================================================
File 1: /data/input/moonbit-docs/CONTRIBUTING-zh.md
================================================
# 贡献指南

_我们鼓励包括问题报告、拉取 PR，以及任何形式的贡献！_

## :bulb: 提问

请访问我们的论坛 ([英文](https://discuss.moonbitlang.com/)/[中文](https://taolun.moonbitlang.com/))。
简而言之，GitHub 问题不是调试特定项目的地方，而是用于提交错误和功能请求。

## :inbox_tray: 提交问题

在提起 issue 之前，请先检查你使用的是否是 [最新版本](https://www.moonbitlang.com/download/) 的 MoonBit 工具链。如果不是，请先更新 MoonBit 工具链到最新版本并确定问题是否仍然存在。

向项目贡献的一个很好的方式是在遇到问题时提交详细的 issue。我们始终感谢编写完善、详尽的错误报告。:v:

简而言之，作为一名开发者，**请提供一个你自己也愿意收到的 issue** ：

- 如果你使用的是 [playground](https://try.moonbitlang.com/)，只需点击分享图标分享代码：

<img width="600" src="imgs/share_moonbit.png">

- 如果你使用的是 [moon build](https://www.moonbitlang.com/docs/build-system-tutorial/)，请提供 `moon version` 和你的操作系统版本的输出。

## :hammer: 贡献代码

我们鼓励贡献者使用 [GitHub 的 Pull Request (PR)](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests) 来提交他们的贡献，包括但不限于以下的贡献：
- 修正代码/文档中的错误
- 提交缺失的中文翻译或改进翻译

文档分为两部分，一部分为交互式的教程，一部分为静态的详细语言文档。

- 对于交互式教程：可以在[这里](https://github.com/moonbitlang/moonbit-docs/tree/main/moonbit-tour/tour)找到其源码，而中文内容则在[这里](https://github.com/moonbitlang/moonbit-docs/tree/main/moonbit-tour/tour/zh)可以找到。

- 对于静态的详细语言文档：可以在[这里](https://github.com/moonbitlang/moonbit-docs/tree/main/next)找到其源码，而中文内容则在[这里](https://github.com/moonbitlang/moonbit-docs/tree/main/next/locales/zh_CN/LC_MESSAGES)可以找到，需要额外注意到的是，中文内容是使用 gettext 工具生成的，因此需要额外注意其中的翻译文件的格式。

## :scroll: 翻译指南

这里是对于中文文档翻译的一些预期要求：

- 翻译需要尽可能忠于原文，不要出现过于冗余的翻译。

- 为保证美观和可读性，中文与英文相邻时要有空格分隔。

- 非特殊情况下请使用中文标点符号，包括但不限于冒号、逗号、句号、引号、全角括号等。



================================================
File 2: /data/input/moonbit-docs/CONTRIBUTING.md
================================================
# Contributing Guidelines

view [CONTRIBUTING-zh.md](./CONTRIBUTING-zh.md) for Chinese version and translate guidelines.

_Pull requests, bug reports, and all other forms of contribution are welcomed and highly encouraged!_

## :bulb: Asking Questions

See our forum ([EN](https://discuss.moonbitlang.com/)/[ZH](https://taolun.moonbitlang.com/)). In short, GitHub issues are not the appropriate place to debug your specific project, but should be reserved for filing bugs and feature requests.

## :inbox_tray: Opening an Issue

Before creating an issue, check if you are using the [latest version](https://www.moonbitlang.com/download/) of MoonBit. If you are not up-to-date, see if updating fixes your issue first.

A great way to contribute to the project is to send a detailed issue when you encounter a problem. We always appreciate a well-written, thorough bug report. :v:

In short, since you are most likely a developer, **provide a ticket that you would like to receive** :

- If you are using [playground](https://try.moonbitlang.com/), simply share the code that could reproduce the bug by clicking the share icon:

<img width="600" src="imgs/share_moonbit.png">

- If you are using [moon build](https://www.moonbitlang.com/docs/build-system-tutorial/), please provide the output of `moon version` and your OS version.

## :hammer: Contributing Code

We encourage contributors to use [GitHub's Pull Request (PR)](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests) to submit their contributions, including but not limited to the following contributions:
- Fix errors in code/documentation
- Submit missing Chinese translations or improve translations

The documentation is divided into two parts: one is the interactive tutorial, and the other is the static detailed language documentation.

- For the interactive tutorial: the source code can be found [here](https://github.com/moonbitlang/moonbit-docs/tree/main/moonbit-tour/tour), and the Chinese content can be found [here](https://github.com/moonbitlang/moonbit-docs/tree/main/moonbit-tour/tour/zh).

- For the static detailed language documentation: the source code can be found [here](https://github.com/moonbitlang/moonbit-docs/tree/main/next), and the Chinese content can be found [here](https://github.com/moonbitlang/moonbit-docs/tree/main/next/locales/zh_CN/LC_MESSAGES), where it should be noted that the Chinese content is generated using the `gettext` tool, so special attention should be paid to the format of the translation files.

If you are interested in translating the documentation, please refer to the [Chinese version Contributing Guidelines](./CONTRIBUTING-zh.md).

================================================
File 3: /data/input/moonbit-docs/LICENSE.md
================================================
# License for MoonBit Documents

## License for all prose content

### Added on or after July 4, 2024

All prose content added on or after July 4, 2024 is available under the
[CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/).

### Added before July 4, 2024

All prose content added before July 4, 2024 is copyright reserved.

## License for code examples

Code examples and snippets are available under
[Apache 2.0](https://www.apache.org/licenses/LICENSE-2.0.txt)

## License for website code

Website code is available under
[Apache 2.0](https://www.apache.org/licenses/LICENSE-2.0.txt)


================================================
File 4: /data/input/moonbit-docs/README-zh.md
================================================
# MoonBit 文档网站

查看 [README.md](./README.md) 获取英文版本。

此存储库托管了 MoonBit 的文档网站 [docs.moonbitlang.com](https://docs.moonbitlang.com)。

打开 `document.code-workspace` 以获得更好的开发体验。可以从终端面板中的 `+` 号选择命令运行，或在命令面板中运行 `Tasks: Run Build Task`。

## 布局

- `legacy/examples`: 一些 MoonBit 的小示例。
- `next`: 基于 Sphinx 的当前文档，托管在 readthedocs 上。查看 [README](./next/README.md)。
- `moonbit-tour`: 一个互动教程。查看 [README](./moonbit-tour/README.md)。

================================================
File 5: /data/input/moonbit-docs/README.md
================================================
# MoonBit Docs Website

view [README-zh.md](./README-zh.md) for Chinese version.

This repository hosts the documentation website for MoonBit [docs.moonbitlang.com](https://docs.moonbitlang.com).

Open `document.code-workspace` for a better development experience. Choose commands to run from either the `+` sign in the Terminal Panel or run `Tasks: Run Build Task` in the command palette.

## Layout

- `legacy/examples`: some small examples for MoonBit.
- `next`: current documentation hosted on readthedocs based on Sphinx. Check [README](./next/README.md).
- `moonbit-tour`: an interactive tour. Check [README](./moonbit-tour/README.md)


================================================
File 6: /data/input/moonbit-docs/legacy/benchmark/fibonacci/README.md
================================================
# WASM benchmark

You can experience this benchmark online at https://moonbitlang.github.io/moonbit-docs/legacy/benchmark/fibonacci/ or set it up at local following below instructions.

## Fibonacci

This folder will use various programming languages to build Wasm, which will calculate the nth Fibonacci number for the benchmark.

### Moonbit

Use Moonbit's [playground](https://try.moonbitlang.com/) or [build tool](https://www.moonbitlang.com/download/) to convert the following function to Wat:

```
func fib(num : Int) -> Int {
  fn aux(n, acc1, acc2) {
    match n {
      0 => acc1
      1 => acc2
      _ => aux(n - 1, acc2, acc1 + acc2)
    }
  }

  aux(num, 0, 1)
}

pub func test(n : Int, count : Int) -> Int {
  let mut i = 0
  let mut res = 0
  while i < count {
    res = fib(n)
    i = i + 1
  }
  res
}
```

Then use [wat2wasm](https://github.com/WebAssembly/wabt) from the WebAssembly Binary Toolkit (WABT) to convert the WebAssembly text format (.wat) to the WebAssembly binary format (.wasm):

``` sh
wat2wasm target/build/main/main.wat -o moonbit.wasm
```

Or you can just use the `moonbit.wasm` in current folder.

Start a web server with `python3 -m http.server 8080`, and we can now test the benchmark of Moonbit by browsing http://127.0.0.1:8080/

<img width="600" src="imgs/moonbit_bench.png">

### Golang

**CAUTION: Do not use the `wasm_exec.js` in the current folder.** Copy your own from `GOROOT`:

``` sh
cp "$(go env GOROOT)/misc/wasm/wasm_exec.js" $PWD
```

Build `golang.wasm`

``` sh
GOOS=js GOARCH=wasm go build -o golang.wasm ./main.go
```
Start a web server with `python3 -m http.server 8080`, and we can now test the benchmark of GO by browsing http://127.0.0.1:8080/

<img width="600" src="imgs/golang_bench.png">

### Rust

``` sh
rustup target add wasm32-unknown-unknown
cd fib-rust
cargo build --target wasm32-unknown-unknown --release
mv target/wasm32-unknown-unknown/release/fib-rust.wasm ../rust.wasm
```

<img width="600" src="imgs/rust_bench.png">


================================================
File 7: /data/input/moonbit-docs/legacy/examples/assert/lib/assert.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

pub fn assert_eq[T : Compare + Show](left : T, right : T) -> Unit {
  if left.compare(right) != 0 {
    abort(
      "assertion failed: (left == right)\n" + "left: " + left.to_string() + "\n" +
      "right: " + right.to_string() + "\n",
    )
  }
}

pub fn assert(x : Bool) -> Unit {
  if x != true {
    abort("assertion failed: " + x.to_string() + "\n")
  }
}

pub fn assert_ne[T : Compare + Show](left : T, right : T) -> Unit {
  if left.compare(right) == 0 {
    abort(
      "assertion failed: (left != right)\n" + "left: " + left.to_string() + "\n" +
      "right: " + right.to_string() + "\n",
    )
  }
}


================================================
File 8: /data/input/moonbit-docs/legacy/examples/assert/main/main.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

fn main {
  @lib.assert_eq(1, 2) // abort
}


================================================
File 9: /data/input/moonbit-docs/legacy/examples/avl_tree/README.md
================================================
## AVL tree

Use Moonbit to implement an [AVL tree](https://en.wikipedia.org/wiki/AVL_tree), with printer to show its internal.


================================================
File 10: /data/input/moonbit-docs/legacy/examples/avl_tree/lib/avl.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at

//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// https://zhuanlan.zhihu.com/p/430867594

// Empty represents an empty node in the AVL tree
// Node represents a node in the AVL tree with left child, value, right child, and height
///|
pub(all) enum T[U] {
  Empty
  Node(T[U], U, T[U], Int)
}

///| `height[U](self: T[U])`
///
/// Calculate the height of a tree-like structure.
pub fn height[U](self : T[U]) -> Int {
  match self {
    Empty => 0
    Node(_, _, _, h) => h
  }
}

///| `create[U](l: T[U], v: U, r: T[U])`
///
/// Create a new node with the given left and right subtrees, along with a value of type `U`.
fn create[U](l : T[U], v : U, r : T[U]) -> T[U] {
  let hl = l.height()
  let hr = r.height()
  Node(l, v, r, if hl >= hr { hl + 1 } else { hr + 1 })
}

///| `bal[U](l: T[U], v: U, r: T[U])`
///
/// Perform balancing operation on a avl tree node.
///
/// This function performs a balancing operation on a avl tree node based on the heights
/// of its left and right subtrees. It ensures that the heights of the subtrees are balanced
/// and returns a new avl tree node with appropriate restructuring if necessary.
fn bal[U](l : T[U], v : U, r : T[U]) -> T[U] {
  let hl = l.height()
  let hr = r.height()

  // Left subtree is taller by more than 2 level
  if hl > hr + 2 {
    match l {
      Empty => Empty // impossible
      Node(ll, lv, lr, _) =>
        if ll.height() >= lr.height() {
          create(ll, lv, create(lr, v, r))
        } else {
          match lr {
            Empty => Empty // impossible
            Node(lrl, lrv, lrr, _) =>
              create(create(ll, lv, lrl), lrv, create(lrr, v, r))
          }
        }
    }
  } else if hr > hl + 2 {
    // Right subtree is taller by more than 2 level
    match r {
      Empty => Empty // impossible
      Node(rl, rv, rr, _) =>
        if rr.height() >= rl.height() {
          create(create(l, v, rl), rv, rr)
        } else {
          match rl {
            Empty => Empty // impossible
            Node(rll, rlv, rlr, _) =>
              create(create(l, v, rll), rlv, create(rlr, rv, rr))
          }
        }
    }
  } else {
    Node(l, v, r, if hl >= hr { hl + 1 } else { hr + 1 })
  }
}

///| `add[U:Compare](self: T[U], x: U)`
///
/// Add a value to a tree-like structure.
pub fn add[U : Compare](self : T[U], x : U) -> T[U] {
  match self {
    Empty => Node(Empty, x, Empty, 1)
    Node(l, v, r, _) as t => {
      let c = x.compare(v)
      if c == 0 {
        t
      } else if c < 0 {
        bal(l.add(x), v, r)
      } else {
        bal(l, v, r.add(x))
      }
    }
  }
}

///| `min_elt[U](self: T[U], default: U)`
///
/// Find the minimum element in a tree-like data structure.
fn min_elt[U](self : T[U], default : U) -> U {
  match self {
    Empty => default
    Node(Empty, v, _, _) => v
    Node(l, v, _, _) => l.min_elt(v)
  }
}

///| `remove_min_elt[U](l: T[U], v: U, r: T[U])`
///
/// Remove the minimum element from a avl tree and rebalance the tree.
fn remove_min_elt[U](l : T[U], v : U, r : T[U]) -> T[U] {
  match l {
    Empty => r
    Node(ll, lv, lr, _) => bal(remove_min_elt(ll, lv, lr), v, r)
  }
}

///| `internal_merge[U](self: T[U], other: T[U])`
///
/// Merge two AVL trees of the same user-defined type `U` into a new AVL tree.
fn internal_merge[U](self : T[U], other : T[U]) -> T[U] {
  match (self, other) {
    (Empty, t) => t
    (t, Empty) => t
    (_, Node(rl, rv, rr, _)) =>
      bal(self, other.min_elt(rv), remove_min_elt(rl, rv, rr))
  }
}

///| `remove[U:Compare](self: T[U], x: U)`
///
/// Removes a value from the AVL tree while maintaining balance
pub fn remove[U : Compare](self : T[U], x : U) -> T[U] {
  match self {
    Empty => Empty
    Node(l, v, r, _) => {
      let c = x.compare(v)
      if c == 0 {
        l.internal_merge(r)
      } else if c < 0 {
        bal(l.remove(x), v, r)
      } else {
        bal(l, v, r.remove(x))
      }
    }
  }
}

///| `to_string[U:Show](self: T[U]) -> String`
///
/// convert the AVL tree to string.
pub impl[U : Show] Show for T[U] with output(self : T[U], logger) -> Unit {
  match self {
    Empty => logger.write_string("()")
    Node(Empty, v, Empty, _) => v.output(logger)
    Node(l, v, r, _) => logger.write_string("(\{l}, \{v}, \{r})")
  }
}

///| `mem[U:Compare](self: T[U], x: U)`
///
/// Check if a given element exists in an AVL tree.
pub fn mem[U : Compare](self : T[U], x : U) -> Bool {
  match self {
    Empty => false
    Node(l, v, r, _) => {
      let c = x.compare(v)
      let tree = if c < 0 { l } else { r }
      c == 0 || tree.mem(x)
    }
  }
}

///|
fn repeat_str(s : String, n : Int) -> String {
  let mut result = ""
  let mut i = 0
  while i < n {
    result = result + s
    i = i + 1
  }
  result
}

///| `print_tree[U:Show](self: T[U])`
///
/// Print the AVL tree
pub fn print_tree[U : Show](self : T[U]) -> Unit {
  let buffer = StringBuilder::new()
  fn helper(node : T[U], level : Int) {
    match node {
      Empty => ()
      Node(l, v, r, _) => {
        helper(l, level + 1)
        let indent = repeat_str("  ", level)
        buffer.write_string(indent + v.to_string())
        helper(r, level + 1)
      }
    }
    println(buffer.to_string())
    buffer.reset()
  }

  helper(self, 0)
}


================================================
File 11: /data/input/moonbit-docs/legacy/examples/avl_tree/main/main.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at

//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

fn main {
  let mut v : @lib.T[Int] = Empty
  let iter = 30 // Create an empty AVL tree with Int type

  // Add values from 0 to iter-1 to the AVL tree
  for i = 0; i < iter; i = i + 1 {
    v = v.add(i)
  }
  let height = v.height()
  println("height of the tree: \{height}")
  v.print_tree()

  // Check values from 0 to iter-1 in the AVL tree
  for i = 0; i < iter; i = i + 1 {
    if not(v.mem(i)) {
      abort("impossible")
    }
  }

  // Remove values from 0 to iter-1 from the AVL tree
  for i = 0; i < iter; i = i + 1 {
    v = v.remove(i)
  }

  // Tree is empty, removal successful
  match v {
    Empty => println("success")
    Node(_) => println("impossible")
  }
}


================================================
File 12: /data/input/moonbit-docs/legacy/examples/buffer/README.md
================================================
# Buffer
## API
Creates a new instance of the Buffer type with the specified initial capacity. The capacity determines the initial size of the buffer to store elements of type T. The type T must implement the Default trait to provide a default value.
```moonbit
Buffer::new[T : Default](capacity : Int) -> Buffer[T]
```
Returns the current capacity of the buffer. The capacity represents the maximum number of elements that the buffer can hold without resizing.
```moonbit
capacity[T](self : Buffer[T]) -> Int
```
Returns the current number of elements stored in the buffer. This method provides the actual count of elements present in the buffer.
```moonbit
length[T](self : Buffer[T]) -> Int
```
Appends an element of type T to the end of the buffer. If the buffer is at its capacity, it may be automatically resized to accommodate the new element.
```moonbit
append[T : Default](self : Buffer[T], value : T)
```
Truncates the current buffer and copies the contents of another buffer another into it. The original capacity of the buffer remains unchanged.
```moonbit
truncate[T : Default](self : Buffer[T], another : Buffer[T])
```
Clears all elements from the buffer and resets its length to zero. The capacity remains unchanged.
```moonbit
clear[T : Default](self : Buffer[T])
```
Resets the buffer by clearing its contents and setting its capacity to the specified value. This is useful when you want to reuse an existing buffer with a different capacity.
```moonbit
reset[T : Default](self : Buffer[T], capacity : Int)
```
Prints the contents of the buffer to the standard output using the Show trait. The Show trait must be implemented for type T in order to use this method.
```moonbit
println[T : Show](self: Buffer[T])
```


================================================
File 13: /data/input/moonbit-docs/legacy/examples/buffer/lib/buffer.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

pub(all) struct SBuffer[T] {
  mut cap : Int
  mut len : Int
  mut data : Array[T]
}

pub fn SBuffer::new[T : Default](capacity : Int) -> SBuffer[T] {
  { cap: capacity, len: 0, data: Array::make(capacity, T::default()) }
}

pub fn capacity[T](self : SBuffer[T]) -> Int {
  self.cap
}

pub fn length[T](self : SBuffer[T]) -> Int {
  self.len
}

pub fn op_get[T](self : SBuffer[T], i : Int) -> T? {
  if i < self.cap {
    Some(self.data[i])
  } else {
    None
  }
}

fn expand_size[T : Default](self : SBuffer[T]) -> Unit {
  let new_capacity = if self.cap != 0 {
    self.cap * 2
  } else {
    (self.cap + 1) * 2
  }
  self.cap = new_capacity
  let new_data = Array::make(new_capacity, T::default())
  let mut index = 0
  while index < self.len {
    new_data[index] = self.data[index]
    index = index + 1
  }
  self.data = new_data
}

pub fn append[T : Default](self : SBuffer[T], value : T) -> Unit {
  if self.len >= self.cap {
    self.expand_size()
  }
  self.data[self.len] = value
  self.len = self.len + 1
}

pub fn truncate[T : Default](self : SBuffer[T], another : SBuffer[T]) -> Unit {
  let mut index = 0
  while index < another.len {
    if self.len >= self.cap {
      self.expand_size()
    }
    self.data[self.len] = another.data[index]
    self.len = self.len + 1
    index = index + 1
  }
}

pub fn clear[T : Default](self : SBuffer[T]) -> Unit {
  let mut index = 0
  while index < self.len {
    self.data[index] = T::default()
    index = index + 1
  }
  self.len = 0
}

pub fn reset[T : Default](self : SBuffer[T], capacity : Int) -> Unit {
  self.cap = capacity
  self.len = 0
  self.data = Array::make(capacity, T::default())
}

pub fn SBuffer::println[T : Show](self : SBuffer[T]) -> Unit {
  let mut index = 0
  let buffer = StringBuilder::new()
  buffer.write_char('[')
  while index < self.len {
    buffer.write_string(self.data[index].to_string())
    index = index + 1
    if index < self.len {
      buffer.write_char(',')
    }
  }
  buffer.write_char(']')
  println(buffer.to_string())
  buffer.reset()
}


================================================
File 14: /data/input/moonbit-docs/legacy/examples/buffer/main/main.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

fn main {
  let buf : @lib.SBuffer[Int] = @lib.SBuffer::new(5)
  println(buf.capacity()) // 5
  for index = 0; index < 8; index = index + 1 {
    buf.append(index)
  }
  println(buf.capacity()) // 10
  println(buf.length()) // 8
  buf.println() // [0,1,2,3,4,5,6,7]
  buf.clear()
  buf.println() // []
  println(buf.capacity()) // 10
  println(buf.length()) // 0
  buf.reset(10)
  println(buf.capacity()) // 10
  println(buf.length()) // 0
}


================================================
File 15: /data/input/moonbit-docs/legacy/examples/bytes-buffer/README.md
================================================
# Bytes-Buffer
## API
```moonbit
pub func Buffer::new(size : Int) -> Buffer
```
Creates a new buffer with the specified size.
```moonbit
pub func capacity(self : Buffer) -> Int
```
Returns the total capacity of the buffer.
```moonbit
pub func length(self : Buffer) -> Int
```
Returns the current length of the buffer.
```moonbit
pub func append_int(self : Buffer, value : Int)
```
Appends an integer value to the buffer.
```moonbit
pub func truncate(self : Buffer, another: Buffer)
```
Truncates the buffer and replaces its content with the content of another buffer.
```moonbit
pub func clear(self : Buffer)
```
Clears the content of the buffer.
```moonbit
pub func reset(self : Buffer, capacity : Int)
```
Resets the buffer with a new capacity.
```moonbit
pub func to_bytes(self : Buffer) -> Bytes
```
Converts the buffer content to bytes.
```moonbit
pub func bytes_to_int(bytes : Bytes, start : Int) -> Int
```
Converts a section of bytes to an integer.



================================================
File 16: /data/input/moonbit-docs/legacy/examples/bytes-buffer/lib/buffer.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

///|
pub struct Buffer {
  mut data : FixedArray[Byte]
  mut len : Int
}

///|
pub fn Buffer::new(size : Int) -> Buffer {
  { data: FixedArray::make(size, 0), len: 0 }
}

///|
pub fn op_get(self : Buffer, i : Int) -> Byte? {
  if i < self.data.length() {
    Some(self.data[i])
  } else {
    None
  }
}

///|
pub fn capacity(self : Buffer) -> Int {
  self.data.length()
}

///|
pub fn length(self : Buffer) -> Int {
  self.len
}

///|
fn expand_size(self : Buffer) -> Unit {
  let new_capacity = if self.data.length() != 0 {
    self.data.length() * 2
  } else {
    (self.data.length() + 1) * 2
  }
  let new_data = FixedArray::make(new_capacity, b'\x00')
  let mut index = 0
  while index < self.len {
    new_data[index] = self.data[index]
    index = index + 1
  }
  self.data = new_data
}

///|
pub fn append_int(self : Buffer, value : Int) -> Unit {
  if self.len + 4 >= self.data.length() {
    self.expand_size()
  }
  let value = value.reinterpret_as_uint()
  self.data[self.len] = ((value >> 24) & 0xFF).to_byte()
  self.data[self.len + 1] = ((value >> 16) & 0xFF).to_byte()
  self.data[self.len + 2] = ((value >> 8) & 0xFF).to_byte()
  self.data[self.len + 3] = (value & 0xFF).to_byte()
  self.len = self.len + 4
}

///|
pub fn truncate(self : Buffer, another : Buffer) -> Unit {
  let mut index = 0
  while index < another.len {
    if self.len >= self.data.length() {
      self.expand_size()
    }
    self.data[self.len] = another.data[index]
    self.len = self.len + 1
    index = index + 1
  }
}

///|
pub fn clear(self : Buffer) -> Unit {
  let mut index = 0
  while index < self.len {
    self.data[index] = b'\x00'
    index = index + 1
  }
  self.len = 0
}

///|
pub fn reset(self : Buffer, capacity : Int) -> Unit {
  self.len = 0
  self.data = FixedArray::make(capacity, b'\x00')
}

///|
pub fn to_bytes(self : Buffer) -> Bytes {
  self.data |> Bytes::from_fixedarray
}


================================================
File 17: /data/input/moonbit-docs/legacy/examples/bytes-buffer/lib/buffer_test.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

///|
test {
  let buf = @lib.Buffer::new(4)
  buf.append_int(256)
  buf.append_int(255)
  let content = buf.to_bytes()
  inspect!(content[:].to_int_be(), content="256")
  inspect!(content[4:].to_int_be(), content="255")
  let buf1 = @lib.Buffer::new(4)
  buf1.append_int(257)
  buf.truncate(buf1)
  let content = buf.to_bytes()
  inspect!(content[8:].to_int_be(), content="257")
}


================================================
File 18: /data/input/moonbit-docs/legacy/examples/cf_worker/README.md
================================================
## Moonbit's Cloudflare Worker Demo

This project showcases how to generate a compact WebAssembly (Wasm) by Moonbit, and invoke it from JavaScript in a Cloudflare worker environment. It is an implementation of the [Invoke Wasm from JavaScript](https://developers.cloudflare.com/workers/runtime-apis/webassembly/javascript/) guide.

## Setup Wrangler

Before you begin, make sure you have `node` and `pnpm` (or `npm`) installed.

To set up a new project, just run `pnpm create cloudflare@2.5.0` and answer the prompts:
- Application Type: Select "Hello World" worker.
- Use TypeScript: Select 'yes'.
- Deploy Your Application: Select 'no'.

## Adding MoonBit

Create the three following files (`moon.mod.json` `moon.pkg.json` `top.mbt`) to the directory just created

```json title=moon.mod.json
{
  "name": "username/hello",
  "version": "0.1.0"
}
```

```json title=moon.pkg.json
{
  "link": {
    "wasm-gc": {
      "exports": [ "fib" ]
    }
  }
}
```

```moonbit title=top.mbt
pub fn fib(n : Int) -> Int64 {
  loop 0L, 1L, n {
    a, _, 0 => a
    a, b, n => continue b, a + b, n - 1
  }
}
```

This will export a function named `fib` with the wasm-gc backend.

## Integrate MoonBit to worker
- Add the following to the `src/index.ts`
  ```typescript title=src/index.ts
  import wasm from '../target/wasm-gc/release/build/hello.wasm';
  const module = await WebAssembly.instantiate(wasm);
  module.exports._start();

  export interface Env {}

  export default {
    async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
      return new Response(`Hello World! ${module.exports.fib(10)}`);
    }
  };
  ```
- Modify the `start` script in `package.json` to `"start": "moon build --target wasm-gc && wrangler dev",`.
- Append the following to `.gitignore`:

  ```gitignore
  # MoonBit project
  
  target/
  .mooncakes/
  ```

## Run the Worker

Navigate to your Cloudflare worker's directory (e.g., `moonbit_cf`) and use Wrangler to start the development server.

Run `pnpm i` to install the dependencies and `pnpm start`, and you should see output indicating the server is running, like this:

```shell
> your-project@0.0.0 start /your-path/moonbit-docs/examples/cf_worker
> moon build --target wasm-gc && wrangler dev

moon: no work to do
 ⛅️ wrangler 3.48.0
-------------------
⎔ Starting local server...
[wrangler:inf] Ready on http://localhost:58966
```

Then you can use `b` to open a browser or `x` to exit the server. The bowser should give you `Hello World! 55`;


================================================
File 19: /data/input/moonbit-docs/legacy/examples/cf_worker/top.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

pub fn fib(n : Int) -> Int64 {
  loop 0L, 1L, n {
    a, _, 0 => a
    a, b, n => continue b, a + b, n - 1
  }
}

================================================
File 20: /data/input/moonbit-docs/legacy/examples/char/README.md
================================================
# Char
Use Moonbit to implement string tools.

## API
This function is used to check whether the given character c is a valid character. It returns a boolean value indicating whether the character is valid or not.
```moonbit
is_valid(c: Char) -> Bool
```
This function is used to determine if the character c is an alphabet letter. It returns true if c is an alphabet letter, otherwise it returns false.
```moonbit
is_alpha(c : Char) -> Bool
```
This function is used to check if the character c is a numeric digit. It returns true if c is a numeric digit, otherwise it returns false.
```moonbit
is_numeric(c : Char) -> Bool
```
This function is used to determine if the character c is either an alphabet letter or a numeric digit. It returns true if c is an alphanumeric character, otherwise it returns false.
```moonbit
is_alphanumeric(c : Char) -> Bool
```
This function is used to convert the character c to its lowercase form and returns the lowercase character.
```moonbit
to_lower(c : Char) -> Char
```
This function is used to convert the character c to its uppercase form and returns the uppercase character.
```moonbit
to_upper(c : Char) -> Char
```
This function is used to check if the character c is a whitespace character (such as space or tab). It returns true if c is a whitespace character, otherwise it returns false.
```moonbit
is_whitespace(c : Char) -> Bool
```
This function returns the next character following the character c. If there is a next character, it returns the character wrapped in Some, otherwise it returns None.
```moonbit
next(c : Char) -> Option[Char]
```
This function returns the previous character before the character c. If there is a previous character, it returns the character wrapped in Some, otherwise it returns None.
```moonbit
prev(c : Char) -> Option[Char]
```


================================================
File 21: /data/input/moonbit-docs/legacy/examples/char/lib/char.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

pub fn is_valid(c : Char) -> Bool {
  c.to_int() >= 0 && (c.to_int() <= 0xD7FF || c.to_int() >= 0xE000) && c.to_int() <=
  0x10FFFF
}

pub fn is_alpha(c : Char) -> Bool {
  (c.compare('a') >= 0 && c.compare('z') <= 0) || (c.compare('A') >= 0 && c.compare(
    'Z',
  ) <= 0)
}

pub fn is_numeric(c : Char) -> Bool {
  c.compare('0') >= 0 && c.compare('9') <= 0
}

pub fn is_alphanumeric(c : Char) -> Bool {
  is_alpha(c) || is_numeric(c)
}

pub fn to_lower(c : Char) -> Char {
  if c.compare('A') >= 0 && c.compare('Z') <= 0 {
    return Char::from_int(c.to_int() - 'A'.to_int() + 'a'.to_int())
  }
  return c
}

pub fn to_upper(c : Char) -> Char {
  if c.compare('a') >= 0 && c.compare('z') <= 0 {
    return Char::from_int(c.to_int() - 'a'.to_int() + 'A'.to_int())
  }
  return c
}

pub fn is_whitespace(c : Char) -> Bool {
  c == ' ' || c == '\t' || c == '\n' || c == '\r'
}

pub fn next(c : Char) -> Char? {
  let ne = Char::from_int(c.to_int() + 1)
  if is_valid(ne) {
    return Some(ne)
  }
  None
}

pub fn prev(c : Char) -> Char? {
  let prev = Char::from_int(c.to_int() - 1)
  if is_valid(prev) {
    return Some(prev)
  }
  None
}


================================================
File 22: /data/input/moonbit-docs/legacy/examples/char/lib/char_test.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

test {
  assert_true!(@lib.is_alpha('a'))
  assert_false!(@lib.is_alpha('3'))
  assert_true!(@lib.is_numeric('1'))
  assert_false!(@lib.is_numeric('b'))
  assert_true!(@lib.is_alphanumeric('a'))
  assert_eq!(@lib.to_lower('H'), 'h')
  assert_eq!(@lib.to_upper('c'), 'C')
  assert_true!(@lib.is_whitespace(' '))
  assert_eq!(@lib.next('Z'), Some('['))
  assert_eq!(@lib.prev('A'), Some('@'))
}


================================================
File 23: /data/input/moonbit-docs/legacy/examples/docstring-demo/README.md
================================================
## Moonbit docstring demo

We can see the docstring display in the IDE as follows:

<img width="480" src="imgs/docs.png">

================================================
File 24: /data/input/moonbit-docs/legacy/examples/docstring-demo/lib/hello.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

/// `hello()`
///
/// Return a string containing the greeting message.
pub fn hello() -> String {
    "Hello, world!\n"
}


================================================
File 25: /data/input/moonbit-docs/legacy/examples/docstring-demo/main/main.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

fn main {
  println(@lib.hello())
}


================================================
File 26: /data/input/moonbit-docs/legacy/examples/game_of_life/README.md
================================================
# Game of Life
We use MoonBit to implement the game of life. Some codes refer: https://github.com/mununki/moonbit-wasm-game-of-life

`lib/game_of_life.mbt` implements the execution logic of the game of life.

`lib/draw.mbt` uses `canvas` to draw.

## How to Run
```
make run
```
## Details

### Use External Ref to Call Canvas API
* Create external ref
```
type Canvas_ctx

func set_stroke_color(self : Canvas_ctx, color : Int) = "canvas" "set_stroke_color"

func move_to(self : Canvas_ctx, x : Int, y : Int) = "canvas" "move_to"

func line_to(self : Canvas_ctx, x : Int, y : Int) = "canvas" "line_to"

func begin_path(self : Canvas_ctx) = "canvas" "begin_path"

func stroke(self : Canvas_ctx) = "canvas" "stroke"

func fill_rect(self : Canvas_ctx, x : Int, y : Int, width : Int, height : Int) = "canvas" "fill_rect"

func set_fill_style(self : Canvas_ctx, color : Int) = "canvas" "set_fill_style"
```
* Draw grid, ref: `lib/draw.mbt/draw_grid(canvas : Canvas_ctx)`
* Draw cell, ref: `lib/draw.mbt/draw_cell(canvas : Canvas_ctx)`
### Load Wasm and Execute It
Create a WebAssembly.Memory
```javascript
const importObject = {
  canvas: {
    stroke_rect: (ctx, x, y, width, height) => ctx.strokeRect(x, y, width, height),
    stroke: (ctx) => ctx.stroke(),
    move_to: (ctx, x, y) => ctx.moveTo(x, y),
    line_to: (ctx, x, y) => ctx.lineTo(x, y),
    begin_path: (ctx) => ctx.beginPath(),
    fill_rect: (ctx, x, y, width, height) => ctx.fillRect(x, y, width, height),
    set_stroke_color: (ctx, color) => ctx.setStrokeColor(color),
    set_fill_style: (ctx, color) => ctx.setFillStyle(color),
  },
  spectest: {},
};
```
Load Wasm and use `requestAnimationFrame(renderLoop)` to draw
```javascript
  WebAssembly.instantiateStreaming(fetch("target/game_of_life.wasm"), importObject).then(
    (obj) => {
      obj.instance.exports._start();
      const drawGrid = obj.instance.exports["game_of_life/lib::draw_grid"];
      const drawCell = obj.instance.exports["game_of_life/lib::draw_cell"];
      const universe_new = obj.instance.exports["game_of_life/lib::new"];
      const universe_tick = obj.instance.exports["game_of_life/lib::@game_of_life/lib.Universe::tick"];
      const universe = universe_new();
      const renderLoop = () => {
        universe_tick(universe);
        drawGrid(ctx);
        drawCell(ctx, universe);
        requestAnimationFrame(renderLoop);
      }
      requestAnimationFrame(renderLoop);
    }
  )
```

================================================
File 27: /data/input/moonbit-docs/legacy/examples/game_of_life/lib/draw.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

type Canvas_ctx

fn set_stroke_color(self : Canvas_ctx, color : Int) = "canvas" "set_stroke_color"

fn move_to(self : Canvas_ctx, x : Int, y : Int) = "canvas" "move_to"

fn line_to(self : Canvas_ctx, x : Int, y : Int) = "canvas" "line_to"

fn begin_path(self : Canvas_ctx) = "canvas" "begin_path"

fn stroke(self : Canvas_ctx) = "canvas" "stroke"

fn fill_rect(self : Canvas_ctx, x : Int, y : Int, width : Int, height : Int) = "canvas" "fill_rect"

fn set_fill_style(self : Canvas_ctx, color : Int) = "canvas" "set_fill_style"

let cell_size = 5

pub fn draw_grid(canvas : Canvas_ctx) -> Unit {
  canvas.begin_path()
  canvas.set_stroke_color(0xcccccc)
  let mut i = 0
  while i <= 64 {
    canvas.move_to(i * (cell_size + 1) + 1, 0)
    canvas.line_to(i * (cell_size + 1) + 1, (cell_size + 1) * 64 + 1)
    i = i + 1
  }
  let mut j = 0
  while j <= 64 {
    canvas.move_to(0, j * (cell_size + 1) + 1)
    canvas.line_to((cell_size + 1) * 64 + 1, j * (cell_size + 1) + 1)
    j = j + 1
  }
  canvas.stroke()
}

pub fn draw_cell(
  canvas : Canvas_ctx,
  universe : Universe,
  dead : Int,
  alive : Int
) -> Unit {
  canvas.begin_path()
  let mut row = 0
  while row < 64 {
    let mut col = 0
    while col < 64 {
      let idx = universe.get_index(row, col)
      let color = if universe.get_cell(idx) == 0 { dead } else { alive }
      canvas.set_fill_style(color)
      canvas.fill_rect(col * 6 + 1, row * 6 + 1, 5, 5)
      col = col + 1
    }
    row = row + 1
  }
  canvas.stroke()
}


================================================
File 28: /data/input/moonbit-docs/legacy/examples/game_of_life/lib/game_of_life.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

enum Cell {
  Dead
  Alive
}

struct Universe {
  width : Int
  height : Int
  mut cells : Array[Cell]
}

fn get_index(self : Universe, row : Int, column : Int) -> Int {
  if row * self.width + column < self.width * self.height {
    row * self.width + column
  } else {
    0
  }
}

pub fn new() -> Universe {
  let width = 64
  let height = 64
  let cells : Array[Cell] = Array::make(width * height, Dead)
  let mut idx = 0
  while idx < width * height {
    if idx % 2 == 0 || idx % 7 == 0 {
      cells[idx] = Alive
    } else {
      cells[idx] = Dead
    }
    idx = idx + 1
  }
  { width, height, cells }
}

pub fn get_width(self : Universe) -> Int {
  self.width
}

pub fn get_height(self : Universe) -> Int {
  self.height
}

pub fn get_cells(self : Universe) -> Array[Cell] {
  self.cells
}

pub fn get_cell(self : Universe, idx : Int) -> Int {
  match self.cells[idx] {
    Alive => 1
    Dead => 0
  }
}

fn live_neighbor_count(self : Universe, row : Int, column : Int) -> Int {
  let mut count = 0
  let delta_rows = [self.height - 1, 0, 1]
  let delta_cols = [self.width - 1, 0, 1]
  let mut r = 0
  while r < 3 {
    let mut c = 0
    while c < 3 {
      if delta_rows[r] == 0 && delta_cols[c] == 0 {
        c = c + 1
        continue
      }
      let neighbor_row = (row + delta_rows[r]) % self.height
      let neighbor_col = (column + delta_cols[c]) % self.width
      let idx = self.get_index(neighbor_row, neighbor_col)
      count = count + self.get_cell(idx)
      c = c + 1
    }
    r = r + 1
  }
  count
}

pub fn tick(self : Universe) -> Unit {
  let next : Array[Cell] = Array::make(self.width * self.height, Dead)
  let mut r = 0
  while r < self.height {
    let mut c = 0
    while c < self.width {
      let idx = self.get_index(r, c)
      let cell = self.cells[idx]
      let live_neighbor = self.live_neighbor_count(r, c)
      let next_cell : Cell = match (cell, live_neighbor) {
        (Alive, c) =>
          if c < 2 {
            Dead
          } else if c == 2 || c == 3 {
            Alive
          } else {
            Dead
          }
        (Dead, 3) => Alive
        _ => cell
      }
      next[idx] = next_cell
      c = c + 1
    }
    r = r + 1
  }
  self.cells = next
}

pub fn to_string(self : Universe) -> String {
  let mut r = 0
  let mut cells = ""
  while r < self.height {
    let mut c = 0
    while c < self.width {
      let idx = self.get_index(r, c)
      let cell = self.cells[idx]
      // No buffer implementation?
      cells = cells +
        (match cell {
          Alive => "▅"
          Dead => "☐"
        })
      c = c + 1
    }
    cells = cells + "\n"
    r = r + 1
  }
  cells
}


================================================
File 29: /data/input/moonbit-docs/legacy/examples/koch_snowflake/lib/koch.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

type Canvas_ctx

fn begin_path(self : Canvas_ctx) = "canvas" "begin_path"

fn clear_rect(self : Canvas_ctx, x : Double, y : Double, w : Double,
        h : Double) = "canvas" "clear_rect"

fn move_to(self : Canvas_ctx, x : Double, y : Double) = "canvas" "move_to"

fn line_to(self : Canvas_ctx, x : Double, y : Double) = "canvas" "line_to"

fn stroke(self : Canvas_ctx) = "canvas" "stroke"

fn sqrt(x : Double) -> Double = "canvas" "sqrt"

fn cos(x : Double) -> Double = "canvas" "cos"

fn get_pi() -> Double = "canvas" "get_pi"

fn koch(ctx : Canvas_ctx, x1 : Double, y1 : Double, x2 : Double,
        y2 : Double, n : Double, m : Double) -> Unit {
  ctx.clear_rect(0.0, 0.0, 400.0, 400.0)
  let x3 = (x2 - x1) / 3.0 + x1
  let y3 = (y2 - y1) / 3.0 + y1
  let x4 = (x2 - x1) / 3.0 * 2.0 + x1
  let y4 = (y2 - y1) / 3.0 * 2.0 + y1
  let x5 = x3 + (x2 - x1 - (y2 - y1) * sqrt(3.0)) / 6.0
  let y5 = y3 + ((x2 - x1) * sqrt(3.0) + (y2 - y1)) / 6.0
  let n = n + 1.0
  if n == m {
    ctx.move_to(x1, y1)
    ctx.line_to(x3, y3)
    ctx.line_to(x5, y5)
    ctx.line_to(x4, y4)
    ctx.line_to(x2, y2)
    ctx.stroke()
    return
  }
  koch(ctx, x1, y1, x3, y3, n, m)
  koch(ctx, x3, y3, x5, y5, n, m)
  koch(ctx, x5, y5, x4, y4, n, m)
  koch(ctx, x4, y4, x2, y2, n, m)
}

pub fn draw(ctx : Canvas_ctx, deep : Double) -> Unit {
  ctx.begin_path()
  let y = 80.0 + cos(get_pi() / 6.0) * 200.0
  koch(ctx, 150.0, y, 250.0, 80.0, 0.0, deep)
  koch(ctx, 250.0, 80.0, 50.0, 80.0, 0.0, deep)
  koch(ctx, 50.0, 80.0, 150.0, y, 0.0, deep)
}



================================================
File 30: /data/input/moonbit-docs/legacy/examples/mandelbrot/REAME.md
================================================
# Mandelbrot
## How to Run
```
make run
```

Open `localhost::3000`

# Result
-0.7+0.0i@3.0769
![-0.7+0.0i@3.0769](./docs/-0.7+0.0i@3.0769.png)
-0.743030+0.126433i@0.016110
![-0.743030+0.126433i@0.016110](./docs/-0.743030+0.126433i@0.016110.png)
-0.74364085+0.13182733i@0.00012068
![-0.74364085+0.13182733i@0.00012068](./docs/-0.74364085+0.13182733i@0.00012068.png)
-0.743643135+0.131825963i@0.000014628
![-0.743643135+0.131825963i@0.000014628](./docs/-0.743643135+0.131825963i@0.000014628.png)

================================================
File 31: /data/input/moonbit-docs/legacy/examples/mandelbrot/lib/mandelbrot.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

fn log(x : Double) -> Double = "math" "log"

fn floor(x : Double) -> Int = "math" "floor"

fn float_of_int(x : Int) -> Double = "math" "float_of_int"

type ImageData

fn set_image_data(self : ImageData, x : Int, rgb : Int) = "imagedata" "set"

let escape_radius = 4.0

let max_iter_number = 1000

// -0.743030 + 0.126433i @ 0.016110 /0.75
// -0.74364085 + 0.13182733i @ 0.00012068 /.75
// -0.7 + 0.0i @ 3.0769 / 0.75

let ratio = 0.75

let image_width = 800.0

let image_height : Double = image_width * ratio // 600

let coffset : Double = if floor(image_width) % 2 == 0 {
  image_width / 2.0 - 0.5
} else {
  image_width / 2.0
}

let roffset : Double = if floor(image_height) % 2 == 0 {
  image_height / 2.0 - 0.5
} else {
  image_height / 2.0
}

pub fn iter(cx : Double, cy : Double) -> Double {
  let mut x = 0.0
  let mut y = 0.0
  let mut newx = 0.0
  let mut newy = 0.0
  let mut smodz = 0.0
  let mut i = 0
  while i < max_iter_number {
    newx = x * x - y * y + cx
    newy = 2.0 * x * y + cy
    x = newx
    y = newy
    i = i + 1
    smodz = x * x + y * y
    if smodz >= escape_radius {
      return float_of_int(i) + 1.0 - log(log(smodz) * 0.5) / log(2.0)
    }
  }
  return -1.0
}

fn interpolation(f : Double, c0 : Int, c1 : Int) -> Int {
  let r0 = c0.asr(16).land(0xFF)
  let g0 = c0.asr(8).land(0xFF)
  let b0 = c0.land(0xFF)
  let r1 = c1.asr(16).land(0xFF)
  let g1 = c1.asr(8).land(0xFF)
  let b1 = c1.land(0xFF)
  let r = floor((1.0 - f) * float_of_int(r0) + f * float_of_int(r1) + 0.5)
  let g = floor((1.0 - f) * float_of_int(g0) + f * float_of_int(g1) + 0.5)
  let b = floor((1.0 - f) * float_of_int(b0) + f * float_of_int(b1) + 0.5)
  return r.lsl(16).lor(g.lsl(8).lor(b))
}

pub fn get_color(d : Double) -> Int {
  if d >= 0.0 {
    let mut k = 0.021 * (d - 1.0 + log(log(128.0)) / log(2.0))
    k = log(1.0 + k) - 29.0 / 400.0
    k = k - float_of_int(floor(k))
    k = k * 400.0
    if k < 63.0 {
      return interpolation(k / 63.0, 0x000764, 0x206BCB)
    } else if k < 167.0 {
      return interpolation((k - 63.0) / (167.0 - 63.0), 0x206BCB, 0xEDFFFF)
    } else if k < 256.0 {
      return interpolation((k - 167.0) / (256.0 - 167.0), 0xEDFFFF, 0xFFAA00)
    } else if k < 342.0 {
      return interpolation((k - 256.0) / (342.0 - 256.0), 0xFFAA00, 0x310230)
    } else {
      return interpolation((k - 342.0) / (400.0 - 342.0), 0x310230, 0x000764)
    }
  } else {
    return 0x000000
  }
}

pub fn calc_color(col : Int, row : Int, ox : Double, oy : Double,
        width : Double) -> Int {
  let pixel_size = width / image_width
  let cx = (float_of_int(col) - coffset) * pixel_size + ox
  let cy = (float_of_int(row) - roffset) * pixel_size + oy
  let mut r = 0
  let mut g = 0
  let mut b = 0
  let mut i = -1
  while i <= 1 {
    let mut j = -1
    while j <= 1 {
      let d = iter(
        cx + float_of_int(i) * pixel_size / 3.0,
        cy + float_of_int(j) * pixel_size / 3.0,
      )
      let c = get_color(d)
      r = r + c.asr(16).land(0xFF)
      g = g + c.asr(8).land(0xFF)
      b = b + c.land(0xFF)
      j = j + 1
    }
    i = i + 1
  }
  r = r / 9
  g = g / 9
  b = b / 9
  return r.lsl(16).lor(g.lsl(8)).lor(b)
}

pub fn draw_color(image_data : ImageData, col : Int, row : Int, rgb : Int) -> Unit {
  let pindex = ((image_height - float_of_int(row) - 1.0) * image_width + float_of_int(
      col,
    )) * 4.0
  let pindex = floor(pindex)
  set_image_data(image_data, pindex, rgb.lsr(16).land(0xFF))
  set_image_data(image_data, pindex + 1, rgb.lsr(8).land(0xFF))
  set_image_data(image_data, pindex + 2, rgb.land(0xFF))
  set_image_data(image_data, pindex + 3, 0xFF)
}



================================================
File 32: /data/input/moonbit-docs/legacy/examples/multidimensional_arrays/README.md
================================================
## Multidimensional Arrays

Use the [triangle problem](https://leetcode.com/problems/triangle/) to demonstrate how to use Moonbit's multidimensional arrays.


================================================
File 33: /data/input/moonbit-docs/legacy/examples/multidimensional_arrays/lib/arrays.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

fn min(a : Int, b : Int) -> Int {
  if a > b {
    return b
  } else {
    return a
  }
}

/// `minPathSum(triangle : Array[Array[Int]])`
///
/// Calculate the minimum path sum through a triangle of integers.
pub fn minPathSum(triangle : Array[Array[Int]]) -> Int {
  fn helper(row : Int, col : Int) -> Int {
    if row == triangle.length() {
      return 0
    }
    let next1 = helper(row + 1, col)
    let next2 = if col < row {
      helper(row + 1, col + 1)
    } else {
      2147483647
    }
    let cur = triangle[row][col]
    return cur + min(next1, next2)
  }

  helper(0, 0)
}


================================================
File 34: /data/input/moonbit-docs/legacy/examples/multidimensional_arrays/lib/arrays_test.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

test {
  let triangle = [[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]
  let result = @lib.minPathSum(triangle)
  inspect!(result, content="11")
}


================================================
File 35: /data/input/moonbit-docs/legacy/examples/number/README.md
================================================
# Number
Use Moonbit to implement string tools.
## API
```
pub fn max[T : Compare](a : T, b : T) -> T
```
This function takes two values of type `T` and returns the maximum value between them. The type `T` must implement the Compare trait for comparison.

Parameters

- `a` (`T`): The first value.

- `b` (`T`): The second value.

Returns

- (`T`): The maximum value between `a` and `b`.
```
pub fn min[T : Compare](a : T, b : T) -> T
```
This function takes two values of type `T` and returns the minimum value between them. The type `T` must implement the Compare trait for comparison.

Parameters

- `a` (`T`): The first value.

- `b` (`T`): The second value.

Returns

- (`T`): The minimum value between `a` and `b`.
```
pub fn abs_int(n : Int) -> Int
```
This function calculates the absolute value of an integer.

Parameters

- `n` (`Int`): The integer value.

Returns

- (`Int`): The absolute value of `n`.

```
pub fn factorial(n : Int) -> Option[Int]
```
This function calculates the factorial of a non-negative integer `n`.

Parameters

- `n` (`Int`): The non-negative integer value.

Returns

- `Some(Int)`: The factorial of n if n is non-negative.

- `None`: If n is negative.
```
pub fn parse_int(s : String) -> Option[Int]
```
This function parses an integer from a string and returns it as an option. If the string does not represent a valid integer, it returns `None`.

Parameters

- `s` (`String`): The string containing the integer representation.

Returns

`Some(Int)`: The parsed integer if the string is a valid representation.

`None`: If the string is not a valid integer representation.

================================================
File 36: /data/input/moonbit-docs/legacy/examples/number/lib/number.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

pub let pi = 3.141592653589793

pub let tau = 6.283185307179586

pub let e = 2.718281828459045

pub let int_min = -2147483648

pub let int_max = 2147483647

pub fn max[T : Compare](a : T, b : T) -> T {
  if a.compare(b) >= 0 {
    return a
  }
  return b
}

pub fn min[T : Compare](a : T, b : T) -> T {
  if a.compare(b) >= 0 {
    return b
  }
  return a
}

pub fn abs_int(n : Int) -> Int {
  if n.compare(0) >= 0 {
    return n
  }
  return -n
}

pub fn factorial(n : Int) -> Int? {
  fn factorial_helper(n : Int, acc : Int) -> Int? {
    match n {
      0 | 1 => Some(acc)
      _ => if acc * n < 0 { None } else { factorial_helper(n - 1, acc * n) }
    }
  }

  factorial_helper(n, 1)
}

pub fn parse_int(s : String) -> Int? {
  let char_0 = 0x30
  let char_u_a = 0x41
  let char_a = 0x61
  let mut index = 0
  let mut is_negative = false
  let mut result_digit = 0
  if s[index] == '-' {
    index = index + 1
    is_negative = true
  }
  let radix = if s[index] == '0' && (s[index + 1] == 'x' || s[index + 1] == 'X') {
    index = index + 2
    16
  } else if s[index] == '0' && (s[index + 1] == 'o' || s[index + 1] == 'O') {
    index = index + 2
    8
  } else if s[index] == '0' && (s[index + 1] == 'b' || s[index + 1] == 'B') {
    index = index + 2
    2
  } else {
    10
  }
  while index < s.length() {
    let c = s[index]
    if c == '_' {
      index = index + 1
      continue
    }
    let digit = if c.compare('0') >= 0 && c.compare('9') <= 0 {
      c.to_int() - char_0
    } else if c.to_int() - char_a < 26 {
      c.to_int() - char_a + 10
    } else if c.to_int() - char_u_a < 26 {
      c.to_int() - char_u_a + 10
    } else {
      break
    }
    result_digit = if is_negative {
      result_digit * radix - digit
    } else {
      result_digit * radix + digit
    }
    if (not(is_negative) && result_digit < 0) || (is_negative && result_digit > 0) {
      return None
    }
    index = index + 1
  }
  return Some(result_digit)
}


================================================
File 37: /data/input/moonbit-docs/legacy/examples/number/lib/number_test.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

test {
  inspect!(@lib.pi, content="3.141592653589793")
  inspect!(@lib.max(4, 2), content="4")
  inspect!(@lib.min(1.2, 1.21), content="1.2")
  inspect!(@lib.int_max, content="2147483647")
  inspect!(@lib.int_min, content="-2147483648")
  inspect!(@lib.parse_int("214748"), content="Some(214748)")
  // overflowed
  inspect!(@lib.parse_int("2147483648"), content="None")
  // -2_147_483_648
  inspect!(@lib.parse_int("-2147483648"), content="Some(-2147483648)")
  // overflowed
  inspect!(@lib.parse_int("-2147483649"), content="None")
  // 291
  inspect!(@lib.parse_int("0x123"), content="Some(291)")
  // 117
  inspect!(@lib.parse_int("0b1110101"), content="Some(117)")
  // 83
  inspect!(@lib.parse_int("0o123"), content="Some(83)")
  inspect!(@lib.abs_int(-3), content="3") // 3
  // 720
  inspect!(@lib.factorial(6), content="Some(720)")
}


================================================
File 38: /data/input/moonbit-docs/legacy/examples/palindrome_string/README.md
================================================
## Palindrome string

Use the palindrome question to demonstrate Moonbit's string iteration.


================================================
File 39: /data/input/moonbit-docs/legacy/examples/palindrome_string/lib/str_iter.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

pub fn is_palindrome(chars : String) -> Bool {
  let n = chars.length()
  let mut i = 0
  while i < n / 2 {
    if chars[i] != chars[n - i - 1] {
      return false
    }
    i = i + 1
  }
  return true
}


================================================
File 40: /data/input/moonbit-docs/legacy/examples/palindrome_string/lib/str_iter_test.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

test {
  let test1 = "abc"
  let test2 = "aba"
  let test3 = "上海自来水来自海上"
  test1 |> @lib.is_palindrome |> assert_false!()
  test2 |> @lib.is_palindrome |> assert_true!()
  test3 |> @lib.is_palindrome |> assert_true!()
}


================================================
File 41: /data/input/moonbit-docs/legacy/examples/path/README.md
================================================
# Path
## API
```
Path::new(s: String, platform: Platform, file_type: FileType) -> Path
```
Creates a new instance of the Path type with the specified string representation, platform, and file type. The Path type represents a file path and is constructed using the given parameters.
```
parent(self : Path) -> String
```
Retrieves the parent directory of the given path. This function returns a string representing the path of the parent directory of the provided path.
```
is_absolute(self : Path) -> Bool
```
Checks whether the provided path is an absolute path. An absolute path is a path that starts from the root directory.
```
is_relative(self : Path) -> Bool
```
Checks whether the provided path is a relative path. A relative path is a path that is not absolute and is typically relative to the current working directory.
```
has_root(self : Path) -> Bool
```
Checks whether the provided path has a root component. The root component refers to the starting point of the file system hierarchy (e.g., drive letter in Windows, root directory in Unix-like systems).
```
file_name(self : Path) -> Option[String]
```
Retrieves the file name component of the provided path. If the path points to a file, this function returns an Option containing the file name. If the path represents a directory or does not have a file name, None is returned.
```
append(self : Path, p : String)
```
Appends a path segment represented by the string p to the provided path. This function extends the path by concatenating the given segment to it.
```
to_string(self : Path) -> String
```
Converts the provided path to its string representation. This function returns the string representation of the path.

================================================
File 42: /data/input/moonbit-docs/legacy/examples/path/lib/path.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

pub(all) struct Path {
  mut inner : String
  platform : Platform
  file_type : FileType
}

pub(all) enum FileType {
  File
  Directory
  Symlink
  Unknown
}

pub(all) enum Platform {
  Posix
  Windows
}

pub fn Path::new(s : String, platform : Platform, file_type : FileType) -> Path {
  { inner: s, platform, file_type }
}

pub fn parent(self : Path) -> String {
  match self.platform {
    Posix => {
      let (parts, l) = split(self.inner, '/')
      let mut parent = ""
      let mut index = 0
      let end = if parts[l] == "" { l - 1 } else { l }
      while index < end {
        parent = parent + parts[index] + "/"
        index = index + 1
      }
      parent
    }
    Windows => {
      let (parts, l) = split(self.inner, '\\')
      let mut parent = ""
      let mut index = 0
      let end = if parts[l] == "" { l - 1 } else { l }
      while index < end {
        parent = parent + parts[index] + "\\"
        index = index + 1
      }
      parent
    }
  }
}

pub fn is_absolute(self : Path) -> Bool {
  self.has_root()
}

pub fn is_relative(self : Path) -> Bool {
  not(self.has_root())
}

pub fn has_root(self : Path) -> Bool {
  match self.platform {
    Posix => self.inner[0] == '/'
    Windows =>
      ((self.inner[0].compare('a') >= 0 && self.inner[0].compare('z') <= 0) || (self.inner[0].compare(
        'A',
      ) >= 0 && self.inner[0].compare('Z') <= 0)) && self.inner[1] == ':'
  }
}

pub fn file_name(self : Path) -> String? {
  match self.file_type {
    FileType::File => {
      let (parts, l) = match self.platform {
        Posix => split(self.inner, '/')
        Windows => split(self.inner, '\\')
      }
      Some(parts[l])
    }
    _ => None
  }
}

pub fn append(self : Path, p : String) -> Unit {
  match self.platform {
    Posix => {
      if self.inner[self.inner.length() - 1] != '/' {
        self.inner = self.inner + "/"
      }
      self.inner = self.inner + p
    }
    Windows => {
      if self.inner[self.inner.length() - 1] != '\\' {
        self.inner = self.inner + "\\"
      }
      self.inner = self.inner + p
    }
  }
}

pub fn to_string(self : Path) -> String {
  self.inner
}

pub fn output(self : Path, log : &Logger) -> Unit {
  self.inner.output(log)
}


================================================
File 43: /data/input/moonbit-docs/legacy/examples/path/lib/path_test.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

test {
  // Posix
  let posix_path = @lib.Path::new(
    "/tmp/abc/f/d",
    @lib.Platform::Posix,
    @lib.FileType::File,
  )
  inspect!(posix_path.is_absolute(), content="true")
  inspect!(posix_path.parent(), content="/tmp/abc/f/")
  inspect!(
    posix_path.file_name(),
    content=
      #|Some("d")
    ,
  )
  posix_path.append("def")
  inspect!(
    posix_path,
    content=
      #|"/tmp/abc/f/d/def"
    ,
  )

  // Relative Posix
  let rel_posix_path = @lib.Path::new(
    "./abc/de/f",
    @lib.Platform::Posix,
    @lib.FileType::File,
  )
  inspect!(rel_posix_path.is_relative(), content="true")
  inspect!(rel_posix_path.parent(), content="./abc/de/")
  inspect!(
    rel_posix_path.file_name(),
    content=
      #|Some("f")
    ,
  )
  rel_posix_path.append("hello")
  inspect!(rel_posix_path.to_string(), content="./abc/de/f/hello")

  // windows
  let win_path = @lib.Path::new(
    "C:\\bc\\de",
    @lib.Platform::Windows,
    @lib.FileType::File,
  )
  inspect!(win_path.is_absolute(), content="true")
  inspect!(
    win_path.file_name(),
    content=
      #|Some("de")
    ,
  )
}


================================================
File 44: /data/input/moonbit-docs/legacy/examples/path/lib/string.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

pub fn split(s : String, sep : Char) -> (Array[String], Int) {
  let mut index = 0
  let mut result : Array[String] = Array::make(5, "")
  let mut cur = 0
  let it = iter(s)
  while it.index != it.length {
    let c = match it.next() {
      Some(c) => c
      None => return (result, cur)
    }
    if c == sep {
      let sub = match sub_string(s, index, it.index - 1) {
        Some(sub) => sub
        None => return (result, cur)
      }
      result[cur] = sub
      cur = cur + 1
      if cur >= result.length() {
        let new_result = Array::make(result.length() * 2, "")
        let mut tmp_cur = 0
        while tmp_cur < result.length() {
          new_result[tmp_cur] = result[tmp_cur]
          tmp_cur = tmp_cur + 1
        }
        result = new_result
      }
      index = it.index
    }
  }
  let sub = match sub_string(s, index, it.length) {
    Some(sub) => sub
    None => return (result, cur)
  }
  result[cur] = sub
  (result, cur)
}

pub fn sub_string(s : String, start : Int, end : Int) -> String? {
  if start > end || start < 0 || end > s.length() {
    return None
  }
  let it = iter(s)
  let mut result : String = ""
  while it.index != it.length {
    let c = match it.next() {
      Some(c) => c
      None => return None
    }
    if it.index - 1 >= start && it.index - 1 < end {
      result = result + c.to_string()
    }
  }
  Some(result)
}

pub fn trim(s : String, removed : Char) -> String {
  let l = s.length()
  let mut start = 0
  let mut end = l - 1
  while start < l && s[start] == removed {
    start = start + 1
  }
  while end >= 0 && s[end] == removed {
    end = end - 1
  }
  if start <= end {
    match sub_string(s, start, end + 1) {
      Some(sub) => return sub
      None => return s
    }
  }
  s
}

pub fn index_of(s : String, pattern : String) -> Int? {
  let prefix_func = prefix_function(pattern)
  let mut s_index = 0
  let mut p_index = 0
  let l = s.length()
  while s_index < l {
    if s[s_index] == pattern[p_index] {
      while p_index < pattern.length() && s_index < l && s[s_index] == pattern[p_index] {
        s_index = s_index + 1
        p_index = p_index + 1
      }
      if p_index == pattern.length() {
        return Some(s_index - pattern.length())
      } else {
        p_index = 0
        s_index = s_index + (p_index - prefix_func[p_index])
      }
    } else {
      s_index = s_index + 1
    }
  }
  None
}

pub fn last_index_of(s : String, pattern : String) -> Int? {
  let prefix_func = prefix_function(pattern)
  let mut s_index = 0
  let mut p_index = 0
  let mut index = -1
  let l = s.length()
  while s_index < l {
    if s[s_index] == pattern[p_index] {
      while p_index < pattern.length() && s_index < l && s[s_index] == pattern[p_index] {
        s_index = s_index + 1
        p_index = p_index + 1
      }
      if p_index == pattern.length() {
        let d = s_index - pattern.length()
        if d > index {
          index = d
        }
      }
      p_index = 0
      s_index = s_index + (p_index - prefix_func[p_index])
    } else {
      s_index = s_index + 1
    }
  }
  if index == -1 {
    None
  } else {
    Some(index)
  }
}

pub fn contains(s : String, sub : String) -> Bool {
  match index_of(s, sub) {
    Some(v) => v != -1
    None => false
  }
}

fn prefix_function(pattern : String) -> Array[Int] {
  let result = Array::make(pattern.length(), 0)
  let n = pattern.length()
  let mut i = 1
  while i < n {
    let mut j = result[i - 1]
    while j > 0 && pattern[i] != pattern[j] {
      j = result[j - 1]
    }
    if pattern[i] == pattern[j] {
      j = j + 1
    }
    result[i] = j
    i = i + 1
  }
  result
}

pub fn char_at(s : String, pos : Int) -> Char? {
  if pos >= 0 && pos < s.length() {
    return Some(s.get(pos))
  }
  None
}

pub fn to_char_array(s : String) -> Array[Char] {
  let l = s.length()
  let array = Array::make(l, ' ')
  let mut index = 0
  while index < l {
    array[index] = s.get(index)
    index = index + 1
  }
  array
}

pub struct Iterator {
  mut index : Int
  length : Int
  data : String
}

pub fn iter(s : String) -> Iterator {
  { index: 0, length: s.length(), data: s }
}

pub fn next(self : Iterator) -> Char? {
  if self.index == self.length {
    return None
  }
  let c = self.data[self.index]
  self.index = self.index + 1
  Some(c)
}


================================================
File 45: /data/input/moonbit-docs/legacy/examples/snake/extern/string.js.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

pub extern type JsString

pub fn JsString::from_string(str : String) -> JsString = "%identity"

pub fn JsString::to_string(str : JsString) -> String = "%identity"


================================================
File 46: /data/input/moonbit-docs/legacy/examples/snake/extern/string.wasm-gc.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

priv extern type JsArray

fn JsArray::new() -> JsArray = "array" "new"

fn push(self : JsArray, charCode : Int) = "array" "push"

pub(all) extern type JsString

fn JsString::from_code_point(charCode : JsArray) -> JsString = "string" "fromCodePoint"

fn iter(self : JsString, f : (Int) -> Unit) -> Unit = "string" "iter"

pub fn JsString::from_string(str : String) -> JsString {
  str
  .iter()
  .fold(
    fn(array : JsArray, char : Char) {
      array.push(char.to_int())
      array
    },
    init=JsArray::new(),
  )
  |> JsString::from_code_point
}

pub fn JsString::to_string(str : JsString) -> String {
  let buffer = StringBuilder::new()
  str.iter(fn(i : Int) { buffer.write_char(Char::from_int(i)) })
  buffer.to_string()
}


================================================
File 47: /data/input/moonbit-docs/legacy/examples/snake/extern/string.wasm.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

priv type JsArray

fn JsArray::new() -> JsArray = "array" "new"

fn push(self : JsArray, charCode : Int) = "array" "push"

pub(all) type JsString

fn JsString::from_char_code(charCode : JsArray) -> JsString = "string" "fromCharCode"

fn iter(self : JsString, f : (Int) -> Unit) -> Unit = "string" "iter"

pub fn JsString::from_string(str : String) -> JsString {
  str
  .iter()
  .fold(
    fn(array : JsArray, char : Char) {
      array.push(char.to_int())
      array
    },
    init=JsArray::new(),
  )
  |> JsString::from_char_code
}

pub fn JsString::to_string(str : JsString) -> String {
  let buffer = StringBuilder::new()
  str.iter(fn(i : Int) { buffer.write_char(Char::from_int(i)) })
  buffer.to_string()
}


================================================
File 48: /data/input/moonbit-docs/legacy/examples/snake/lib/draw.js.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

extern "js" fn set_stroke_color_ffi(
  self : Canvas_ctx,
  color : @extern.JsString
) =
  #|(ctx, color) => ctx.strokeStyle = color

fn set_stroke_color(self : Canvas_ctx, color : String) -> Unit {
  self.set_stroke_color_ffi(@extern.JsString::from_string(color))
}

extern "js" fn set_line_width(self : Canvas_ctx, width : Double) =
  #|(ctx, width) => ctx.lineWidth = width

extern "js" fn stroke_rect(
  self : Canvas_ctx,
  x : Int,
  y : Int,
  width : Int,
  height : Int
) =
  #|(ctx, x, y, width, height) => ctx.strokeRect(x, y, width, height)

extern "js" fn fill_rect(
  self : Canvas_ctx,
  x : Int,
  y : Int,
  width : Int,
  height : Int
) =
  #|(ctx, x, y, width, height) => ctx.fillRect(x, y, width, height)

extern "js" fn set_fill_style_ffi(self : Canvas_ctx, color : @extern.JsString) =
  #|(ctx, color) => ctx.fillStyle = color

fn set_fill_style(self : Canvas_ctx, color : String) -> Unit {
  self.set_fill_style_ffi(@extern.JsString::from_string(color))
}


================================================
File 49: /data/input/moonbit-docs/legacy/examples/snake/lib/draw.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

pub(all) type Canvas_ctx

fn body_color(grid : GridType) -> String {
  match grid {
    Body => "#ffb900"
    Food => "#2753f1"
    None => "#dcdcdc"
  }
}

let border_color = "#00263f"

pub fn draw(canvas : Canvas_ctx, snake : GameState) -> Unit {
  // draw background
  for c = 0; c < grid_col_count; c = c + 1 {
    canvas.set_fill_style(body_color(None))
    canvas.fill_rect(c, 0, 1, grid_row_count)
  }
  draw_piece(canvas, snake.grid, (0, 0))
}

fn draw_piece(
  canvas : Canvas_ctx,
  matrix : FixedArray[GridType],
  offset : (Int, Int)
) -> Unit {
  matrix.eachi(
    fn {
      _, None => ()
      c, grid => {
        let c0 = c % grid_col_count
        let r = c / grid_col_count
        canvas.set_fill_style(body_color(grid))
        canvas.fill_rect(offset.0 + c0, r, 1, 1)
        canvas.set_stroke_color(border_color)
        canvas.set_line_width(0.1)
        canvas.stroke_rect(c0, r, 1, 1)
      }
    },
  )
}


================================================
File 50: /data/input/moonbit-docs/legacy/examples/snake/lib/draw.wasm-gc.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

fn set_stroke_color_ffi(self : Canvas_ctx, color : @extern.JsString) = "canvas" "set_stroke_color"

fn set_stroke_color(self : Canvas_ctx, color : String) -> Unit {
  self.set_stroke_color_ffi(@extern.JsString::from_string(color))
}

fn set_line_width(self : Canvas_ctx, width : Double) = "canvas" "set_line_width"

fn stroke_rect(self : Canvas_ctx, x : Int, y : Int, width : Int, height : Int) = "canvas" "stroke_rect"

fn fill_rect(self : Canvas_ctx, x : Int, y : Int, width : Int, height : Int) = "canvas" "fill_rect"

fn set_fill_style_ffi(self : Canvas_ctx, color : @extern.JsString) = "canvas" "set_fill_style"

fn set_fill_style(self : Canvas_ctx, color : String) -> Unit {
  self.set_fill_style_ffi(@extern.JsString::from_string(color))
}


================================================
File 51: /data/input/moonbit-docs/legacy/examples/snake/lib/draw.wasm.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

fn set_stroke_color_ffi(self : Canvas_ctx, color : @extern.JsString) = "canvas" "set_stroke_color"

fn set_stroke_color(self : Canvas_ctx, color : String) -> Unit {
  self.set_stroke_color_ffi(@extern.JsString::from_string(color))
}

fn set_line_width(self : Canvas_ctx, width : Double) = "canvas" "set_line_width"

fn stroke_rect(self : Canvas_ctx, x : Int, y : Int, width : Int, height : Int) = "canvas" "stroke_rect"

fn fill_rect(self : Canvas_ctx, x : Int, y : Int, width : Int, height : Int) = "canvas" "fill_rect"

fn set_fill_style_ffi(self : Canvas_ctx, color : @extern.JsString) = "canvas" "set_fill_style"

fn set_fill_style(self : Canvas_ctx, color : String) -> Unit {
  self.set_fill_style_ffi(@extern.JsString::from_string(color))
}


================================================
File 52: /data/input/moonbit-docs/legacy/examples/snake/lib/snake.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

let grid_row_count = 20

let grid_col_count = 20

pub(all) enum Direction {
  Up
  Down
  Left
  Right
  Default
} derive(Eq)

enum GridType {
  Body
  Food
  None
} derive(Eq)

fn dir_posi(self : Direction) -> Position {
  match self {
    Up => { x: 0, y: -1 }
    Down => { x: 0, y: 1 }
    Left => { x: -1, y: 0 }
    Right => { x: 1, y: 0 }
    Default => { x: 0, y: 0 }
  }
}

struct Position {
  x : Int
  y : Int
}

struct GameState {
  grid : FixedArray[GridType]
  body : @deque.T[Position]
  mut dir : Direction
}

fn initialize(self : GameState) -> Unit {
  self.grid.fill(None)
  self.dir = Up
  self.body.clear()
  self.body.push_back({ x: grid_col_count / 2, y: grid_col_count / 2 })
  self.grid[grid_col_count / 2 * grid_col_count + grid_col_count / 2] = Body
  self.generate_Food()
}

fn setGridType(self : GameState, p : Position, t : GridType) -> Unit {
  self.grid[p.y * grid_col_count + p.x] = t
}

fn random() -> Double = "Math" "random"

fn floor(i : Double) -> Int = "Math" "floor"

fn generate_Food(self : GameState) -> Unit {
  while true {
    let i : Int = floor(random() * 20.0)
    let j : Int = floor(random() * 20.0)
    if self.grid[j * grid_col_count + i] == None {
      self.setGridType({ x: i, y: j }, Food)
      return
    }
  }
}

fn go_step(self : GameState) -> Unit {
  // if (prev == Up && self.dir == Down) ||  (prev == Down && self.dir == Up) || (prev == Left && self.dir == Right) || (prev == Right && self.dir == Left){
  //   self.dir = prev
  // }
  let head : Position = self.body.front().unwrap()
  let newHead = {
    x: (head.x + dir_posi(self.dir).x + grid_col_count) % grid_col_count,
    y: (head.y + dir_posi(self.dir).y + grid_row_count) % grid_row_count,
  }
  if self.grid[newHead.y * grid_col_count + newHead.x] == Body {
    initialize(self)
    return
  } else if self.grid[newHead.y * grid_col_count + newHead.x] == Food {
    self.setGridType(newHead, Body)
    self.body.push_front(newHead)
    generate_Food(self)
  } else {
    self.setGridType(newHead, Body)
    self.body.push_front(newHead)
    self.setGridType(self.body.back().unwrap(), None)
    self.body.unsafe_pop_back()
  }
}

pub fn step(self : GameState, action : Direction) -> Unit {
  match (action, self.dir) {
    (Up, Down) | (Left, Right) | (Right, Left) | (Down, Up) =>
      if self.body.length() == 1 {
        self.dir = action
        self.go_step()
      }
    _ => {
      if action != Default {
        self.dir = action
      }
      self.go_step()
    }
  }
}

pub fn new() -> GameState {
  let game : GameState = {
    grid: FixedArray::make(grid_row_count * grid_col_count, None),
    body: @deque.new(),
    dir: Up,
  }
  game.initialize()
  game
}


================================================
File 53: /data/input/moonbit-docs/legacy/examples/snake/main/main.js.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

extern "js" fn request_animation_frame(callback : (Double) -> Unit) -> Int =
  #|window.requestAnimationFrame

extern "js" fn set_on_keydown(callback : (KeyboardEvent) -> Unit) =
  #|(callback) => { document.onkeydown = callback }

extern "js" fn get_context() -> @lib.Canvas_ctx =
  #|() => {
  #|  const context = globalThis["canvas"].getContext("2d");
  #|  context.scale(24, 24);
  #|  return context;
  #|}

type KeyboardEvent

extern "js" fn key_ffi(self : KeyboardEvent) -> @extern.JsString =
  #|(event) => event.key

fn key(self : KeyboardEvent) -> String {
  self.key_ffi().to_string()
}


================================================
File 54: /data/input/moonbit-docs/legacy/examples/snake/main/main.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

let state : @lib.GameState = @lib.new()

let context : @lib.Canvas_ctx = get_context()

let last_frame : Ref[Double] = { val: 0.0 }

let game_interval = 500.0

fn update(time : Double) -> Unit {
  if time - last_frame.val > game_interval {
    @lib.step(state, @lib.Direction::Default)
    @lib.draw(context, state)
    last_frame.val = time
  } else {
    @lib.draw(context, state)
  }
  request_animation_frame(update) |> ignore
}

fn main {
  set_on_keydown(
    fn(event) {
      if last_frame.val < 0.0 { // not started yet
        return
      }
      match event.key() {
        "ArrowLeft" => {
          @lib.step(state, @lib.Direction::Left)
          @lib.draw(context, state)
        }
        "ArrowRight" => {
          @lib.step(state, @lib.Direction::Right)
          @lib.draw(context, state)
        }
        "ArrowDown" => {
          @lib.step(state, @lib.Direction::Down)
          @lib.draw(context, state)
        }
        "ArrowUp" => {
          @lib.step(state, @lib.Direction::Up)
          @lib.draw(context, state)
        }
        _ => ()
      }
    },
  )
  request_animation_frame(update) |> ignore
}


================================================
File 55: /data/input/moonbit-docs/legacy/examples/snake/main/main.wasm-gc.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

fn request_animation_frame(callback : (Double) -> Unit) -> Int = "window" "requestAnimationFrame"

fn set_on_keydown(callback : (KeyboardEvent) -> Unit) = "document" "set_onkeydown"

fn get_context() -> @lib.Canvas_ctx = "canvas" "get_context"

type KeyboardEvent

fn key_ffi(self : KeyboardEvent) -> @extern.JsString = "keyboard_event" "key"

fn key(self : KeyboardEvent) -> String {
  self.key_ffi().to_string()
}


================================================
File 56: /data/input/moonbit-docs/legacy/examples/snake/main/main.wasm.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

fn request_animation_frame(callback : (Double) -> Unit) -> Int = "window" "requestAnimationFrame"

fn set_on_keydown(callback : (KeyboardEvent) -> Unit) = "document" "set_onkeydown"

fn get_context() -> @lib.Canvas_ctx = "canvas" "get_context"

type KeyboardEvent

fn key_ffi(self : KeyboardEvent) -> @extern.JsString = "keyboard_event" "key"

fn key(self : KeyboardEvent) -> String {
  self.key_ffi().to_string()
}


================================================
File 57: /data/input/moonbit-docs/legacy/examples/string/README.md
================================================
# String

Use MoonBit to implement string tools.

## API
Split a string, and return an array of string split and the length of the array.
```
split(String, Char) -> (Array[String], Int)
```
Get the substring of a string from start to end.
```
sub_string(String, start: Int, end: Int) -> Option[String]
```
Remove the character at the start and end.
```
trim(String, Char) -> String
```
Get the position of the first match.
```
index_of(s: String, pattern: String) -> Option[Int]
```
Get the position of the last match.
```
last_index_of(s: String, pattern: String) -> Option[Int]
```
Determine whether string s contains string sub. 
```
contains(s: String, sub: String) -> Bool
```
Return a char at the position.
```
char_at(String, position: Int) -> Option[Char]
```
Convert a string to a char array.
```
to_char_array(String) -> Array[Char]
```
Create an iterator for string.
```
iter(String) -> Iterator
next(Iterator) -> Option[Char]
```

================================================
File 58: /data/input/moonbit-docs/legacy/examples/string/lib/string.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

pub fn split(s : String, sep : Char) -> Array[String] {
  let mut index = 0
  let result = []
  let it = iter(s)
  while it.index != it.length {
    let c = match it.next() {
      Some(c) => c
      None => return result
    }
    if c == sep {
      let sub = match sub_string(s, index, it.index - 1) {
        Some(sub) => sub
        None => return result
      }
      result.push(sub)
      index = it.index
    }
  }
  let sub = match sub_string(s, index, it.length) {
    Some(sub) => sub
    None => return result
  }
  result.push(sub)
  result
}

pub fn sub_string(s : String, start : Int, end : Int) -> String? {
  if start > end || start < 0 || end > s.length() {
    return None
  }
  let it = iter(s)
  let mut result : String = ""
  while it.index != it.length {
    let c = match it.next() {
      Some(c) => c
      None => return None
    }
    if it.index - 1 >= start && it.index - 1 < end {
      result = result + c.to_string()
    }
  }
  Some(result)
}

pub fn trim(s : String, removed : Char) -> String {
  let l = s.length()
  let mut start = 0
  let mut end = l - 1
  while start < l && s[start] == removed {
    start = start + 1
  }
  while end >= 0 && s[end] == removed {
    end = end - 1
  }
  if start <= end {
    match sub_string(s, start, end + 1) {
      Some(sub) => return sub
      None => return s
    }
  }
  s
}

pub fn index_of(s : String, pattern : String) -> Int? {
  let prefix_func = prefix_function(pattern)
  let mut s_index = 0
  let mut p_index = 0
  let l = s.length()
  while s_index < l {
    if s[s_index] == pattern[p_index] {
      while p_index < pattern.length() && s_index < l && s[s_index] == pattern[p_index] {
        s_index = s_index + 1
        p_index = p_index + 1
      }
      if p_index == pattern.length() {
        return Some(s_index - pattern.length())
      } else {
        p_index = 0
        s_index = s_index + (p_index - prefix_func[p_index])
      }
    } else {
      s_index = s_index + 1
    }
  }
  None
}

pub fn last_index_of(s : String, pattern : String) -> Int? {
  let prefix_func = prefix_function(pattern)
  let mut s_index = 0
  let mut p_index = 0
  let mut index = -1
  let l = s.length()
  while s_index < l {
    if s[s_index] == pattern[p_index] {
      while p_index < pattern.length() && s_index < l && s[s_index] == pattern[p_index] {
        s_index = s_index + 1
        p_index = p_index + 1
      }
      if p_index == pattern.length() {
        let d = s_index - pattern.length()
        if d > index {
          index = d
        }
      }
      p_index = 0
      s_index = s_index + (p_index - prefix_func[p_index])
    } else {
      s_index = s_index + 1
    }
  }
  if index == -1 {
    None
  } else {
    Some(index)
  }
}

pub fn contains(s : String, sub : String) -> Bool {
  match index_of(s, sub) {
    Some(v) => v != -1
    None => false
  }
}

fn prefix_function(pattern : String) -> Array[Int] {
  let result = Array::make(pattern.length(), 0)
  let n = pattern.length()
  let mut i = 1
  while i < n {
    let mut j = result[i - 1]
    while j > 0 && pattern[i] != pattern[j] {
      j = result[j - 1]
    }
    if pattern[i] == pattern[j] {
      j = j + 1
    }
    result[i] = j
    i = i + 1
  }
  result
}

pub fn char_at(s : String, pos : Int) -> Char? {
  if pos >= 0 && pos < s.length() {
    return Some(s.get(pos))
  }
  None
}

pub fn to_char_array(s : String) -> Array[Char] {
  let l = s.length()
  let array = Array::make(l, ' ')
  let mut index = 0
  while index < l {
    array[index] = s.get(index)
    index = index + 1
  }
  array
}

pub struct Iterator {
  mut index : Int
  length : Int
  data : String
}

pub fn iter(s : String) -> Iterator {
  { index: 0, length: s.length(), data: s }
}

pub fn next(self : Iterator) -> Char? {
  if self.index == self.length {
    return None
  }
  let c = self.data[self.index]
  self.index = self.index + 1
  Some(c)
}


================================================
File 59: /data/input/moonbit-docs/legacy/examples/string/lib/string_test.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

test {
  let arr = @lib.split("a.b.c.e.f.g.h.i.j.k.l.m.n", '.')
  assert_eq!(
    arr,
    ["a", "b", "c", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n"],
  )
  inspect!(
    @lib.sub_string("Hello World", 3, 7),
    content=
      #|Some("lo W")
    ,
  )
  "Hello World" |> @lib.index_of("Wo") |> assert_eq!(Some(6))
  "Hello World World Hello" |> @lib.last_index_of("Wo") |> assert_eq!(Some(12))
  assert_true!(@lib.contains("Hello World", "Wo"))
  let arr = @lib.to_char_array("HelloWorld")
  assert_eq!(arr, ['H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd'])
  assert_eq!(@lib.char_at("abcde", 4), Some('e'))
  assert_eq!(@lib.trim("   abcde   ", ' '), "abcde")
}


================================================
File 60: /data/input/moonbit-docs/legacy/examples/tetris/README.md
================================================
# Tetris in MoonBitLang

`lib/tetris.mbt` implements the execution logic of the tetris.

`lib/draw.mbt` uses `canvas` to draw.

## Deps

This example works with the following versions of the environment.

```
❯ moon version
moon 0.1.0 (6865948 2023-09-12)
moonc 7a44af122 /home/luoxuwei/.moon/bin/moonc

❯ wat2wasm --version
1.0.33 (git~1.0.33-30-g2581e8d5)
```

## How to Run
```
make 
```
## Details

### Use External Ref to Call Canvas API
* Create external ref
```
type Canvas_ctx

func set_stroke_color(self : Canvas_ctx, color : Int) = "canvas" "set_stroke_color"

func set_line_width(self : Canvas_ctx, width : Float64) = "canvas" "set_line_width"

func stroke_rect(self : Canvas_ctx, x : Int, y : Int, width : Int, height : Int) = "canvas" "stroke_rect"

func fill_rect(self : Canvas_ctx, x : Int, y : Int, width : Int, height : Int) = "canvas" "fill_rect"

func set_fill_style(self : Canvas_ctx, color : Int) = "canvas" "set_fill_style"

func draw_game_over(self: Canvas_ctx) = "canvas" "draw_game_over"
```
* Draw entry, ref: `lib/draw.mbt/draw(canvas : Canvas_ctx, tetris : Tetris)`
### Load Wasm and Execute It
Create a WebAssembly.Memory
```javascript
const importObject = {
  canvas: {
    stroke_rect: (ctx, x, y, width, height) => ctx.strokeRect(x, y, width, height),
    stroke: (ctx) => ctx.stroke(),
    set_line_width: (ctx, width) => ctx.lineWidth = width,
    fill_rect: (ctx, x, y, width, height) => ctx.fillRect(x, y, width, height),
    set_stroke_color: (ctx, color) => ctx.strokeStyle = colors[color],
    set_fill_style: (ctx, color) => ctx.fillStyle = colors[color],
  },
  spectest: {
      print_i32: (x) => console.log(String(x)),
      print_f64: (x) => console.log(String(x)),
      print_char: (x) => console.log(String.fromCharCode(x)),
    }
};
```
Load Wasm and use `requestAnimationFrame(update)` to draw
```javascript
function update(time = 0) {
  const deltaTime = time - lastTime
  dropCounter += deltaTime
  if (dropCounter > dropInterval) {
    tetris_step(tetris, 0);
    scoreDom.innerHTML = "score: " + tetris_score(tetris)
    dropCounter = 0
  }
  lastTime = time
  tetris_draw(context, tetris);
  requestAnimationFrameId = requestAnimationFrame(update)
}

WebAssembly.instantiateStreaming(fetch("target/tetris.wasm"), importObject).then(
    (obj) => {
      obj.instance.exports._start();
      tetris_draw = obj.instance.exports["tetris/lib::draw"];
      tetris_new = obj.instance.exports["tetris/lib::new"];
      tetris_step = obj.instance.exports["tetris/lib::step"];
      tetris_score = obj.instance.exports["tetris/lib::get_score"]
      tetris = tetris_new();
      requestAnimationFrameId = requestAnimationFrame(update);
    }
  )
```
* Game entry, ref: `lib/tetris.mbt/step(tetris:Tetris, action:Int)`

================================================
File 61: /data/input/moonbit-docs/legacy/examples/tetris/lib/config.mbt
================================================
//  Copyright 2023 luoxuwei
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

let grid_row_count = 20

let grid_col_count = 10

enum PIECE {
  I
  L
  J
  S
  Z
  T
  O
}

pub fn piece_shape(self : PIECE) -> Array[Array[Int]] {
  match self {
    I => [[1, 1, 1, 1]]
    L => [[0, 0, 2], [2, 2, 2]]
    J => [[3, 0, 0], [3, 3, 3]]
    S => [[0, 4, 4], [4, 4, 0]]
    Z => [[5, 5, 0], [0, 5, 5]]
    T => [[6, 6, 6], [0, 6, 0]]
    O => [[7, 7], [7, 7]]
  }
}


================================================
File 62: /data/input/moonbit-docs/legacy/examples/tetris/lib/draw.mbt
================================================
//  Copyright 2023 luoxuwei
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

type Canvas_ctx

fn set_stroke_color(self : Canvas_ctx, color : Int) = "canvas" "set_stroke_color"

fn set_line_width(self : Canvas_ctx, width : Double) = "canvas" "set_line_width"

fn stroke_rect(self : Canvas_ctx, x : Int, y : Int, width : Int, height : Int) = "canvas" "stroke_rect"

fn fill_rect(self : Canvas_ctx, x : Int, y : Int, width : Int, height : Int) = "canvas" "fill_rect"

fn set_fill_style(self : Canvas_ctx, color : Int) = "canvas" "set_fill_style"

fn draw_game_over(self : Canvas_ctx) = "canvas" "draw_game_over"

pub fn draw(canvas : Canvas_ctx, tetris : Tetris) -> Unit {
  // draw background
  for c = 0; c < grid_col_count; c = c + 1 {
    let color = if c % 2 == 0 { 0 } else { 1 }
    canvas.set_fill_style(color)
    canvas.fill_rect(c, 0, 1, grid_row_count)
  }
  draw_piece(canvas, tetris.grid, (0, 0))
  draw_piece(
    canvas,
    @immut/list.from_array(tetris.piece_shape),
    (tetris.piece_x, tetris.piece_y),
  )
  if tetris.dead {
    canvas.draw_game_over()
  }
}

pub fn draw_piece(
  canvas : Canvas_ctx,
  matrix : @immut/list.T[Array[Int]],
  offset : (Int, Int)
) -> Unit {
  canvas.set_stroke_color(0)
  canvas.set_line_width(0.1)
  matrix.eachi(
    fn {
      r, v =>
        for c = 0; c < v.length(); c = c + 1 {
          if v[c] == 0 {
            continue c + 1
          }
          canvas.set_fill_style(v[c] + 1)
          canvas.fill_rect(offset.0 + c, offset.1 + r, 1, 1)
          canvas.stroke_rect(offset.0 + c, offset.1 + r, 1, 1)
        }
    },
  )
}


================================================
File 63: /data/input/moonbit-docs/legacy/examples/tetris/lib/tetris.mbt
================================================
//  Copyright 2023 luoxuwei
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

struct Tetris {
  mut dead : Bool
  mut grid : @immut/list.T[Array[Int]]
  mut piece_pool : @immut/list.T[PIECE]
  mut current : PIECE
  mut piece_x : Int
  mut piece_y : Int
  mut piece_shape : Array[Array[Int]]
  mut score : Int
}

pub fn reset_game(self : Tetris) -> Unit {
  self.dead = false
  self.score = 0
  self.grid = for i = 0, grid = @immut/list.Nil
                  i < grid_row_count
                  i = i + 1, grid = Cons(Array::make(grid_col_count, 0), grid) {

  } else {
    grid
  }
  self.dead = self.generate_piece()
}

pub fn generate_piece(self : Tetris) -> Bool {
  self.current = self.get_next_piece(true)
  self.piece_shape = self.current.piece_shape()
  self.piece_x = grid_col_count / 2 - self.piece_shape[0].length() / 2
  self.piece_y = 0
  return check_collision(
    self.grid,
    self.piece_shape,
    (self.piece_x, self.piece_y),
  )
}

pub fn get_next_piece(self : Tetris, pop : Bool) -> PIECE {
  if self.piece_pool.length() == 0 {
    self.generate_piece_pool()
  }
  match self.piece_pool {
    Nil => abort("impossible")
    Cons(cur, n) => {
      if pop {
        self.piece_pool = n
      }
      cur
    }
  }
}

pub fn generate_piece_pool(self : Tetris) -> Unit {
  self.piece_pool = @immut/list.of(
    [PIECE::I, PIECE::J, PIECE::L, PIECE::O, PIECE::S, PIECE::T, PIECE::Z],
  )
}
// TODO:shuffle

pub fn on_piece_collision(self : Tetris) -> Unit {
  let len_r = self.piece_shape.length()
  let len_c = self.piece_shape[0].length()
  let y = self.piece_y - 1

  // Add the current shap to grid
  self.grid.eachi(
    fn {
      r, v => {
        if r < y || r >= y + len_r {
          return
        }
        for c = 0; c < len_c; c = c + 1 {
          if self.piece_shape[r - y][c] == 0 {
            continue c + 1
          }
          v[c + self.piece_x] = self.piece_shape[r - y][c]
        }
      }
    },
  )

  // Delete the complete row
  let (new_grid, row_completed) = self.grid.rev_fold(
    init=(@immut/list.Nil, 0),
    fn {
      v, (new_grid, row_completed) =>
        if v.contains(0) {
          (Cons(v, new_grid), row_completed)
        } else {
          (new_grid, row_completed + 1)
        }
    },
  )
  // 1 line == 1 score
  self.score = self.score + row_completed

  // Insert blank row at the top
  self.grid = for i = 0, new_grid = new_grid
                  i < row_completed
                  i = i + 1, new_grid = @immut/list.Cons(
                      Array::make(grid_col_count, 0),
                      new_grid,
                    ) {

  } else {
    new_grid
  }
  self.dead = self.generate_piece()
}

pub fn drop_piece(self : Tetris, instant : Bool) -> Unit {
  if instant {
    let y = get_effective_height(
      self.grid,
      self.piece_shape,
      (self.piece_x, self.piece_y),
    )
    self.piece_y = y + 1
  } else {
    self.piece_y = self.piece_y + 1
  }
  if instant == false && check_collision(
    self.grid,
    self.piece_shape,
    (self.piece_x, self.piece_y),
  ) == false {
    return
  }
  self.on_piece_collision()
}

pub fn move_piece(self : Tetris, delta : Int) -> Unit {
  let mut new_x = self.piece_x + delta
  new_x = @math.maximum(
    0,
    @math.minimum(new_x, grid_col_count - self.piece_shape[0].length()),
  )
  if check_collision(self.grid, self.piece_shape, (new_x, self.piece_y)) {
    return
  }
  self.piece_x = new_x
}

pub fn rotate_piece(self : Tetris) -> Unit {
  let r = self.piece_shape.length()
  let c = self.piece_shape[0].length()
  let new_shap = Array::make(c, Array::make(r, 0))
  for i = 0; i < c; i = i + 1 {
    new_shap[i] = Array::make(r, 0)
  }
  for i_c = 0; i_c < c; i_c = i_c + 1 {
    for i_r = 0; i_r < r; i_r = i_r + 1 {
      new_shap[i_c][i_r] = self.piece_shape[r - i_r - 1][i_c]
    }
  }
  let mut new_x = self.piece_x
  if new_x + new_shap[0].length() > grid_col_count {
    new_x = grid_col_count - new_shap[0].length()
  }
  if check_collision(self.grid, new_shap, (new_x, self.piece_y)) {
    return
  }
  self.piece_x = new_x
  self.piece_shape = new_shap
}

pub fn step(tetris : Tetris, action : Int) -> Unit {
  if tetris.dead {
    return
  }
  match action {
    // move left
    1 => tetris.move_piece(-1)
    // move right
    2 => tetris.move_piece(1)
    // rotate
    3 => tetris.rotate_piece()
    // instant
    4 => tetris.drop_piece(true)
    _ => tetris.drop_piece(false)
  }
}

pub fn new() -> Tetris {
  let tetris = {
    dead: false,
    grid: Nil,
    piece_pool: Nil,
    current: I,
    piece_x: 0,
    piece_y: 0,
    piece_shape: PIECE::I.piece_shape(),
    score: 0,
  }
  tetris.reset_game()
  tetris
}

pub fn get_score(tetris : Tetris) -> Int {
  tetris.score
}


================================================
File 64: /data/input/moonbit-docs/legacy/examples/tetris/lib/utils.mbt
================================================
//  Copyright 2023 luoxuwei
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

pub fn check_collision(
  grid : @immut/list.T[Array[Int]],
  shap : Array[Array[Int]],
  offset : (Int, Int)
) -> Bool {
  let len_r = shap.length()
  let len_c = shap[0].length()
  if offset.1 + len_r > grid_row_count {
    return true
  }
  loop grid, 0 {
    Cons(v, n), r => {
      if r < offset.1 {
        continue n, r + 1
      }
      if r >= offset.1 + len_r {
        return false
      }
      for c = 0; c < len_c; c = c + 1 {
        if shap[r - offset.1][c] == 0 {
          continue c + 1
        }
        if v[c + offset.0] != 0 {
          return true
        }
      }
      continue n, r + 1
    }
    Nil, _ => false
  }
}

pub fn get_effective_height(
  grid : @immut/list.T[Array[Int]],
  shap : Array[Array[Int]],
  offset : (Int, Int)
) -> Int {
  let x = offset.0
  let mut y = offset.1
  while check_collision(grid, shap, (x, y)) == false {
    y = y + 1
  }
  y - 1
}


================================================
File 65: /data/input/moonbit-docs/legacy/examples/unicode_demo/README.md
================================================
## Moonbit Unicode

We can use emoji in Moonbit now :)


================================================
File 66: /data/input/moonbit-docs/legacy/examples/unicode_demo/main/main.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

type T😯 Int

fn 😀(self : T😯) -> Int {
  self._
}

pub(all) enum 😆😆 {
  A
  B
} derive(Show)

test {
  let 🤣 = T😯::T😯(3)
  inspect!(🤣.😀(), content="3")
  let 😆 = 😆😆::A
  inspect!(😆, content="A")
}


================================================
File 67: /data/input/moonbit-docs/legacy/examples/wasi-http/ffi/top.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!

///|
pub extern "wasm" fn extend16(value : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.extend16_s)

///|
pub extern "wasm" fn extend8(value : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.extend8_s)

///|
pub extern "wasm" fn store8(offset : Int, value : Int) =
  #|(func (param i32) (param i32) local.get 0 local.get 1 i32.store8)

///|
pub extern "wasm" fn load8_u(offset : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.load8_u)

///|
pub extern "wasm" fn load8(offset : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.load8_s)

///|
pub extern "wasm" fn store16(offset : Int, value : Int) =
  #|(func (param i32) (param i32) local.get 0 local.get 1 i32.store16)

///|
pub extern "wasm" fn load16(offset : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.load16_s)

///|
pub extern "wasm" fn load16_u(offset : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.load16_u)

///|
pub extern "wasm" fn store32(offset : Int, value : Int) =
  #|(func (param i32) (param i32) local.get 0 local.get 1 i32.store)

///|
pub extern "wasm" fn load32(offset : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.load)

///|
pub extern "wasm" fn store64(offset : Int, value : Int64) =
  #|(func (param i32) (param i64) local.get 0 local.get 1 i64.store)

///|
pub extern "wasm" fn load64(offset : Int) -> Int64 =
  #|(func (param i32) (result i64) local.get 0 i64.load)

///|
pub extern "wasm" fn storef32(offset : Int, value : Float) =
  #|(func (param i32) (param f32) local.get 0 local.get 1 f32.store)

///|
pub extern "wasm" fn loadf32(offset : Int) -> Float =
  #|(func (param i32) (result f32) local.get 0 f32.load)

///|
pub extern "wasm" fn storef64(offset : Int, value : Double) =
  #|(func (param i32) (param f64) local.get 0 local.get 1 f64.store)

///|
pub extern "wasm" fn loadf64(offset : Int) -> Double =
  #|(func (param i32) (result f64) local.get 0 f64.load)

///|
pub extern "wasm" fn f32_to_i32(value : Float) -> Int =
  #|(func (param f32) (result i32) local.get 0 f32.convert_i32_s)

///|
pub extern "wasm" fn f32_to_i64(value : Float) -> Int64 =
  #|(func (param f32) (result i64) local.get 0 f32.convert_i64_s)

///|
extern "wasm" fn malloc_inline(size : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 call $moonbit.malloc)

///|
pub fn malloc(size : Int) -> Int {
  let words = size / 4 + 1
  let address = malloc_inline(8 + words * 4)
  store32(address, 1)
  store32(address + 4, (words << 8) | 246)
  store8(address + words * 4 + 7, 3 - size % 4)
  address + 8
}

///|
pub extern "wasm" fn free(position : Int) =
  #|(func (param i32) local.get 0 i32.const 8 i32.sub call $moonbit.decref)

///|
pub fn copy(dest : Int, src : Int) -> Unit {
  let src_len = (load32(src - 12) >> 2) - 4
  let dest_len = (load32(dest - 12) >> 2) - 4
  let min = if src_len < dest_len { src_len } else { dest_len }
  copy_inline(dest, src, min)
}

///|
extern "wasm" fn copy_inline(dest : Int, src : Int, len : Int) =
  #|(func (param i32) (param i32) (param i32) local.get 0 local.get 1 local.get 2 memory.copy)

///|
pub extern "wasm" fn str2ptr(str : String) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

///|
pub extern "wasm" fn ptr2str(ptr : Int) -> String =
  #|(func (param i32) (result i32) local.get 0 i32.const 4 i32.sub i32.const 243 i32.store8 local.get 0 i32.const 8 i32.sub)

///|
pub extern "wasm" fn bytes2ptr(bytes : FixedArray[Byte]) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

///|
pub extern "wasm" fn ptr2bytes(ptr : Int, _len : Int) -> FixedArray[Byte] =
  #|(func (param i32) (param i32) (result i32) local.get 0 i32.const 8 i32.sub)

///|
pub extern "wasm" fn uint_array2ptr(array : FixedArray[UInt]) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

///|
pub extern "wasm" fn uint64_array2ptr(array : FixedArray[UInt64]) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

///|
pub extern "wasm" fn int_array2ptr(array : FixedArray[Int]) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

///|
pub extern "wasm" fn int64_array2ptr(array : FixedArray[Int64]) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

///|
pub extern "wasm" fn float_array2ptr(array : FixedArray[Float]) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

///|
pub extern "wasm" fn double_array2ptr(array : FixedArray[Double]) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

///|
extern "wasm" fn ptr2uint_array_ffi(ptr : Int) -> FixedArray[UInt] =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.sub)

///|
pub fn ptr2uint_array(ptr : Int, len : Int) -> FixedArray[UInt] {
  set_header_ffi(ptr - 4, len)
  ptr2uint_array_ffi(ptr)
}

///|
extern "wasm" fn ptr2int_array_ffi(ptr : Int) -> FixedArray[Int] =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.sub)

///|
pub fn ptr2int_array(ptr : Int, len : Int) -> FixedArray[Int] {
  set_header_ffi(ptr - 4, len)
  ptr2int_array_ffi(ptr)
}

///|
extern "wasm" fn ptr2float_array_ffi(ptr : Int) -> FixedArray[Float] =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.sub)

///|
pub fn ptr2float_array(ptr : Int, len : Int) -> FixedArray[Float] {
  set_header_ffi(ptr - 4, len)
  ptr2float_array_ffi(ptr)
}

///|
extern "wasm" fn ptr2uint64_array_ffi(ptr : Int) -> FixedArray[UInt64] =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.sub)

///|
pub fn ptr2uint64_array(ptr : Int, len : Int) -> FixedArray[UInt64] {
  set_header_ffi(ptr - 4, len)
  ptr2uint64_array_ffi(ptr)
}

///|
extern "wasm" fn ptr2int64_array_ffi(ptr : Int) -> FixedArray[Int64] =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.sub)

///|
pub fn ptr2int64_array(ptr : Int, len : Int) -> FixedArray[Int64] {
  set_header_ffi(ptr - 4, len)
  ptr2int64_array_ffi(ptr)
}

///|
extern "wasm" fn ptr2double_array_ffi(ptr : Int) -> FixedArray[Double] =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.sub)

///|
pub fn ptr2double_array(ptr : Int, len : Int) -> FixedArray[Double] {
  set_header_ffi(ptr - 4, len)
  ptr2double_array_ffi(ptr)
}

///|
fn set_header_ffi(offset : Int, len : Int) -> Unit {
  store32(offset, (len << 8) | 241)
}

///|
pub fn cabi_realloc(
  src_offset : Int,
  src_size : Int,
  _dst_alignment : Int,
  dst_size : Int
) -> Int {
  // malloc
  if src_offset == 0 && src_size == 0 {
    return malloc(dst_size)
  }
  // free
  if dst_size <= 0 {
    free(src_offset)
    return 0
  }
  // realloc
  let dst = malloc(dst_size)
  copy(dst, src_offset)
  free(src_offset)
  dst
}

///|
pub(open) trait Any {}

///|
pub(all) struct Cleanup {
  address : Int
  size : Int
  align : Int
}


================================================
File 68: /data/input/moonbit-docs/legacy/examples/wasi-http/gen/ffi.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!

///|
pub fn cabi_realloc(
  src_offset : Int,
  src_size : Int,
  dst_alignment : Int,
  dst_size : Int
) -> Int {
  @ffi.cabi_realloc(src_offset, src_size, dst_alignment, dst_size)
}


================================================
File 69: /data/input/moonbit-docs/legacy/examples/wasi-http/gen/gen_interface_wasi_http_incoming_handler_export.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!

///|
pub fn wasmExportHandle(p0 : Int, p1 : Int) -> Unit {
  let _ = @incomingHandler.handle(
    @types.IncomingRequest::IncomingRequest(p0),
    @types.ResponseOutparam::ResponseOutparam(p1),
  )

}


================================================
File 70: /data/input/moonbit-docs/legacy/examples/wasi-http/gen/interface/wasi/http/incomingHandler/README.md
================================================
This interface defines a handler of incoming HTTP Requests. It should
be exported by components which can respond to HTTP Requests.

================================================
File 71: /data/input/moonbit-docs/legacy/examples/wasi-http/gen/interface/wasi/http/incomingHandler/stub.mbt
================================================
// Generated by `wit-bindgen` 0.36.0.
///| This function is invoked with an incoming HTTP Request, and a resource
/// `response-outparam` which provides the capability to reply with an HTTP
/// Response. The response is sent by calling the `response-outparam.set`
/// method, which allows execution to continue after the response has been
/// sent. This enables both streaming to the response body, and performing other
/// work.
///
/// The implementor of this function must write a response to the
/// `response-outparam` before returning, or else the caller will respond
/// with an error on its behalf.
pub fn handle(
  _request : @types.IncomingRequest,
  _response_out : @types.ResponseOutparam
) -> Unit {
  ...
}


================================================
File 72: /data/input/moonbit-docs/legacy/examples/wasi-http/gen/interface/wasi/http/incomingHandler/top.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!


================================================
File 73: /data/input/moonbit-docs/legacy/examples/wasi-http/gen/world/server/stub.mbt
================================================
// Generated by `wit-bindgen` 0.36.0.


================================================
File 74: /data/input/moonbit-docs/legacy/examples/wasi-http/gen/world_server_export.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!


================================================
File 75: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/cli/stderr/ffi.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///|
fn wasmImportGetStderr() -> Int = "wasi:cli/stderr@0.2.1" "get-stderr"


================================================
File 76: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/cli/stderr/top.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!

///|
pub fn get_stderr() -> @streams.OutputStream {
  let result : Int = wasmImportGetStderr()
  return @streams.OutputStream::OutputStream(result)
}


================================================
File 77: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/cli/stdin/ffi.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///|
fn wasmImportGetStdin() -> Int = "wasi:cli/stdin@0.2.1" "get-stdin"


================================================
File 78: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/cli/stdin/top.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!

///|
pub fn get_stdin() -> @streams.InputStream {
  let result : Int = wasmImportGetStdin()
  return @streams.InputStream::InputStream(result)
}


================================================
File 79: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/cli/stdout/ffi.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///|
fn wasmImportGetStdout() -> Int = "wasi:cli/stdout@0.2.1" "get-stdout"


================================================
File 80: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/cli/stdout/top.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!

///|
pub fn get_stdout() -> @streams.OutputStream {
  let result : Int = wasmImportGetStdout()
  return @streams.OutputStream::OutputStream(result)
}


================================================
File 81: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/clocks/monotonicClock/README.md
================================================
WASI Monotonic Clock is a clock API intended to let users measure elapsed
time.

It is intended to be portable at least between Unix-family platforms and
Windows.

A monotonic clock is a clock which has an unspecified initial value, and
successive reads of the clock will produce non-decreasing values.

================================================
File 82: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/clocks/monotonicClock/ffi.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///|
fn wasmImportNow() -> Int64 = "wasi:clocks/monotonic-clock@0.2.1" "now"

///|
fn wasmImportResolution() -> Int64 = "wasi:clocks/monotonic-clock@0.2.1" "resolution"

///|
fn wasmImportSubscribeInstant(p0 : Int64) -> Int = "wasi:clocks/monotonic-clock@0.2.1" "subscribe-instant"

///|
fn wasmImportSubscribeDuration(p0 : Int64) -> Int = "wasi:clocks/monotonic-clock@0.2.1" "subscribe-duration"


================================================
File 83: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/clocks/monotonicClock/top.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///| Read the current value of the clock.
///
/// The clock is monotonic, therefore calling this function repeatedly will
/// produce a sequence of non-decreasing values.
pub fn now() -> UInt64 {
  let result : Int64 = wasmImportNow()
  return result.reinterpret_as_uint64()
}

///| Query the resolution of the clock. Returns the duration of time
/// corresponding to a clock tick.
pub fn resolution() -> UInt64 {
  let result : Int64 = wasmImportResolution()
  return result.reinterpret_as_uint64()
}

///| Create a `pollable` which will resolve once the specified instant
/// has occurred.
pub fn subscribe_instant(when : UInt64) -> @poll.Pollable {
  let result : Int = wasmImportSubscribeInstant(when.reinterpret_as_int64())
  return @poll.Pollable::Pollable(result)
}

///| Create a `pollable` that will resolve after the specified duration has
/// elapsed from the time this function is invoked.
pub fn subscribe_duration(when : UInt64) -> @poll.Pollable {
  let result : Int = wasmImportSubscribeDuration(when.reinterpret_as_int64())
  return @poll.Pollable::Pollable(result)
}


================================================
File 84: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/clocks/wallClock/README.md
================================================
WASI Wall Clock is a clock API intended to let users query the current
time. The name "wall" makes an analogy to a "clock on the wall", which
is not necessarily monotonic as it may be reset.

It is intended to be portable at least between Unix-family platforms and
Windows.

A wall clock is a clock which measures the date and time according to
some external reference.

External references may be reset, so this clock is not necessarily
monotonic, making it unsuitable for measuring elapsed time.

It is intended for reporting the current date and time for humans.

================================================
File 85: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/clocks/wallClock/ffi.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///|
fn wasmImportNow(p0 : Int) = "wasi:clocks/wall-clock@0.2.1" "now"

///|
fn wasmImportResolution(p0 : Int) = "wasi:clocks/wall-clock@0.2.1" "resolution"


================================================
File 86: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/clocks/wallClock/top.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///| A time and date in seconds plus nanoseconds.
pub(all) struct Datetime {
  seconds : UInt64
  nanoseconds : UInt
} derive(Show, Eq)

///| Read the current value of the clock.
///
/// This clock is not monotonic, therefore calling this function repeatedly
/// will not necessarily produce a sequence of non-decreasing values.
///
/// The returned timestamps represent the number of seconds since
/// 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
/// also known as [Unix Time].
///
/// The nanoseconds field of the output is always less than 1000000000.
///
/// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
/// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
pub fn now() -> Datetime {
  let return_area = @ffi.malloc(16)
  wasmImportNow(return_area)
  @ffi.free(return_area)
  return Datetime::{
    seconds: @ffi.load64(return_area + 0).reinterpret_as_uint64(),
    nanoseconds: @ffi.load32(return_area + 8).reinterpret_as_uint(),
  }
}

///| Query the resolution of the clock.
///
/// The nanoseconds field of the output is always less than 1000000000.
pub fn resolution() -> Datetime {
  let return_area = @ffi.malloc(16)
  wasmImportResolution(return_area)
  @ffi.free(return_area)
  return Datetime::{
    seconds: @ffi.load64(return_area + 0).reinterpret_as_uint64(),
    nanoseconds: @ffi.load32(return_area + 8).reinterpret_as_uint(),
  }
}


================================================
File 87: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/http/outgoingHandler/README.md
================================================
This interface defines a handler of outgoing HTTP Requests. It should be
imported by components which wish to make HTTP Requests.

================================================
File 88: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/http/outgoingHandler/ffi.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///|
fn wasmImportHandle(p0 : Int, p1 : Int, p2 : Int, p3 : Int) = "wasi:http/outgoing-handler@0.2.1" "handle"


================================================
File 89: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/http/outgoingHandler/top.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///| This function is invoked with an outgoing HTTP Request, and it returns
/// a resource `future-incoming-response` which represents an HTTP Response
/// which may arrive in the future.
///
/// The `options` argument accepts optional parameters for the HTTP
/// protocol's transport layer.
///
/// This function may return an error if the `outgoing-request` is invalid
/// or not allowed to be made. Otherwise, protocol errors are reported
/// through the `future-incoming-response`.
pub fn handle(
  request : @types.OutgoingRequest,
  options : @types.RequestOptions?
) -> Result[@types.FutureIncomingResponse, @types.ErrorCode] {
  let @types.OutgoingRequest(handle) = request
  let (lowered, lowered4) = match options {
    None => (0, 0)
    Some(payload2) => {
      let @types.RequestOptions(handle3) = payload2
      (1, handle3)
    }
  }
  let return_area = @ffi.malloc(40)
  wasmImportHandle(handle, lowered, lowered4, return_area)
  let lifted205 = match @ffi.load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        @types.FutureIncomingResponse::FutureIncomingResponse(
          @ffi.load32(return_area + 8),
        ),
      )
    1 => {
      let lifted204 = match @ffi.load8_u(return_area + 8) {
        0 => @types.ErrorCode::DnsTimeout
        1 => {
          let lifted : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result)
            }
            _ => panic()
          }
          let lifted21 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(
                @ffi.load16_u(return_area + 30)
                .land(0xFFFF)
                .reinterpret_as_uint(),
              )
            _ => panic()
          }
          @types.ErrorCode::DnsError(@types.DnsErrorPayload::{
            rcode: lifted,
            info_code: lifted21,
          })
        }
        2 => @types.ErrorCode::DestinationNotFound
        3 => @types.ErrorCode::DestinationUnavailable
        4 => @types.ErrorCode::DestinationIpProhibited
        5 => @types.ErrorCode::DestinationIpUnroutable
        6 => @types.ErrorCode::ConnectionRefused
        7 => @types.ErrorCode::ConnectionTerminated
        8 => @types.ErrorCode::ConnectionTimeout
        9 => @types.ErrorCode::ConnectionReadTimeout
        10 => @types.ErrorCode::ConnectionWriteTimeout
        11 => @types.ErrorCode::ConnectionLimitReached
        12 => @types.ErrorCode::TlsProtocolError
        13 => @types.ErrorCode::TlsCertificateError
        14 => {
          let lifted52 : Byte? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => Option::Some(@ffi.load8_u(return_area + 17).to_byte())
            _ => panic()
          }
          let lifted58 : String? = match @ffi.load8_u(return_area + 20) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 28))
              let result57 = @ffi.ptr2str(@ffi.load32(return_area + 24))
              Option::Some(result57)
            }
            _ => panic()
          }
          @types.ErrorCode::TlsAlertReceived(@types.TlsAlertReceivedPayload::{
            alert_id: lifted52,
            alert_message: lifted58,
          })
        }
        15 => @types.ErrorCode::HttpRequestDenied
        16 => @types.ErrorCode::HttpRequestLengthRequired
        17 => {
          let lifted69 : UInt64? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                @ffi.load64(return_area + 24).reinterpret_as_uint64(),
              )
            _ => panic()
          }
          @types.ErrorCode::HttpRequestBodySize(lifted69)
        }
        18 => @types.ErrorCode::HttpRequestMethodInvalid
        19 => @types.ErrorCode::HttpRequestUriInvalid
        20 => @types.ErrorCode::HttpRequestUriTooLong
        21 => {
          let lifted82 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          @types.ErrorCode::HttpRequestHeaderSectionSize(lifted82)
        }
        22 => {
          let lifted100 : @types.FieldSizePayload? = match
            @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let lifted94 : String? = match @ffi.load8_u(return_area + 20) {
                0 => Option::None
                1 => {
                  ignore(@ffi.load32(return_area + 28))
                  let result93 = @ffi.ptr2str(@ffi.load32(return_area + 24))
                  Option::Some(result93)
                }
                _ => panic()
              }
              let lifted99 : UInt? = match @ffi.load8_u(return_area + 32) {
                0 => Option::None
                1 =>
                  Option::Some(
                    @ffi.load32(return_area + 36).reinterpret_as_uint(),
                  )
                _ => panic()
              }
              Option::Some(@types.FieldSizePayload::{
                field_name: lifted94,
                field_size: lifted99,
              })
            }
            _ => panic()
          }
          @types.ErrorCode::HttpRequestHeaderSize(lifted100)
        }
        23 => {
          let lifted107 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          @types.ErrorCode::HttpRequestTrailerSectionSize(lifted107)
        }
        24 => {
          let lifted115 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result114 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result114)
            }
            _ => panic()
          }
          let lifted120 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 32).reinterpret_as_uint())
            _ => panic()
          }
          @types.ErrorCode::HttpRequestTrailerSize(@types.FieldSizePayload::{
            field_name: lifted115,
            field_size: lifted120,
          })
        }
        25 => @types.ErrorCode::HttpResponseIncomplete
        26 => {
          let lifted129 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          @types.ErrorCode::HttpResponseHeaderSectionSize(lifted129)
        }
        27 => {
          let lifted137 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result136 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result136)
            }
            _ => panic()
          }
          let lifted142 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 32).reinterpret_as_uint())
            _ => panic()
          }
          @types.ErrorCode::HttpResponseHeaderSize(@types.FieldSizePayload::{
            field_name: lifted137,
            field_size: lifted142,
          })
        }
        28 => {
          let lifted149 : UInt64? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                @ffi.load64(return_area + 24).reinterpret_as_uint64(),
              )
            _ => panic()
          }
          @types.ErrorCode::HttpResponseBodySize(lifted149)
        }
        29 => {
          let lifted156 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          @types.ErrorCode::HttpResponseTrailerSectionSize(lifted156)
        }
        30 => {
          let lifted164 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result163 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result163)
            }
            _ => panic()
          }
          let lifted169 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 32).reinterpret_as_uint())
            _ => panic()
          }
          @types.ErrorCode::HttpResponseTrailerSize(@types.FieldSizePayload::{
            field_name: lifted164,
            field_size: lifted169,
          })
        }
        31 => {
          let lifted177 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result176 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result176)
            }
            _ => panic()
          }
          @types.ErrorCode::HttpResponseTransferCoding(lifted177)
        }
        32 => {
          let lifted185 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result184 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result184)
            }
            _ => panic()
          }
          @types.ErrorCode::HttpResponseContentCoding(lifted185)
        }
        33 => @types.ErrorCode::HttpResponseTimeout
        34 => @types.ErrorCode::HttpUpgradeFailed
        35 => @types.ErrorCode::HttpProtocolError
        36 => @types.ErrorCode::LoopDetected
        37 => @types.ErrorCode::ConfigurationError
        38 => {
          let lifted203 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result202 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result202)
            }
            _ => panic()
          }
          @types.ErrorCode::InternalError(lifted203)
        }
        _ => panic()
      }
      Result::Err(lifted204)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted205
}


================================================
File 90: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/http/types/README.md
================================================
This interface defines all of the types and methods for implementing
HTTP Requests and Responses, both incoming and outgoing, as well as
their headers, trailers, and bodies.

================================================
File 91: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/http/types/ffi.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!

///|
fn wasmImportResourceDropFields(resource : Int) = "wasi:http/types@0.2.1" "[resource-drop]fields"

///|
fn wasmImportResourceDropIncomingRequest(resource : Int) = "wasi:http/types@0.2.1" "[resource-drop]incoming-request"

///|
fn wasmImportResourceDropOutgoingRequest(resource : Int) = "wasi:http/types@0.2.1" "[resource-drop]outgoing-request"

///|
fn wasmImportResourceDropRequestOptions(resource : Int) = "wasi:http/types@0.2.1" "[resource-drop]request-options"

///|
fn wasmImportResourceDropResponseOutparam(resource : Int) = "wasi:http/types@0.2.1" "[resource-drop]response-outparam"

///|
fn wasmImportResourceDropIncomingResponse(resource : Int) = "wasi:http/types@0.2.1" "[resource-drop]incoming-response"

///|
fn wasmImportResourceDropIncomingBody(resource : Int) = "wasi:http/types@0.2.1" "[resource-drop]incoming-body"

///|
fn wasmImportResourceDropFutureTrailers(resource : Int) = "wasi:http/types@0.2.1" "[resource-drop]future-trailers"

///|
fn wasmImportResourceDropOutgoingResponse(resource : Int) = "wasi:http/types@0.2.1" "[resource-drop]outgoing-response"

///|
fn wasmImportResourceDropOutgoingBody(resource : Int) = "wasi:http/types@0.2.1" "[resource-drop]outgoing-body"

///|
fn wasmImportResourceDropFutureIncomingResponse(resource : Int) = "wasi:http/types@0.2.1" "[resource-drop]future-incoming-response"

///|
fn wasmImportHttpErrorCode(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "http-error-code"

///|
fn wasmImportConstructorFields() -> Int = "wasi:http/types@0.2.1" "[constructor]fields"

///|
fn wasmImportStaticFieldsFromList(p0 : Int, p1 : Int, p2 : Int) = "wasi:http/types@0.2.1" "[static]fields.from-list"

///|
fn wasmImportMethodFieldsGet(p0 : Int, p1 : Int, p2 : Int, p3 : Int) = "wasi:http/types@0.2.1" "[method]fields.get"

///|
fn wasmImportMethodFieldsHas(p0 : Int, p1 : Int, p2 : Int) -> Int = "wasi:http/types@0.2.1" "[method]fields.has"

///|
fn wasmImportMethodFieldsSet(
  p0 : Int,
  p1 : Int,
  p2 : Int,
  p3 : Int,
  p4 : Int,
  p5 : Int
) = "wasi:http/types@0.2.1" "[method]fields.set"

///|
fn wasmImportMethodFieldsDelete(p0 : Int, p1 : Int, p2 : Int, p3 : Int) = "wasi:http/types@0.2.1" "[method]fields.delete"

///|
fn wasmImportMethodFieldsAppend(
  p0 : Int,
  p1 : Int,
  p2 : Int,
  p3 : Int,
  p4 : Int,
  p5 : Int
) = "wasi:http/types@0.2.1" "[method]fields.append"

///|
fn wasmImportMethodFieldsEntries(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]fields.entries"

///|
fn wasmImportMethodFieldsClone(p0 : Int) -> Int = "wasi:http/types@0.2.1" "[method]fields.clone"

///|
fn wasmImportMethodIncomingRequestMethod(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]incoming-request.method"

///|
fn wasmImportMethodIncomingRequestPathWithQuery(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]incoming-request.path-with-query"

///|
fn wasmImportMethodIncomingRequestScheme(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]incoming-request.scheme"

///|
fn wasmImportMethodIncomingRequestAuthority(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]incoming-request.authority"

///|
fn wasmImportMethodIncomingRequestHeaders(p0 : Int) -> Int = "wasi:http/types@0.2.1" "[method]incoming-request.headers"

///|
fn wasmImportMethodIncomingRequestConsume(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]incoming-request.consume"

///|
fn wasmImportConstructorOutgoingRequest(p0 : Int) -> Int = "wasi:http/types@0.2.1" "[constructor]outgoing-request"

///|
fn wasmImportMethodOutgoingRequestBody(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]outgoing-request.body"

///|
fn wasmImportMethodOutgoingRequestMethod(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]outgoing-request.method"

///|
fn wasmImportMethodOutgoingRequestSetMethod(
  p0 : Int,
  p1 : Int,
  p2 : Int,
  p3 : Int
) -> Int = "wasi:http/types@0.2.1" "[method]outgoing-request.set-method"

///|
fn wasmImportMethodOutgoingRequestPathWithQuery(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]outgoing-request.path-with-query"

///|
fn wasmImportMethodOutgoingRequestSetPathWithQuery(
  p0 : Int,
  p1 : Int,
  p2 : Int,
  p3 : Int
) -> Int = "wasi:http/types@0.2.1" "[method]outgoing-request.set-path-with-query"

///|
fn wasmImportMethodOutgoingRequestScheme(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]outgoing-request.scheme"

///|
fn wasmImportMethodOutgoingRequestSetScheme(
  p0 : Int,
  p1 : Int,
  p2 : Int,
  p3 : Int,
  p4 : Int
) -> Int = "wasi:http/types@0.2.1" "[method]outgoing-request.set-scheme"

///|
fn wasmImportMethodOutgoingRequestAuthority(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]outgoing-request.authority"

///|
fn wasmImportMethodOutgoingRequestSetAuthority(
  p0 : Int,
  p1 : Int,
  p2 : Int,
  p3 : Int
) -> Int = "wasi:http/types@0.2.1" "[method]outgoing-request.set-authority"

///|
fn wasmImportMethodOutgoingRequestHeaders(p0 : Int) -> Int = "wasi:http/types@0.2.1" "[method]outgoing-request.headers"

///|
fn wasmImportConstructorRequestOptions() -> Int = "wasi:http/types@0.2.1" "[constructor]request-options"

///|
fn wasmImportMethodRequestOptionsConnectTimeout(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]request-options.connect-timeout"

///|
fn wasmImportMethodRequestOptionsSetConnectTimeout(
  p0 : Int,
  p1 : Int,
  p2 : Int64
) -> Int = "wasi:http/types@0.2.1" "[method]request-options.set-connect-timeout"

///|
fn wasmImportMethodRequestOptionsFirstByteTimeout(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]request-options.first-byte-timeout"

///|
fn wasmImportMethodRequestOptionsSetFirstByteTimeout(
  p0 : Int,
  p1 : Int,
  p2 : Int64
) -> Int = "wasi:http/types@0.2.1" "[method]request-options.set-first-byte-timeout"

///|
fn wasmImportMethodRequestOptionsBetweenBytesTimeout(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]request-options.between-bytes-timeout"

///|
fn wasmImportMethodRequestOptionsSetBetweenBytesTimeout(
  p0 : Int,
  p1 : Int,
  p2 : Int64
) -> Int = "wasi:http/types@0.2.1" "[method]request-options.set-between-bytes-timeout"

///|
fn wasmImportStaticResponseOutparamSet(
  p0 : Int,
  p1 : Int,
  p2 : Int,
  p3 : Int,
  p4 : Int64,
  p5 : Int,
  p6 : Int,
  p7 : Int,
  p8 : Int
) = "wasi:http/types@0.2.1" "[static]response-outparam.set"

///|
fn wasmImportMethodIncomingResponseStatus(p0 : Int) -> Int = "wasi:http/types@0.2.1" "[method]incoming-response.status"

///|
fn wasmImportMethodIncomingResponseHeaders(p0 : Int) -> Int = "wasi:http/types@0.2.1" "[method]incoming-response.headers"

///|
fn wasmImportMethodIncomingResponseConsume(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]incoming-response.consume"

///|
fn wasmImportMethodIncomingBodyStream(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]incoming-body.stream"

///|
fn wasmImportStaticIncomingBodyFinish(p0 : Int) -> Int = "wasi:http/types@0.2.1" "[static]incoming-body.finish"

///|
fn wasmImportMethodFutureTrailersSubscribe(p0 : Int) -> Int = "wasi:http/types@0.2.1" "[method]future-trailers.subscribe"

///|
fn wasmImportMethodFutureTrailersGet(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]future-trailers.get"

///|
fn wasmImportConstructorOutgoingResponse(p0 : Int) -> Int = "wasi:http/types@0.2.1" "[constructor]outgoing-response"

///|
fn wasmImportMethodOutgoingResponseStatusCode(p0 : Int) -> Int = "wasi:http/types@0.2.1" "[method]outgoing-response.status-code"

///|
fn wasmImportMethodOutgoingResponseSetStatusCode(p0 : Int, p1 : Int) -> Int = "wasi:http/types@0.2.1" "[method]outgoing-response.set-status-code"

///|
fn wasmImportMethodOutgoingResponseHeaders(p0 : Int) -> Int = "wasi:http/types@0.2.1" "[method]outgoing-response.headers"

///|
fn wasmImportMethodOutgoingResponseBody(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]outgoing-response.body"

///|
fn wasmImportMethodOutgoingBodyWrite(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]outgoing-body.write"

///|
fn wasmImportStaticOutgoingBodyFinish(p0 : Int, p1 : Int, p2 : Int, p3 : Int) = "wasi:http/types@0.2.1" "[static]outgoing-body.finish"

///|
fn wasmImportMethodFutureIncomingResponseSubscribe(p0 : Int) -> Int = "wasi:http/types@0.2.1" "[method]future-incoming-response.subscribe"

///|
fn wasmImportMethodFutureIncomingResponseGet(p0 : Int, p1 : Int) = "wasi:http/types@0.2.1" "[method]future-incoming-response.get"


================================================
File 92: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/http/types/top.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///| This type corresponds to HTTP standard Methods.
pub(all) enum Method {
  Get
  Head
  Post
  Put
  Delete
  Connect
  Options
  Trace
  Patch
  Other(String)
} derive(Show, Eq)

///| This type corresponds to HTTP standard Related Schemes.
pub(all) enum Scheme {
  Http
  Https
  Other(String)
} derive(Show, Eq)

///| Defines the case payload type for `DNS-error` above:
pub(all) struct DnsErrorPayload {
  rcode : String?
  info_code : UInt?
} derive(Show, Eq)

///| Defines the case payload type for `TLS-alert-received` above:
pub(all) struct TlsAlertReceivedPayload {
  alert_id : Byte?
  alert_message : String?
} derive(Show, Eq)

///| Defines the case payload type for `HTTP-response-{header,trailer}-size` above:
pub(all) struct FieldSizePayload {
  field_name : String?
  field_size : UInt?
} derive(Show, Eq)

///| These cases are inspired by the IANA HTTP Proxy Error Types:
/// https://www.iana.org/assignments/http-proxy-status/http-proxy-status.xhtml#table-http-proxy-error-types
pub(all) type! ErrorCode {
  DnsTimeout
  DnsError(DnsErrorPayload)
  DestinationNotFound
  DestinationUnavailable
  DestinationIpProhibited
  DestinationIpUnroutable
  ConnectionRefused
  ConnectionTerminated
  ConnectionTimeout
  ConnectionReadTimeout
  ConnectionWriteTimeout
  ConnectionLimitReached
  TlsProtocolError
  TlsCertificateError
  TlsAlertReceived(TlsAlertReceivedPayload)
  HttpRequestDenied
  HttpRequestLengthRequired
  HttpRequestBodySize(UInt64?)
  HttpRequestMethodInvalid
  HttpRequestUriInvalid
  HttpRequestUriTooLong
  HttpRequestHeaderSectionSize(UInt?)
  HttpRequestHeaderSize(FieldSizePayload?)
  HttpRequestTrailerSectionSize(UInt?)
  HttpRequestTrailerSize(FieldSizePayload)
  HttpResponseIncomplete
  HttpResponseHeaderSectionSize(UInt?)
  HttpResponseHeaderSize(FieldSizePayload)
  HttpResponseBodySize(UInt64?)
  HttpResponseTrailerSectionSize(UInt?)
  HttpResponseTrailerSize(FieldSizePayload)
  HttpResponseTransferCoding(String?)
  HttpResponseContentCoding(String?)
  HttpResponseTimeout
  HttpUpgradeFailed
  HttpProtocolError
  LoopDetected
  ConfigurationError
  InternalError(String?)
} derive(Show, Eq)

///| This type enumerates the different kinds of errors that may occur when
/// setting or appending to a `fields` resource.
pub(all) type! HeaderError {
  InvalidSyntax
  Forbidden
  Immutable
} derive(Show, Eq)

///| This following block defines the `fields` resource which corresponds to
/// HTTP standard Fields. Fields are a common representation used for both
/// Headers and Trailers.
///
/// A `fields` may be mutable or immutable. A `fields` created using the
/// constructor, `from-list`, or `clone` will be mutable, but a `fields`
/// resource given by other means (including, but not limited to,
/// `incoming-request.headers`, `outgoing-request.headers`) might be be
/// immutable. In an immutable fields, the `set`, `append`, and `delete`
/// operations will fail with `header-error.immutable`.
pub(all) type Fields Int derive(Show, Eq)

///| Drops a resource handle.
pub fn Fields::drop(self : Fields) -> Unit {
  let Fields(resource) = self
  wasmImportResourceDropFields(resource)
}

///| Represents an incoming HTTP Request.
pub(all) type IncomingRequest Int derive(Show, Eq)

///| Drops a resource handle.
pub fn IncomingRequest::drop(self : IncomingRequest) -> Unit {
  let IncomingRequest(resource) = self
  wasmImportResourceDropIncomingRequest(resource)
}

///| Represents an outgoing HTTP Request.
pub(all) type OutgoingRequest Int derive(Show, Eq)

///| Drops a resource handle.
pub fn OutgoingRequest::drop(self : OutgoingRequest) -> Unit {
  let OutgoingRequest(resource) = self
  wasmImportResourceDropOutgoingRequest(resource)
}

///| Parameters for making an HTTP Request. Each of these parameters is
/// currently an optional timeout applicable to the transport layer of the
/// HTTP protocol.
///
/// These timeouts are separate from any the user may use to bound a
/// blocking call to `wasi:io/poll.poll`.
pub(all) type RequestOptions Int derive(Show, Eq)

///| Drops a resource handle.
pub fn RequestOptions::drop(self : RequestOptions) -> Unit {
  let RequestOptions(resource) = self
  wasmImportResourceDropRequestOptions(resource)
}

///| Represents the ability to send an HTTP Response.
///
/// This resource is used by the `wasi:http/incoming-handler` interface to
/// allow a Response to be sent corresponding to the Request provided as the
/// other argument to `incoming-handler.handle`.
pub(all) type ResponseOutparam Int derive(Show, Eq)

///| Drops a resource handle.
pub fn ResponseOutparam::drop(self : ResponseOutparam) -> Unit {
  let ResponseOutparam(resource) = self
  wasmImportResourceDropResponseOutparam(resource)
}

///| Represents an incoming HTTP Response.
pub(all) type IncomingResponse Int derive(Show, Eq)

///| Drops a resource handle.
pub fn IncomingResponse::drop(self : IncomingResponse) -> Unit {
  let IncomingResponse(resource) = self
  wasmImportResourceDropIncomingResponse(resource)
}

///| Represents an incoming HTTP Request or Response's Body.
///
/// A body has both its contents - a stream of bytes - and a (possibly
/// empty) set of trailers, indicating that the full contents of the
/// body have been received. This resource represents the contents as
/// an `input-stream` and the delivery of trailers as a `future-trailers`,
/// and ensures that the user of this interface may only be consuming either
/// the body contents or waiting on trailers at any given time.
pub(all) type IncomingBody Int derive(Show, Eq)

///| Drops a resource handle.
pub fn IncomingBody::drop(self : IncomingBody) -> Unit {
  let IncomingBody(resource) = self
  wasmImportResourceDropIncomingBody(resource)
}

///| Represents a future which may eventually return trailers, or an error.
///
/// In the case that the incoming HTTP Request or Response did not have any
/// trailers, this future will resolve to the empty set of trailers once the
/// complete Request or Response body has been received.
pub(all) type FutureTrailers Int derive(Show, Eq)

///| Drops a resource handle.
pub fn FutureTrailers::drop(self : FutureTrailers) -> Unit {
  let FutureTrailers(resource) = self
  wasmImportResourceDropFutureTrailers(resource)
}

///| Represents an outgoing HTTP Response.
pub(all) type OutgoingResponse Int derive(Show, Eq)

///| Drops a resource handle.
pub fn OutgoingResponse::drop(self : OutgoingResponse) -> Unit {
  let OutgoingResponse(resource) = self
  wasmImportResourceDropOutgoingResponse(resource)
}

///| Represents an outgoing HTTP Request or Response's Body.
///
/// A body has both its contents - a stream of bytes - and a (possibly
/// empty) set of trailers, inducating the full contents of the body
/// have been sent. This resource represents the contents as an
/// `output-stream` child resource, and the completion of the body (with
/// optional trailers) with a static function that consumes the
/// `outgoing-body` resource, and ensures that the user of this interface
/// may not write to the body contents after the body has been finished.
///
/// If the user code drops this resource, as opposed to calling the static
/// method `finish`, the implementation should treat the body as incomplete,
/// and that an error has occurred. The implementation should propagate this
/// error to the HTTP protocol by whatever means it has available,
/// including: corrupting the body on the wire, aborting the associated
/// Request, or sending a late status code for the Response.
pub(all) type OutgoingBody Int derive(Show, Eq)

///| Drops a resource handle.
pub fn OutgoingBody::drop(self : OutgoingBody) -> Unit {
  let OutgoingBody(resource) = self
  wasmImportResourceDropOutgoingBody(resource)
}

///| Represents a future which may eventually return an incoming HTTP
/// Response, or an error.
///
/// This resource is returned by the `wasi:http/outgoing-handler` interface to
/// provide the HTTP Response corresponding to the sent Request.
pub(all) type FutureIncomingResponse Int derive(Show, Eq)

///| Drops a resource handle.
pub fn FutureIncomingResponse::drop(self : FutureIncomingResponse) -> Unit {
  let FutureIncomingResponse(resource) = self
  wasmImportResourceDropFutureIncomingResponse(resource)
}

///| Attempts to extract a http-related `error` from the wasi:io `error`
/// provided.
///
/// Stream operations which return
/// `wasi:io/stream/stream-error::last-operation-failed` have a payload of
/// type `wasi:io/error/error` with more information about the operation
/// that failed. This payload can be passed through to this function to see
/// if there's http-related information about the error to return.
///
/// Note that this function is fallible because not all io-errors are
/// http-related errors.
pub fn http_error_code(err : @error.Error_) -> ErrorCode? {
  let @error.Error_(handle) = err
  let return_area = @ffi.malloc(40)
  wasmImportHttpErrorCode(handle, return_area)
  let lifted198 : ErrorCode? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let lifted197 = match @ffi.load8_u(return_area + 8) {
        0 => ErrorCode::DnsTimeout
        1 => {
          let lifted : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result)
            }
            _ => panic()
          }
          let lifted14 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(
                @ffi.load16_u(return_area + 30)
                .land(0xFFFF)
                .reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::DnsError(DnsErrorPayload::{
            rcode: lifted,
            info_code: lifted14,
          })
        }
        2 => ErrorCode::DestinationNotFound
        3 => ErrorCode::DestinationUnavailable
        4 => ErrorCode::DestinationIpProhibited
        5 => ErrorCode::DestinationIpUnroutable
        6 => ErrorCode::ConnectionRefused
        7 => ErrorCode::ConnectionTerminated
        8 => ErrorCode::ConnectionTimeout
        9 => ErrorCode::ConnectionReadTimeout
        10 => ErrorCode::ConnectionWriteTimeout
        11 => ErrorCode::ConnectionLimitReached
        12 => ErrorCode::TlsProtocolError
        13 => ErrorCode::TlsCertificateError
        14 => {
          let lifted45 : Byte? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => Option::Some(@ffi.load8_u(return_area + 17).to_byte())
            _ => panic()
          }
          let lifted51 : String? = match @ffi.load8_u(return_area + 20) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 28))
              let result50 = @ffi.ptr2str(@ffi.load32(return_area + 24))
              Option::Some(result50)
            }
            _ => panic()
          }
          ErrorCode::TlsAlertReceived(TlsAlertReceivedPayload::{
            alert_id: lifted45,
            alert_message: lifted51,
          })
        }
        15 => ErrorCode::HttpRequestDenied
        16 => ErrorCode::HttpRequestLengthRequired
        17 => {
          let lifted62 : UInt64? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                @ffi.load64(return_area + 24).reinterpret_as_uint64(),
              )
            _ => panic()
          }
          ErrorCode::HttpRequestBodySize(lifted62)
        }
        18 => ErrorCode::HttpRequestMethodInvalid
        19 => ErrorCode::HttpRequestUriInvalid
        20 => ErrorCode::HttpRequestUriTooLong
        21 => {
          let lifted75 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpRequestHeaderSectionSize(lifted75)
        }
        22 => {
          let lifted93 : FieldSizePayload? = match
            @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let lifted87 : String? = match @ffi.load8_u(return_area + 20) {
                0 => Option::None
                1 => {
                  ignore(@ffi.load32(return_area + 28))
                  let result86 = @ffi.ptr2str(@ffi.load32(return_area + 24))
                  Option::Some(result86)
                }
                _ => panic()
              }
              let lifted92 : UInt? = match @ffi.load8_u(return_area + 32) {
                0 => Option::None
                1 =>
                  Option::Some(
                    @ffi.load32(return_area + 36).reinterpret_as_uint(),
                  )
                _ => panic()
              }
              Option::Some(FieldSizePayload::{
                field_name: lifted87,
                field_size: lifted92,
              })
            }
            _ => panic()
          }
          ErrorCode::HttpRequestHeaderSize(lifted93)
        }
        23 => {
          let lifted100 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpRequestTrailerSectionSize(lifted100)
        }
        24 => {
          let lifted108 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result107 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result107)
            }
            _ => panic()
          }
          let lifted113 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 32).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpRequestTrailerSize(FieldSizePayload::{
            field_name: lifted108,
            field_size: lifted113,
          })
        }
        25 => ErrorCode::HttpResponseIncomplete
        26 => {
          let lifted122 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpResponseHeaderSectionSize(lifted122)
        }
        27 => {
          let lifted130 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result129 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result129)
            }
            _ => panic()
          }
          let lifted135 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 32).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpResponseHeaderSize(FieldSizePayload::{
            field_name: lifted130,
            field_size: lifted135,
          })
        }
        28 => {
          let lifted142 : UInt64? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                @ffi.load64(return_area + 24).reinterpret_as_uint64(),
              )
            _ => panic()
          }
          ErrorCode::HttpResponseBodySize(lifted142)
        }
        29 => {
          let lifted149 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpResponseTrailerSectionSize(lifted149)
        }
        30 => {
          let lifted157 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result156 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result156)
            }
            _ => panic()
          }
          let lifted162 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 32).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpResponseTrailerSize(FieldSizePayload::{
            field_name: lifted157,
            field_size: lifted162,
          })
        }
        31 => {
          let lifted170 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result169 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result169)
            }
            _ => panic()
          }
          ErrorCode::HttpResponseTransferCoding(lifted170)
        }
        32 => {
          let lifted178 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result177 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result177)
            }
            _ => panic()
          }
          ErrorCode::HttpResponseContentCoding(lifted178)
        }
        33 => ErrorCode::HttpResponseTimeout
        34 => ErrorCode::HttpUpgradeFailed
        35 => ErrorCode::HttpProtocolError
        36 => ErrorCode::LoopDetected
        37 => ErrorCode::ConfigurationError
        38 => {
          let lifted196 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result195 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result195)
            }
            _ => panic()
          }
          ErrorCode::InternalError(lifted196)
        }
        _ => panic()
      }
      Option::Some(lifted197)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted198
}

///| Construct an empty HTTP Fields.
///
/// The resulting `fields` is mutable.
pub fn Fields::fields() -> Fields {
  let result : Int = wasmImportConstructorFields()
  return Fields::Fields(result)
}

///| Construct an HTTP Fields.
///
/// The resulting `fields` is mutable.
///
/// The list represents each key-value pair in the Fields. Keys
/// which have multiple values are represented by multiple entries in this
/// list with the same key.
///
/// The tuple is a pair of the field key, represented as a string, and
/// Value, represented as a list of bytes.
///
/// An error result will be returned if any `field-key` or `field-value` is
/// syntactically invalid, or if a field is forbidden.
pub fn Fields::from_list(
  entries : Array[(String, FixedArray[Byte])]
) -> Result[Fields, HeaderError] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[&@ffi.Any] = []
  let address = @ffi.malloc(entries.length() * 16)
  for index = 0; index < entries.length(); index = index + 1 {
    let element : (String, FixedArray[Byte]) = entries[index]
    let base = address + index * 16
    @ffi.store32(base + 4, element.0.iter().count())
    @ffi.store32(base + 0, @ffi.str2ptr(element.0))
    @ffi.store32(base + 12, element.1.length())
    @ffi.store32(base + 8, @ffi.bytes2ptr(element.1))
    ignoreList.push(element.0)
    ignoreList.push(element.1)
  }
  let return_area = @ffi.malloc(8)
  wasmImportStaticFieldsFromList(address, entries.length(), return_area)
  let lifted10 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(Fields::Fields(@ffi.load32(return_area + 4)))
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 => HeaderError::InvalidSyntax
        1 => HeaderError::Forbidden
        2 => HeaderError::Immutable
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  @ffi.free(address)
  @ffi.free(return_area)
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted10
}

///| Get all of the values corresponding to a key. If the key is not present
/// in this `fields` or is syntactically invalid, an empty list is returned.
/// However, if the key is present but empty, this is represented by a list
/// with one or more empty field-values present.
pub fn Fields::get(self : Fields, name : String) -> Array[FixedArray[Byte]] {
  let Fields(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodFieldsGet(
    handle,
    @ffi.str2ptr(name),
    name.iter().count(),
    return_area,
  )
  let array : Array[FixedArray[Byte]] = []
  for index = 0; index < @ffi.load32(return_area + 4); index = index + 1 {
    let base = @ffi.load32(return_area + 0) + index * 8
    let result = @ffi.ptr2bytes(@ffi.load32(base + 0), @ffi.load32(base + 4))
    array.push(result)
  }
  @ffi.free(@ffi.load32(return_area + 0))
  ignore(name)
  @ffi.free(return_area)
  return array
}

///| Returns `true` when the key is present in this `fields`. If the key is
/// syntactically invalid, `false` is returned.
pub fn Fields::has(self : Fields, name : String) -> Bool {
  let Fields(handle) = self
  let result : Int = wasmImportMethodFieldsHas(
    handle,
    @ffi.str2ptr(name),
    name.iter().count(),
  )
  ignore(name)
  return result != 0
}

///| Set all of the values for a key. Clears any existing values for that
/// key, if they have been set.
///
/// Fails with `header-error.immutable` if the `fields` are immutable.
///
/// Fails with `header-error.invalid-syntax` if the `field-key` or any of
/// the `field-value`s are syntactically invalid.
pub fn Fields::set(
  self : Fields,
  name : String,
  value : Array[FixedArray[Byte]]
) -> Result[Unit, HeaderError] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[&@ffi.Any] = []
  let Fields(handle) = self
  let address = @ffi.malloc(value.length() * 8)
  for index = 0; index < value.length(); index = index + 1 {
    let element : FixedArray[Byte] = value[index]
    let base = address + index * 8
    @ffi.store32(base + 4, element.length())
    @ffi.store32(base + 0, @ffi.bytes2ptr(element))
    ignoreList.push(element)
  }
  let return_area = @ffi.malloc(2)
  wasmImportMethodFieldsSet(
    handle,
    @ffi.str2ptr(name),
    name.iter().count(),
    address,
    value.length(),
    return_area,
  )
  let lifted10 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 1) {
        0 => HeaderError::InvalidSyntax
        1 => HeaderError::Forbidden
        2 => HeaderError::Immutable
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(name)
  @ffi.free(address)
  @ffi.free(return_area)
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted10
}

///| Delete all values for a key. Does nothing if no values for the key
/// exist.
///
/// Fails with `header-error.immutable` if the `fields` are immutable.
///
/// Fails with `header-error.invalid-syntax` if the `field-key` is
/// syntactically invalid.
pub fn Fields::delete(
  self : Fields,
  name : String
) -> Result[Unit, HeaderError] {
  let Fields(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodFieldsDelete(
    handle,
    @ffi.str2ptr(name),
    name.iter().count(),
    return_area,
  )
  let lifted8 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 1) {
        0 => HeaderError::InvalidSyntax
        1 => HeaderError::Forbidden
        2 => HeaderError::Immutable
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(name)
  @ffi.free(return_area)
  return lifted8
}

///| Append a value for a key. Does not change or delete any existing
/// values for that key.
///
/// Fails with `header-error.immutable` if the `fields` are immutable.
///
/// Fails with `header-error.invalid-syntax` if the `field-key` or
/// `field-value` are syntactically invalid.
pub fn Fields::append(
  self : Fields,
  name : String,
  value : FixedArray[Byte]
) -> Result[Unit, HeaderError] {
  let Fields(handle) = self
  let return_area = @ffi.malloc(2)
  wasmImportMethodFieldsAppend(
    handle,
    @ffi.str2ptr(name),
    name.iter().count(),
    @ffi.bytes2ptr(value),
    value.length(),
    return_area,
  )
  let lifted8 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 1) {
        0 => HeaderError::InvalidSyntax
        1 => HeaderError::Forbidden
        2 => HeaderError::Immutable
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(name)
  ignore(value)
  @ffi.free(return_area)
  return lifted8
}

///| Retrieve the full set of keys and values in the Fields. Like the
/// constructor, the list represents each key-value pair.
///
/// The outer list represents each key-value pair in the Fields. Keys
/// which have multiple values are represented by multiple entries in this
/// list with the same key.
pub fn Fields::entries(self : Fields) -> Array[(String, FixedArray[Byte])] {
  let Fields(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodFieldsEntries(handle, return_area)
  let array : Array[(String, FixedArray[Byte])] = []
  for index = 0; index < @ffi.load32(return_area + 4); index = index + 1 {
    let base = @ffi.load32(return_area + 0) + index * 16
    ignore(@ffi.load32(base + 4))
    let result = @ffi.ptr2str(@ffi.load32(base + 0))
    let result0 = @ffi.ptr2bytes(@ffi.load32(base + 8), @ffi.load32(base + 12))
    array.push((result, result0))
  }
  @ffi.free(@ffi.load32(return_area + 0))
  @ffi.free(return_area)
  return array
}

///| Make a deep copy of the Fields. Equivalent in behavior to calling the
/// `fields` constructor on the return value of `entries`. The resulting
/// `fields` is mutable.
pub fn Fields::clone(self : Fields) -> Fields {
  let Fields(handle) = self
  let result : Int = wasmImportMethodFieldsClone(handle)
  return Fields::Fields(result)
}

///| Returns the method of the incoming request.
pub fn IncomingRequest::method_(self : IncomingRequest) -> Method {
  let IncomingRequest(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodIncomingRequestMethod(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Method::Get
    1 => Method::Head
    2 => Method::Post
    3 => Method::Put
    4 => Method::Delete
    5 => Method::Connect
    6 => Method::Options
    7 => Method::Trace
    8 => Method::Patch
    9 => {
      ignore(@ffi.load32(return_area + 8))
      let result = @ffi.ptr2str(@ffi.load32(return_area + 4))
      Method::Other(result)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Returns the path with query parameters from the request, as a string.
pub fn IncomingRequest::path_with_query(self : IncomingRequest) -> String? {
  let IncomingRequest(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodIncomingRequestPathWithQuery(handle, return_area)
  let lifted : String? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      ignore(@ffi.load32(return_area + 8))
      let result = @ffi.ptr2str(@ffi.load32(return_area + 4))
      Option::Some(result)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Returns the protocol scheme from the request.
pub fn IncomingRequest::scheme(self : IncomingRequest) -> Scheme? {
  let IncomingRequest(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodIncomingRequestScheme(handle, return_area)
  let lifted8 : Scheme? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 => Scheme::Http
        1 => Scheme::Https
        2 => {
          ignore(@ffi.load32(return_area + 12))
          let result = @ffi.ptr2str(@ffi.load32(return_area + 8))
          Scheme::Other(result)
        }
        _ => panic()
      }
      Option::Some(lifted)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted8
}

///| Returns the authority of the Request's target URI, if present.
pub fn IncomingRequest::authority(self : IncomingRequest) -> String? {
  let IncomingRequest(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodIncomingRequestAuthority(handle, return_area)
  let lifted : String? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      ignore(@ffi.load32(return_area + 8))
      let result = @ffi.ptr2str(@ffi.load32(return_area + 4))
      Option::Some(result)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Get the `headers` associated with the request.
///
/// The returned `headers` resource is immutable: `set`, `append`, and
/// `delete` operations will fail with `header-error.immutable`.
///
/// The `headers` returned are a child resource: it must be dropped before
/// the parent `incoming-request` is dropped. Dropping this
/// `incoming-request` before all children are dropped will trap.
pub fn IncomingRequest::headers(self : IncomingRequest) -> Fields {
  let IncomingRequest(handle) = self
  let result : Int = wasmImportMethodIncomingRequestHeaders(handle)
  return Fields::Fields(result)
}

///| Gives the `incoming-body` associated with this request. Will only
/// return success at most once, and subsequent calls will return error.
pub fn IncomingRequest::consume(
  self : IncomingRequest
) -> Result[IncomingBody, Unit] {
  let IncomingRequest(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodIncomingRequestConsume(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(IncomingBody::IncomingBody(@ffi.load32(return_area + 4)))
    1 => Result::Err(())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Construct a new `outgoing-request` with a default `method` of `GET`, and
/// `none` values for `path-with-query`, `scheme`, and `authority`.
///
/// * `headers` is the HTTP Headers for the Request.
///
/// It is possible to construct, or manipulate with the accessor functions
/// below, an `outgoing-request` with an invalid combination of `scheme`
/// and `authority`, or `headers` which are not permitted to be sent.
/// It is the obligation of the `outgoing-handler.handle` implementation
/// to reject invalid constructions of `outgoing-request`.
pub fn OutgoingRequest::outgoing_request(headers : Fields) -> OutgoingRequest {
  let Fields(handle) = headers
  let result : Int = wasmImportConstructorOutgoingRequest(handle)
  return OutgoingRequest::OutgoingRequest(result)
}

///| Returns the resource corresponding to the outgoing Body for this
/// Request.
///
/// Returns success on the first call: the `outgoing-body` resource for
/// this `outgoing-request` can be retrieved at most once. Subsequent
/// calls will return error.
pub fn OutgoingRequest::body(
  self : OutgoingRequest
) -> Result[OutgoingBody, Unit] {
  let OutgoingRequest(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodOutgoingRequestBody(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(OutgoingBody::OutgoingBody(@ffi.load32(return_area + 4)))
    1 => Result::Err(())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Get the Method for the Request.
pub fn OutgoingRequest::method_(self : OutgoingRequest) -> Method {
  let OutgoingRequest(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodOutgoingRequestMethod(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Method::Get
    1 => Method::Head
    2 => Method::Post
    3 => Method::Put
    4 => Method::Delete
    5 => Method::Connect
    6 => Method::Options
    7 => Method::Trace
    8 => Method::Patch
    9 => {
      ignore(@ffi.load32(return_area + 8))
      let result = @ffi.ptr2str(@ffi.load32(return_area + 4))
      Method::Other(result)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Set the Method for the Request. Fails if the string present in a
/// `method.other` argument is not a syntactically valid method.
pub fn OutgoingRequest::set_method(
  self : OutgoingRequest,
  method_ : Method
) -> Result[Unit, Unit] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[&@ffi.Any] = []
  let OutgoingRequest(handle) = self
  let (lowered, lowered27, lowered28) = match method_ {
    Get => (0, 0, 0)
    Head => (1, 0, 0)
    Post => (2, 0, 0)
    Put => (3, 0, 0)
    Delete => (4, 0, 0)
    Connect => (5, 0, 0)
    Options => (6, 0, 0)
    Trace => (7, 0, 0)
    Patch => (8, 0, 0)
    Other(payload26) => {
      ignoreList.push(payload26)
      (9, @ffi.str2ptr(payload26), payload26.iter().count())
    }
  }
  let result : Int = wasmImportMethodOutgoingRequestSetMethod(
    handle, lowered, lowered27, lowered28,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted
}

///| Get the combination of the HTTP Path and Query for the Request.
/// When `none`, this represents an empty Path and empty Query.
pub fn OutgoingRequest::path_with_query(self : OutgoingRequest) -> String? {
  let OutgoingRequest(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodOutgoingRequestPathWithQuery(handle, return_area)
  let lifted : String? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      ignore(@ffi.load32(return_area + 8))
      let result = @ffi.ptr2str(@ffi.load32(return_area + 4))
      Option::Some(result)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Set the combination of the HTTP Path and Query for the Request.
/// When `none`, this represents an empty Path and empty Query. Fails is the
/// string given is not a syntactically valid path and query uri component.
pub fn OutgoingRequest::set_path_with_query(
  self : OutgoingRequest,
  path_with_query : String?
) -> Result[Unit, Unit] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[&@ffi.Any] = []
  let OutgoingRequest(handle) = self
  let (lowered, lowered3, lowered4) = match path_with_query {
    None => (0, 0, 0)
    Some(payload2) => {
      ignoreList.push(payload2)
      (1, @ffi.str2ptr(payload2), payload2.iter().count())
    }
  }
  let result : Int = wasmImportMethodOutgoingRequestSetPathWithQuery(
    handle, lowered, lowered3, lowered4,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted
}

///| Get the HTTP Related Scheme for the Request. When `none`, the
/// implementation may choose an appropriate default scheme.
pub fn OutgoingRequest::scheme(self : OutgoingRequest) -> Scheme? {
  let OutgoingRequest(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodOutgoingRequestScheme(handle, return_area)
  let lifted8 : Scheme? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 => Scheme::Http
        1 => Scheme::Https
        2 => {
          ignore(@ffi.load32(return_area + 12))
          let result = @ffi.ptr2str(@ffi.load32(return_area + 8))
          Scheme::Other(result)
        }
        _ => panic()
      }
      Option::Some(lifted)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted8
}

///| Set the HTTP Related Scheme for the Request. When `none`, the
/// implementation may choose an appropriate default scheme. Fails if the
/// string given is not a syntactically valid uri scheme.
pub fn OutgoingRequest::set_scheme(
  self : OutgoingRequest,
  scheme : Scheme?
) -> Result[Unit, Unit] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[&@ffi.Any] = []
  let OutgoingRequest(handle) = self
  let (lowered14, lowered15, lowered16, lowered17) = match scheme {
    None => (0, 0, 0, 0)
    Some(payload2) => {
      let (lowered, lowered12, lowered13) = match payload2 {
        Http => (0, 0, 0)
        Https => (1, 0, 0)
        Other(payload11) => {
          ignoreList.push(payload11)
          (2, @ffi.str2ptr(payload11), payload11.iter().count())
        }
      }
      (1, lowered, lowered12, lowered13)
    }
  }
  let result : Int = wasmImportMethodOutgoingRequestSetScheme(
    handle, lowered14, lowered15, lowered16, lowered17,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted
}

///| Get the authority of the Request's target URI. A value of `none` may be used
/// with Related Schemes which do not require an authority. The HTTP and
/// HTTPS schemes always require an authority.
pub fn OutgoingRequest::authority(self : OutgoingRequest) -> String? {
  let OutgoingRequest(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodOutgoingRequestAuthority(handle, return_area)
  let lifted : String? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      ignore(@ffi.load32(return_area + 8))
      let result = @ffi.ptr2str(@ffi.load32(return_area + 4))
      Option::Some(result)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Set the authority of the Request's target URI. A value of `none` may be used
/// with Related Schemes which do not require an authority. The HTTP and
/// HTTPS schemes always require an authority. Fails if the string given is
/// not a syntactically valid URI authority.
pub fn OutgoingRequest::set_authority(
  self : OutgoingRequest,
  authority : String?
) -> Result[Unit, Unit] {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[&@ffi.Any] = []
  let OutgoingRequest(handle) = self
  let (lowered, lowered3, lowered4) = match authority {
    None => (0, 0, 0)
    Some(payload2) => {
      ignoreList.push(payload2)
      (1, @ffi.str2ptr(payload2), payload2.iter().count())
    }
  }
  let result : Int = wasmImportMethodOutgoingRequestSetAuthority(
    handle, lowered, lowered3, lowered4,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return lifted
}

///| Get the headers associated with the Request.
///
/// The returned `headers` resource is immutable: `set`, `append`, and
/// `delete` operations will fail with `header-error.immutable`.
///
/// This headers resource is a child: it must be dropped before the parent
/// `outgoing-request` is dropped, or its ownership is transferred to
/// another component by e.g. `outgoing-handler.handle`.
pub fn OutgoingRequest::headers(self : OutgoingRequest) -> Fields {
  let OutgoingRequest(handle) = self
  let result : Int = wasmImportMethodOutgoingRequestHeaders(handle)
  return Fields::Fields(result)
}

///| Construct a default `request-options` value.
pub fn RequestOptions::request_options() -> RequestOptions {
  let result : Int = wasmImportConstructorRequestOptions()
  return RequestOptions::RequestOptions(result)
}

///| The timeout for the initial connect to the HTTP Server.
pub fn RequestOptions::connect_timeout(self : RequestOptions) -> UInt64? {
  let RequestOptions(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodRequestOptionsConnectTimeout(handle, return_area)
  let lifted : UInt64? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => Option::Some(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Set the timeout for the initial connect to the HTTP Server. An error
/// return value indicates that this timeout is not supported.
pub fn RequestOptions::set_connect_timeout(
  self : RequestOptions,
  duration : UInt64?
) -> Result[Unit, Unit] {
  let RequestOptions(handle) = self
  let (lowered, lowered3) = match duration {
    None => (0, 0L)
    Some(payload2) => (1, payload2.reinterpret_as_int64())
  }
  let result : Int = wasmImportMethodRequestOptionsSetConnectTimeout(
    handle, lowered, lowered3,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  return lifted
}

///| The timeout for receiving the first byte of the Response body.
pub fn RequestOptions::first_byte_timeout(self : RequestOptions) -> UInt64? {
  let RequestOptions(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodRequestOptionsFirstByteTimeout(handle, return_area)
  let lifted : UInt64? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => Option::Some(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Set the timeout for receiving the first byte of the Response body. An
/// error return value indicates that this timeout is not supported.
pub fn RequestOptions::set_first_byte_timeout(
  self : RequestOptions,
  duration : UInt64?
) -> Result[Unit, Unit] {
  let RequestOptions(handle) = self
  let (lowered, lowered3) = match duration {
    None => (0, 0L)
    Some(payload2) => (1, payload2.reinterpret_as_int64())
  }
  let result : Int = wasmImportMethodRequestOptionsSetFirstByteTimeout(
    handle, lowered, lowered3,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  return lifted
}

///| The timeout for receiving subsequent chunks of bytes in the Response
/// body stream.
pub fn RequestOptions::between_bytes_timeout(self : RequestOptions) -> UInt64? {
  let RequestOptions(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodRequestOptionsBetweenBytesTimeout(handle, return_area)
  let lifted : UInt64? = match @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => Option::Some(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Set the timeout for receiving subsequent chunks of bytes in the Response
/// body stream. An error return value indicates that this timeout is not
/// supported.
pub fn RequestOptions::set_between_bytes_timeout(
  self : RequestOptions,
  duration : UInt64?
) -> Result[Unit, Unit] {
  let RequestOptions(handle) = self
  let (lowered, lowered3) = match duration {
    None => (0, 0L)
    Some(payload2) => (1, payload2.reinterpret_as_int64())
  }
  let result : Int = wasmImportMethodRequestOptionsSetBetweenBytesTimeout(
    handle, lowered, lowered3,
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  return lifted
}

///| Set the value of the `response-outparam` to either send a response,
/// or indicate an error.
///
/// This method consumes the `response-outparam` to ensure that it is
/// called at most once. If it is never called, the implementation
/// will respond with an error.
///
/// The user may provide an `error` to `response` to allow the
/// implementation determine how to respond with an HTTP error response.
pub fn ResponseOutparam::set(
  param : ResponseOutparam,
  response : Result[OutgoingResponse, ErrorCode]
) -> Unit {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[&@ffi.Any] = []
  let ResponseOutparam(handle) = param
  let (
    lowered316,
    lowered317,
    lowered318,
    lowered319,
    lowered320,
    lowered321,
    lowered322,
    lowered323,
  ) = match response {
    Ok(payload) => {
      let OutgoingResponse(handle0) = payload
      (0, handle0, 0, 0L, 0, 0, 0, 0)
    }
    Err(payload3) => {
      let (
        lowered309,
        lowered310,
        lowered311,
        lowered312,
        lowered313,
        lowered314,
        lowered315,
      ) = match payload3 {
        DnsTimeout => (0, 0, 0L, 0, 0, 0, 0)
        DnsError(payload9) => {
          let (lowered, lowered16, lowered17) = match payload9.rcode {
            None => (0, 0, 0)
            Some(payload15) => {
              ignoreList.push(payload15)
              (1, @ffi.str2ptr(payload15), payload15.iter().count())
            }
          }
          let (lowered24, lowered25) = match payload9.info_code {
            None => (0, 0)
            Some(payload23) => (1, payload23.reinterpret_as_int())
          }
          (
            1,
            lowered,
            Int::to_int64(lowered16),
            lowered17,
            lowered24,
            lowered25,
            0,
          )
        }
        DestinationNotFound => (2, 0, 0L, 0, 0, 0, 0)
        DestinationUnavailable => (3, 0, 0L, 0, 0, 0, 0)
        DestinationIpProhibited => (4, 0, 0L, 0, 0, 0, 0)
        DestinationIpUnroutable => (5, 0, 0L, 0, 0, 0, 0)
        ConnectionRefused => (6, 0, 0L, 0, 0, 0, 0)
        ConnectionTerminated => (7, 0, 0L, 0, 0, 0, 0)
        ConnectionTimeout => (8, 0, 0L, 0, 0, 0, 0)
        ConnectionReadTimeout => (9, 0, 0L, 0, 0, 0, 0)
        ConnectionWriteTimeout => (10, 0, 0L, 0, 0, 0, 0)
        ConnectionLimitReached => (11, 0, 0L, 0, 0, 0, 0)
        TlsProtocolError => (12, 0, 0L, 0, 0, 0, 0)
        TlsCertificateError => (13, 0, 0L, 0, 0, 0, 0)
        TlsAlertReceived(payload64) => {
          let (lowered71, lowered72) = match payload64.alert_id {
            None => (0, 0)
            Some(payload70) => (1, payload70.to_int())
          }
          let (lowered79, lowered80, lowered81) = match
            payload64.alert_message {
            None => (0, 0, 0)
            Some(payload78) => {
              ignoreList.push(payload78)
              (1, @ffi.str2ptr(payload78), payload78.iter().count())
            }
          }
          (
            14,
            lowered71,
            Int::to_int64(lowered72),
            lowered79,
            lowered80,
            lowered81,
            0,
          )
        }
        HttpRequestDenied => (15, 0, 0L, 0, 0, 0, 0)
        HttpRequestLengthRequired => (16, 0, 0L, 0, 0, 0, 0)
        HttpRequestBodySize(payload90) => {
          let (lowered97, lowered98) = match payload90 {
            None => (0, 0L)
            Some(payload96) => (1, payload96.reinterpret_as_int64())
          }
          (17, lowered97, lowered98, 0, 0, 0, 0)
        }
        HttpRequestMethodInvalid => (18, 0, 0L, 0, 0, 0, 0)
        HttpRequestUriInvalid => (19, 0, 0L, 0, 0, 0, 0)
        HttpRequestUriTooLong => (20, 0, 0L, 0, 0, 0, 0)
        HttpRequestHeaderSectionSize(payload110) => {
          let (lowered117, lowered118) = match payload110 {
            None => (0, 0)
            Some(payload116) => (1, payload116.reinterpret_as_int())
          }
          (21, lowered117, Int::to_int64(lowered118), 0, 0, 0, 0)
        }
        HttpRequestHeaderSize(payload121) => {
          let (
            lowered145,
            lowered146,
            lowered147,
            lowered148,
            lowered149,
            lowered150,
          ) = match payload121 {
            None => (0, 0, 0, 0, 0, 0)
            Some(payload127) => {
              let (lowered134, lowered135, lowered136) = match
                payload127.field_name {
                None => (0, 0, 0)
                Some(payload133) => {
                  ignoreList.push(payload133)
                  (1, @ffi.str2ptr(payload133), payload133.iter().count())
                }
              }
              let (lowered143, lowered144) = match payload127.field_size {
                None => (0, 0)
                Some(payload142) => (1, payload142.reinterpret_as_int())
              }
              (1, lowered134, lowered135, lowered136, lowered143, lowered144)
            }
          }
          (
            22,
            lowered145,
            Int::to_int64(lowered146),
            lowered147,
            lowered148,
            lowered149,
            lowered150,
          )
        }
        HttpRequestTrailerSectionSize(payload153) => {
          let (lowered160, lowered161) = match payload153 {
            None => (0, 0)
            Some(payload159) => (1, payload159.reinterpret_as_int())
          }
          (23, lowered160, Int::to_int64(lowered161), 0, 0, 0, 0)
        }
        HttpRequestTrailerSize(payload164) => {
          let (lowered171, lowered172, lowered173) = match
            payload164.field_name {
            None => (0, 0, 0)
            Some(payload170) => {
              ignoreList.push(payload170)
              (1, @ffi.str2ptr(payload170), payload170.iter().count())
            }
          }
          let (lowered180, lowered181) = match payload164.field_size {
            None => (0, 0)
            Some(payload179) => (1, payload179.reinterpret_as_int())
          }
          (
            24,
            lowered171,
            Int::to_int64(lowered172),
            lowered173,
            lowered180,
            lowered181,
            0,
          )
        }
        HttpResponseIncomplete => (25, 0, 0L, 0, 0, 0, 0)
        HttpResponseHeaderSectionSize(payload187) => {
          let (lowered194, lowered195) = match payload187 {
            None => (0, 0)
            Some(payload193) => (1, payload193.reinterpret_as_int())
          }
          (26, lowered194, Int::to_int64(lowered195), 0, 0, 0, 0)
        }
        HttpResponseHeaderSize(payload198) => {
          let (lowered205, lowered206, lowered207) = match
            payload198.field_name {
            None => (0, 0, 0)
            Some(payload204) => {
              ignoreList.push(payload204)
              (1, @ffi.str2ptr(payload204), payload204.iter().count())
            }
          }
          let (lowered214, lowered215) = match payload198.field_size {
            None => (0, 0)
            Some(payload213) => (1, payload213.reinterpret_as_int())
          }
          (
            27,
            lowered205,
            Int::to_int64(lowered206),
            lowered207,
            lowered214,
            lowered215,
            0,
          )
        }
        HttpResponseBodySize(payload218) => {
          let (lowered225, lowered226) = match payload218 {
            None => (0, 0L)
            Some(payload224) => (1, payload224.reinterpret_as_int64())
          }
          (28, lowered225, lowered226, 0, 0, 0, 0)
        }
        HttpResponseTrailerSectionSize(payload229) => {
          let (lowered236, lowered237) = match payload229 {
            None => (0, 0)
            Some(payload235) => (1, payload235.reinterpret_as_int())
          }
          (29, lowered236, Int::to_int64(lowered237), 0, 0, 0, 0)
        }
        HttpResponseTrailerSize(payload240) => {
          let (lowered247, lowered248, lowered249) = match
            payload240.field_name {
            None => (0, 0, 0)
            Some(payload246) => {
              ignoreList.push(payload246)
              (1, @ffi.str2ptr(payload246), payload246.iter().count())
            }
          }
          let (lowered256, lowered257) = match payload240.field_size {
            None => (0, 0)
            Some(payload255) => (1, payload255.reinterpret_as_int())
          }
          (
            30,
            lowered247,
            Int::to_int64(lowered248),
            lowered249,
            lowered256,
            lowered257,
            0,
          )
        }
        HttpResponseTransferCoding(payload260) => {
          let (lowered267, lowered268, lowered269) = match payload260 {
            None => (0, 0, 0)
            Some(payload266) => {
              ignoreList.push(payload266)
              (1, @ffi.str2ptr(payload266), payload266.iter().count())
            }
          }
          (31, lowered267, Int::to_int64(lowered268), lowered269, 0, 0, 0)
        }
        HttpResponseContentCoding(payload272) => {
          let (lowered279, lowered280, lowered281) = match payload272 {
            None => (0, 0, 0)
            Some(payload278) => {
              ignoreList.push(payload278)
              (1, @ffi.str2ptr(payload278), payload278.iter().count())
            }
          }
          (32, lowered279, Int::to_int64(lowered280), lowered281, 0, 0, 0)
        }
        HttpResponseTimeout => (33, 0, 0L, 0, 0, 0, 0)
        HttpUpgradeFailed => (34, 0, 0L, 0, 0, 0, 0)
        HttpProtocolError => (35, 0, 0L, 0, 0, 0, 0)
        LoopDetected => (36, 0, 0L, 0, 0, 0, 0)
        ConfigurationError => (37, 0, 0L, 0, 0, 0, 0)
        InternalError(payload299) => {
          let (lowered306, lowered307, lowered308) = match payload299 {
            None => (0, 0, 0)
            Some(payload305) => {
              ignoreList.push(payload305)
              (1, @ffi.str2ptr(payload305), payload305.iter().count())
            }
          }
          (38, lowered306, Int::to_int64(lowered307), lowered308, 0, 0, 0)
        }
      }
      (
        1, lowered309, lowered310, lowered311, lowered312, lowered313, lowered314,
        lowered315,
      )
    }
  }
  wasmImportStaticResponseOutparamSet(
    handle, lowered316, lowered317, lowered318, lowered319, lowered320, lowered321,
    lowered322, lowered323,
  )
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
}

///| Returns the status code from the incoming response.
pub fn IncomingResponse::status(self : IncomingResponse) -> UInt {
  let IncomingResponse(handle) = self
  let result : Int = wasmImportMethodIncomingResponseStatus(handle)
  return result.land(0xFFFF).reinterpret_as_uint()
}

///| Returns the headers from the incoming response.
///
/// The returned `headers` resource is immutable: `set`, `append`, and
/// `delete` operations will fail with `header-error.immutable`.
///
/// This headers resource is a child: it must be dropped before the parent
/// `incoming-response` is dropped.
pub fn IncomingResponse::headers(self : IncomingResponse) -> Fields {
  let IncomingResponse(handle) = self
  let result : Int = wasmImportMethodIncomingResponseHeaders(handle)
  return Fields::Fields(result)
}

///| Returns the incoming body. May be called at most once. Returns error
/// if called additional times.
pub fn IncomingResponse::consume(
  self : IncomingResponse
) -> Result[IncomingBody, Unit] {
  let IncomingResponse(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodIncomingResponseConsume(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(IncomingBody::IncomingBody(@ffi.load32(return_area + 4)))
    1 => Result::Err(())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Returns the contents of the body, as a stream of bytes.
///
/// Returns success on first call: the stream representing the contents
/// can be retrieved at most once. Subsequent calls will return error.
///
/// The returned `input-stream` resource is a child: it must be dropped
/// before the parent `incoming-body` is dropped, or consumed by
/// `incoming-body.finish`.
///
/// This invariant ensures that the implementation can determine whether
/// the user is consuming the contents of the body, waiting on the
/// `future-trailers` to be ready, or neither. This allows for network
/// backpressure is to be applied when the user is consuming the body,
/// and for that backpressure to not inhibit delivery of the trailers if
/// the user does not read the entire body.
pub fn IncomingBody::stream(
  self : IncomingBody
) -> Result[@streams.InputStream, Unit] {
  let IncomingBody(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodIncomingBodyStream(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        @streams.InputStream::InputStream(@ffi.load32(return_area + 4)),
      )
    1 => Result::Err(())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Takes ownership of `incoming-body`, and returns a `future-trailers`.
/// This function will trap if the `input-stream` child is still alive.
pub fn IncomingBody::finish(this : IncomingBody) -> FutureTrailers {
  let IncomingBody(handle) = this
  let result : Int = wasmImportStaticIncomingBodyFinish(handle)
  return FutureTrailers::FutureTrailers(result)
}

///| Returns a pollable which becomes ready when either the trailers have
/// been received, or an error has occurred. When this pollable is ready,
/// the `get` method will return `some`.
pub fn FutureTrailers::subscribe(self : FutureTrailers) -> @poll.Pollable {
  let FutureTrailers(handle) = self
  let result : Int = wasmImportMethodFutureTrailersSubscribe(handle)
  return @poll.Pollable::Pollable(result)
}

///| Returns the contents of the trailers, or an error which occurred,
/// once the future is ready.
///
/// The outer `option` represents future readiness. Users can wait on this
/// `option` to become `some` using the `subscribe` method.
///
/// The outer `result` is used to retrieve the trailers or error at most
/// once. It will be success on the first call in which the outer option
/// is `some`, and error on subsequent calls.
///
/// The inner `result` represents that either the HTTP Request or Response
/// body, as well as any trailers, were received successfully, or that an
/// error occurred receiving them. The optional `trailers` indicates whether
/// or not trailers were present in the body.
///
/// When some `trailers` are returned by this method, the `trailers`
/// resource is immutable, and a child. Use of the `set`, `append`, or
/// `delete` methods will return an error, and the resource must be
/// dropped before the parent `future-trailers` is dropped.
pub fn FutureTrailers::get(
  self : FutureTrailers
) -> Result[Result[Fields?, ErrorCode], Unit]? {
  let FutureTrailers(handle) = self
  let return_area = @ffi.malloc(56)
  wasmImportMethodFutureTrailersGet(handle, return_area)
  let lifted213 : Result[Result[Fields?, ErrorCode], Unit]? = match
    @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let lifted212 = match @ffi.load8_u(return_area + 8) {
        0 => {
          let lifted209 = match @ffi.load8_u(return_area + 16) {
            0 => {
              let lifted : Fields? = match @ffi.load8_u(return_area + 24) {
                0 => Option::None
                1 => Option::Some(Fields::Fields(@ffi.load32(return_area + 28)))
                _ => panic()
              }
              Result::Ok(lifted)
            }
            1 => {
              let lifted208 = match @ffi.load8_u(return_area + 24) {
                0 => ErrorCode::DnsTimeout
                1 => {
                  let lifted20 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result = @ffi.ptr2str(@ffi.load32(return_area + 36))
                      Option::Some(result)
                    }
                    _ => panic()
                  }
                  let lifted25 : UInt? = match @ffi.load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load16_u(return_area + 46)
                        .land(0xFFFF)
                        .reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::DnsError(DnsErrorPayload::{
                    rcode: lifted20,
                    info_code: lifted25,
                  })
                }
                2 => ErrorCode::DestinationNotFound
                3 => ErrorCode::DestinationUnavailable
                4 => ErrorCode::DestinationIpProhibited
                5 => ErrorCode::DestinationIpUnroutable
                6 => ErrorCode::ConnectionRefused
                7 => ErrorCode::ConnectionTerminated
                8 => ErrorCode::ConnectionTimeout
                9 => ErrorCode::ConnectionReadTimeout
                10 => ErrorCode::ConnectionWriteTimeout
                11 => ErrorCode::ConnectionLimitReached
                12 => ErrorCode::TlsProtocolError
                13 => ErrorCode::TlsCertificateError
                14 => {
                  let lifted56 : Byte? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => Option::Some(@ffi.load8_u(return_area + 33).to_byte())
                    _ => panic()
                  }
                  let lifted62 : String? = match
                    @ffi.load8_u(return_area + 36) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 44))
                      let result61 = @ffi.ptr2str(@ffi.load32(return_area + 40))
                      Option::Some(result61)
                    }
                    _ => panic()
                  }
                  ErrorCode::TlsAlertReceived(TlsAlertReceivedPayload::{
                    alert_id: lifted56,
                    alert_message: lifted62,
                  })
                }
                15 => ErrorCode::HttpRequestDenied
                16 => ErrorCode::HttpRequestLengthRequired
                17 => {
                  let lifted73 : UInt64? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load64(return_area + 40).reinterpret_as_uint64(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestBodySize(lifted73)
                }
                18 => ErrorCode::HttpRequestMethodInvalid
                19 => ErrorCode::HttpRequestUriInvalid
                20 => ErrorCode::HttpRequestUriTooLong
                21 => {
                  let lifted86 : UInt? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestHeaderSectionSize(lifted86)
                }
                22 => {
                  let lifted104 : FieldSizePayload? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let lifted98 : String? = match
                        @ffi.load8_u(return_area + 36) {
                        0 => Option::None
                        1 => {
                          ignore(@ffi.load32(return_area + 44))
                          let result97 = @ffi.ptr2str(
                            @ffi.load32(return_area + 40),
                          )
                          Option::Some(result97)
                        }
                        _ => panic()
                      }
                      let lifted103 : UInt? = match
                        @ffi.load8_u(return_area + 48) {
                        0 => Option::None
                        1 =>
                          Option::Some(
                            @ffi.load32(return_area + 52).reinterpret_as_uint(),
                          )
                        _ => panic()
                      }
                      Option::Some(FieldSizePayload::{
                        field_name: lifted98,
                        field_size: lifted103,
                      })
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpRequestHeaderSize(lifted104)
                }
                23 => {
                  let lifted111 : UInt? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestTrailerSectionSize(lifted111)
                }
                24 => {
                  let lifted119 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result118 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result118)
                    }
                    _ => panic()
                  }
                  let lifted124 : UInt? = match @ffi.load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestTrailerSize(FieldSizePayload::{
                    field_name: lifted119,
                    field_size: lifted124,
                  })
                }
                25 => ErrorCode::HttpResponseIncomplete
                26 => {
                  let lifted133 : UInt? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseHeaderSectionSize(lifted133)
                }
                27 => {
                  let lifted141 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result140 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result140)
                    }
                    _ => panic()
                  }
                  let lifted146 : UInt? = match @ffi.load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseHeaderSize(FieldSizePayload::{
                    field_name: lifted141,
                    field_size: lifted146,
                  })
                }
                28 => {
                  let lifted153 : UInt64? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load64(return_area + 40).reinterpret_as_uint64(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseBodySize(lifted153)
                }
                29 => {
                  let lifted160 : UInt? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTrailerSectionSize(lifted160)
                }
                30 => {
                  let lifted168 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result167 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result167)
                    }
                    _ => panic()
                  }
                  let lifted173 : UInt? = match @ffi.load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTrailerSize(FieldSizePayload::{
                    field_name: lifted168,
                    field_size: lifted173,
                  })
                }
                31 => {
                  let lifted181 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result180 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result180)
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTransferCoding(lifted181)
                }
                32 => {
                  let lifted189 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result188 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result188)
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpResponseContentCoding(lifted189)
                }
                33 => ErrorCode::HttpResponseTimeout
                34 => ErrorCode::HttpUpgradeFailed
                35 => ErrorCode::HttpProtocolError
                36 => ErrorCode::LoopDetected
                37 => ErrorCode::ConfigurationError
                38 => {
                  let lifted207 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result206 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result206)
                    }
                    _ => panic()
                  }
                  ErrorCode::InternalError(lifted207)
                }
                _ => panic()
              }
              Result::Err(lifted208)
            }
            _ => panic()
          }
          Result::Ok(lifted209)
        }
        1 => Result::Err(())
        _ => panic()
      }
      Option::Some(lifted212)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted213
}

///| Construct an `outgoing-response`, with a default `status-code` of `200`.
/// If a different `status-code` is needed, it must be set via the
/// `set-status-code` method.
///
/// * `headers` is the HTTP Headers for the Response.
pub fn OutgoingResponse::outgoing_response(
  headers : Fields
) -> OutgoingResponse {
  let Fields(handle) = headers
  let result : Int = wasmImportConstructorOutgoingResponse(handle)
  return OutgoingResponse::OutgoingResponse(result)
}

///| Get the HTTP Status Code for the Response.
pub fn OutgoingResponse::status_code(self : OutgoingResponse) -> UInt {
  let OutgoingResponse(handle) = self
  let result : Int = wasmImportMethodOutgoingResponseStatusCode(handle)
  return result.land(0xFFFF).reinterpret_as_uint()
}

///| Set the HTTP Status Code for the Response. Fails if the status-code
/// given is not a valid http status code.
pub fn OutgoingResponse::set_status_code(
  self : OutgoingResponse,
  status_code : UInt
) -> Result[Unit, Unit] {
  let OutgoingResponse(handle) = self
  let result : Int = wasmImportMethodOutgoingResponseSetStatusCode(
    handle,
    status_code.reinterpret_as_int(),
  )
  let lifted = match result {
    0 => Result::Ok(())
    1 => Result::Err(())
    _ => panic()
  }
  return lifted
}

///| Get the headers associated with the Request.
///
/// The returned `headers` resource is immutable: `set`, `append`, and
/// `delete` operations will fail with `header-error.immutable`.
///
/// This headers resource is a child: it must be dropped before the parent
/// `outgoing-request` is dropped, or its ownership is transferred to
/// another component by e.g. `outgoing-handler.handle`.
pub fn OutgoingResponse::headers(self : OutgoingResponse) -> Fields {
  let OutgoingResponse(handle) = self
  let result : Int = wasmImportMethodOutgoingResponseHeaders(handle)
  return Fields::Fields(result)
}

///| Returns the resource corresponding to the outgoing Body for this Response.
///
/// Returns success on the first call: the `outgoing-body` resource for
/// this `outgoing-response` can be retrieved at most once. Subsequent
/// calls will return error.
pub fn OutgoingResponse::body(
  self : OutgoingResponse
) -> Result[OutgoingBody, Unit] {
  let OutgoingResponse(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodOutgoingResponseBody(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(OutgoingBody::OutgoingBody(@ffi.load32(return_area + 4)))
    1 => Result::Err(())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Returns a stream for writing the body contents.
///
/// The returned `output-stream` is a child resource: it must be dropped
/// before the parent `outgoing-body` resource is dropped (or finished),
/// otherwise the `outgoing-body` drop or `finish` will trap.
///
/// Returns success on the first call: the `output-stream` resource for
/// this `outgoing-body` may be retrieved at most once. Subsequent calls
/// will return error.
pub fn OutgoingBody::write(
  self : OutgoingBody
) -> Result[@streams.OutputStream, Unit] {
  let OutgoingBody(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodOutgoingBodyWrite(handle, return_area)
  let lifted = match @ffi.load8_u(return_area + 0) {
    0 =>
      Result::Ok(
        @streams.OutputStream::OutputStream(@ffi.load32(return_area + 4)),
      )
    1 => Result::Err(())
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted
}

///| Finalize an outgoing body, optionally providing trailers. This must be
/// called to signal that the response is complete. If the `outgoing-body`
/// is dropped without calling `outgoing-body.finalize`, the implementation
/// should treat the body as corrupted.
///
/// Fails if the body's `outgoing-request` or `outgoing-response` was
/// constructed with a Content-Length header, and the contents written
/// to the body (via `write`) does not match the value given in the
/// Content-Length.
pub fn OutgoingBody::finish(
  this : OutgoingBody,
  trailers : Fields?
) -> Result[Unit, ErrorCode] {
  let OutgoingBody(handle) = this
  let (lowered, lowered4) = match trailers {
    None => (0, 0)
    Some(payload2) => {
      let Fields(handle3) = payload2
      (1, handle3)
    }
  }
  let return_area = @ffi.malloc(40)
  wasmImportStaticOutgoingBodyFinish(handle, lowered, lowered4, return_area)
  let lifted205 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted204 = match @ffi.load8_u(return_area + 8) {
        0 => ErrorCode::DnsTimeout
        1 => {
          let lifted : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result)
            }
            _ => panic()
          }
          let lifted21 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(
                @ffi.load16_u(return_area + 30)
                .land(0xFFFF)
                .reinterpret_as_uint(),
              )
            _ => panic()
          }
          ErrorCode::DnsError(DnsErrorPayload::{
            rcode: lifted,
            info_code: lifted21,
          })
        }
        2 => ErrorCode::DestinationNotFound
        3 => ErrorCode::DestinationUnavailable
        4 => ErrorCode::DestinationIpProhibited
        5 => ErrorCode::DestinationIpUnroutable
        6 => ErrorCode::ConnectionRefused
        7 => ErrorCode::ConnectionTerminated
        8 => ErrorCode::ConnectionTimeout
        9 => ErrorCode::ConnectionReadTimeout
        10 => ErrorCode::ConnectionWriteTimeout
        11 => ErrorCode::ConnectionLimitReached
        12 => ErrorCode::TlsProtocolError
        13 => ErrorCode::TlsCertificateError
        14 => {
          let lifted52 : Byte? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => Option::Some(@ffi.load8_u(return_area + 17).to_byte())
            _ => panic()
          }
          let lifted58 : String? = match @ffi.load8_u(return_area + 20) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 28))
              let result57 = @ffi.ptr2str(@ffi.load32(return_area + 24))
              Option::Some(result57)
            }
            _ => panic()
          }
          ErrorCode::TlsAlertReceived(TlsAlertReceivedPayload::{
            alert_id: lifted52,
            alert_message: lifted58,
          })
        }
        15 => ErrorCode::HttpRequestDenied
        16 => ErrorCode::HttpRequestLengthRequired
        17 => {
          let lifted69 : UInt64? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                @ffi.load64(return_area + 24).reinterpret_as_uint64(),
              )
            _ => panic()
          }
          ErrorCode::HttpRequestBodySize(lifted69)
        }
        18 => ErrorCode::HttpRequestMethodInvalid
        19 => ErrorCode::HttpRequestUriInvalid
        20 => ErrorCode::HttpRequestUriTooLong
        21 => {
          let lifted82 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpRequestHeaderSectionSize(lifted82)
        }
        22 => {
          let lifted100 : FieldSizePayload? = match
            @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              let lifted94 : String? = match @ffi.load8_u(return_area + 20) {
                0 => Option::None
                1 => {
                  ignore(@ffi.load32(return_area + 28))
                  let result93 = @ffi.ptr2str(@ffi.load32(return_area + 24))
                  Option::Some(result93)
                }
                _ => panic()
              }
              let lifted99 : UInt? = match @ffi.load8_u(return_area + 32) {
                0 => Option::None
                1 =>
                  Option::Some(
                    @ffi.load32(return_area + 36).reinterpret_as_uint(),
                  )
                _ => panic()
              }
              Option::Some(FieldSizePayload::{
                field_name: lifted94,
                field_size: lifted99,
              })
            }
            _ => panic()
          }
          ErrorCode::HttpRequestHeaderSize(lifted100)
        }
        23 => {
          let lifted107 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpRequestTrailerSectionSize(lifted107)
        }
        24 => {
          let lifted115 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result114 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result114)
            }
            _ => panic()
          }
          let lifted120 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 32).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpRequestTrailerSize(FieldSizePayload::{
            field_name: lifted115,
            field_size: lifted120,
          })
        }
        25 => ErrorCode::HttpResponseIncomplete
        26 => {
          let lifted129 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpResponseHeaderSectionSize(lifted129)
        }
        27 => {
          let lifted137 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result136 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result136)
            }
            _ => panic()
          }
          let lifted142 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 32).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpResponseHeaderSize(FieldSizePayload::{
            field_name: lifted137,
            field_size: lifted142,
          })
        }
        28 => {
          let lifted149 : UInt64? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(
                @ffi.load64(return_area + 24).reinterpret_as_uint64(),
              )
            _ => panic()
          }
          ErrorCode::HttpResponseBodySize(lifted149)
        }
        29 => {
          let lifted156 : UInt? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 20).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpResponseTrailerSectionSize(lifted156)
        }
        30 => {
          let lifted164 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result163 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result163)
            }
            _ => panic()
          }
          let lifted169 : UInt? = match @ffi.load8_u(return_area + 28) {
            0 => Option::None
            1 =>
              Option::Some(@ffi.load32(return_area + 32).reinterpret_as_uint())
            _ => panic()
          }
          ErrorCode::HttpResponseTrailerSize(FieldSizePayload::{
            field_name: lifted164,
            field_size: lifted169,
          })
        }
        31 => {
          let lifted177 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result176 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result176)
            }
            _ => panic()
          }
          ErrorCode::HttpResponseTransferCoding(lifted177)
        }
        32 => {
          let lifted185 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result184 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result184)
            }
            _ => panic()
          }
          ErrorCode::HttpResponseContentCoding(lifted185)
        }
        33 => ErrorCode::HttpResponseTimeout
        34 => ErrorCode::HttpUpgradeFailed
        35 => ErrorCode::HttpProtocolError
        36 => ErrorCode::LoopDetected
        37 => ErrorCode::ConfigurationError
        38 => {
          let lifted203 : String? = match @ffi.load8_u(return_area + 16) {
            0 => Option::None
            1 => {
              ignore(@ffi.load32(return_area + 24))
              let result202 = @ffi.ptr2str(@ffi.load32(return_area + 20))
              Option::Some(result202)
            }
            _ => panic()
          }
          ErrorCode::InternalError(lifted203)
        }
        _ => panic()
      }
      Result::Err(lifted204)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted205
}

///| Returns a pollable which becomes ready when either the Response has
/// been received, or an error has occurred. When this pollable is ready,
/// the `get` method will return `some`.
pub fn FutureIncomingResponse::subscribe(
  self : FutureIncomingResponse
) -> @poll.Pollable {
  let FutureIncomingResponse(handle) = self
  let result : Int = wasmImportMethodFutureIncomingResponseSubscribe(handle)
  return @poll.Pollable::Pollable(result)
}

///| Returns the incoming HTTP Response, or an error, once one is ready.
///
/// The outer `option` represents future readiness. Users can wait on this
/// `option` to become `some` using the `subscribe` method.
///
/// The outer `result` is used to retrieve the response or error at most
/// once. It will be success on the first call in which the outer option
/// is `some`, and error on subsequent calls.
///
/// The inner `result` represents that either the incoming HTTP Response
/// status and headers have received successfully, or that an error
/// occurred. Errors may also occur while consuming the response body,
/// but those will be reported by the `incoming-body` and its
/// `output-stream` child.
pub fn FutureIncomingResponse::get(
  self : FutureIncomingResponse
) -> Result[Result[IncomingResponse, ErrorCode], Unit]? {
  let FutureIncomingResponse(handle) = self
  let return_area = @ffi.malloc(56)
  wasmImportMethodFutureIncomingResponseGet(handle, return_area)
  let lifted208 : Result[Result[IncomingResponse, ErrorCode], Unit]? = match
    @ffi.load8_u(return_area + 0) {
    0 => Option::None
    1 => {
      let lifted207 = match @ffi.load8_u(return_area + 8) {
        0 => {
          let lifted204 = match @ffi.load8_u(return_area + 16) {
            0 =>
              Result::Ok(
                IncomingResponse::IncomingResponse(
                  @ffi.load32(return_area + 24),
                ),
              )
            1 => {
              let lifted203 = match @ffi.load8_u(return_area + 24) {
                0 => ErrorCode::DnsTimeout
                1 => {
                  let lifted : String? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result = @ffi.ptr2str(@ffi.load32(return_area + 36))
                      Option::Some(result)
                    }
                    _ => panic()
                  }
                  let lifted20 : UInt? = match @ffi.load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load16_u(return_area + 46)
                        .land(0xFFFF)
                        .reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::DnsError(DnsErrorPayload::{
                    rcode: lifted,
                    info_code: lifted20,
                  })
                }
                2 => ErrorCode::DestinationNotFound
                3 => ErrorCode::DestinationUnavailable
                4 => ErrorCode::DestinationIpProhibited
                5 => ErrorCode::DestinationIpUnroutable
                6 => ErrorCode::ConnectionRefused
                7 => ErrorCode::ConnectionTerminated
                8 => ErrorCode::ConnectionTimeout
                9 => ErrorCode::ConnectionReadTimeout
                10 => ErrorCode::ConnectionWriteTimeout
                11 => ErrorCode::ConnectionLimitReached
                12 => ErrorCode::TlsProtocolError
                13 => ErrorCode::TlsCertificateError
                14 => {
                  let lifted51 : Byte? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => Option::Some(@ffi.load8_u(return_area + 33).to_byte())
                    _ => panic()
                  }
                  let lifted57 : String? = match
                    @ffi.load8_u(return_area + 36) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 44))
                      let result56 = @ffi.ptr2str(@ffi.load32(return_area + 40))
                      Option::Some(result56)
                    }
                    _ => panic()
                  }
                  ErrorCode::TlsAlertReceived(TlsAlertReceivedPayload::{
                    alert_id: lifted51,
                    alert_message: lifted57,
                  })
                }
                15 => ErrorCode::HttpRequestDenied
                16 => ErrorCode::HttpRequestLengthRequired
                17 => {
                  let lifted68 : UInt64? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load64(return_area + 40).reinterpret_as_uint64(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestBodySize(lifted68)
                }
                18 => ErrorCode::HttpRequestMethodInvalid
                19 => ErrorCode::HttpRequestUriInvalid
                20 => ErrorCode::HttpRequestUriTooLong
                21 => {
                  let lifted81 : UInt? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestHeaderSectionSize(lifted81)
                }
                22 => {
                  let lifted99 : FieldSizePayload? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      let lifted93 : String? = match
                        @ffi.load8_u(return_area + 36) {
                        0 => Option::None
                        1 => {
                          ignore(@ffi.load32(return_area + 44))
                          let result92 = @ffi.ptr2str(
                            @ffi.load32(return_area + 40),
                          )
                          Option::Some(result92)
                        }
                        _ => panic()
                      }
                      let lifted98 : UInt? = match
                        @ffi.load8_u(return_area + 48) {
                        0 => Option::None
                        1 =>
                          Option::Some(
                            @ffi.load32(return_area + 52).reinterpret_as_uint(),
                          )
                        _ => panic()
                      }
                      Option::Some(FieldSizePayload::{
                        field_name: lifted93,
                        field_size: lifted98,
                      })
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpRequestHeaderSize(lifted99)
                }
                23 => {
                  let lifted106 : UInt? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestTrailerSectionSize(lifted106)
                }
                24 => {
                  let lifted114 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result113 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result113)
                    }
                    _ => panic()
                  }
                  let lifted119 : UInt? = match @ffi.load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpRequestTrailerSize(FieldSizePayload::{
                    field_name: lifted114,
                    field_size: lifted119,
                  })
                }
                25 => ErrorCode::HttpResponseIncomplete
                26 => {
                  let lifted128 : UInt? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseHeaderSectionSize(lifted128)
                }
                27 => {
                  let lifted136 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result135 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result135)
                    }
                    _ => panic()
                  }
                  let lifted141 : UInt? = match @ffi.load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseHeaderSize(FieldSizePayload::{
                    field_name: lifted136,
                    field_size: lifted141,
                  })
                }
                28 => {
                  let lifted148 : UInt64? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load64(return_area + 40).reinterpret_as_uint64(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseBodySize(lifted148)
                }
                29 => {
                  let lifted155 : UInt? = match @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 36).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTrailerSectionSize(lifted155)
                }
                30 => {
                  let lifted163 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result162 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result162)
                    }
                    _ => panic()
                  }
                  let lifted168 : UInt? = match @ffi.load8_u(return_area + 44) {
                    0 => Option::None
                    1 =>
                      Option::Some(
                        @ffi.load32(return_area + 48).reinterpret_as_uint(),
                      )
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTrailerSize(FieldSizePayload::{
                    field_name: lifted163,
                    field_size: lifted168,
                  })
                }
                31 => {
                  let lifted176 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result175 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result175)
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpResponseTransferCoding(lifted176)
                }
                32 => {
                  let lifted184 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result183 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result183)
                    }
                    _ => panic()
                  }
                  ErrorCode::HttpResponseContentCoding(lifted184)
                }
                33 => ErrorCode::HttpResponseTimeout
                34 => ErrorCode::HttpUpgradeFailed
                35 => ErrorCode::HttpProtocolError
                36 => ErrorCode::LoopDetected
                37 => ErrorCode::ConfigurationError
                38 => {
                  let lifted202 : String? = match
                    @ffi.load8_u(return_area + 32) {
                    0 => Option::None
                    1 => {
                      ignore(@ffi.load32(return_area + 40))
                      let result201 = @ffi.ptr2str(
                        @ffi.load32(return_area + 36),
                      )
                      Option::Some(result201)
                    }
                    _ => panic()
                  }
                  ErrorCode::InternalError(lifted202)
                }
                _ => panic()
              }
              Result::Err(lifted203)
            }
            _ => panic()
          }
          Result::Ok(lifted204)
        }
        1 => Result::Err(())
        _ => panic()
      }
      Option::Some(lifted207)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted208
}


================================================
File 93: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/io/error/ffi.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!

///|
fn wasmImportResourceDropError_(resource : Int) = "wasi:io/error@0.2.1" "[resource-drop]error"

///|
fn wasmImportMethodErrorToDebugString(p0 : Int, p1 : Int) = "wasi:io/error@0.2.1" "[method]error.to-debug-string"


================================================
File 94: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/io/error/top.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///| A resource which represents some error information.
///
/// The only method provided by this resource is `to-debug-string`,
/// which provides some human-readable information about the error.
///
/// In the `wasi:io` package, this resource is returned through the
/// `wasi:io/streams/stream-error` type.
///
/// To provide more specific error information, other interfaces may
/// offer functions to "downcast" this error into more specific types. For example,
/// errors returned from streams derived from filesystem types can be described using
/// the filesystem's own error-code type. This is done using the function
/// `wasi:filesystem/types/filesystem-error-code`, which takes a `borrow<error>`
/// parameter and returns an `option<wasi:filesystem/types/error-code>`.
///
/// The set of functions which can "downcast" an `error` into a more
/// concrete type is open.
pub(all) type! Error_ Int derive(Show, Eq)

///| Drops a resource handle.
pub fn Error_::drop(self : Error_) -> Unit {
  let Error_(resource) = self
  wasmImportResourceDropError_(resource)
}

///| Returns a string that is suitable to assist humans in debugging
/// this error.
///
/// WARNING: The returned string should not be consumed mechanically!
/// It may change across platforms, hosts, or other implementation
/// details. Parsing this string is a major platform-compatibility
/// hazard.
pub fn Error_::to_debug_string(self : Error_) -> String {
  let Error_(handle) = self
  let return_area = @ffi.malloc(8)
  wasmImportMethodErrorToDebugString(handle, return_area)
  ignore(@ffi.load32(return_area + 4))
  let result = @ffi.ptr2str(@ffi.load32(return_area + 0))
  @ffi.free(return_area)
  return result
}


================================================
File 95: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/io/poll/README.md
================================================
A poll API intended to let users wait for I/O events on multiple handles
at once.

================================================
File 96: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/io/poll/ffi.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!

///|
fn wasmImportResourceDropPollable(resource : Int) = "wasi:io/poll@0.2.1" "[resource-drop]pollable"

///|
fn wasmImportMethodPollableReady(p0 : Int) -> Int = "wasi:io/poll@0.2.1" "[method]pollable.ready"

///|
fn wasmImportMethodPollableBlock(p0 : Int) = "wasi:io/poll@0.2.1" "[method]pollable.block"

///|
fn wasmImportPoll(p0 : Int, p1 : Int, p2 : Int) = "wasi:io/poll@0.2.1" "poll"


================================================
File 97: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/io/poll/top.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///| `pollable` represents a single I/O event which may be ready, or not.
pub(all) type Pollable Int derive(Show, Eq)

///| Drops a resource handle.
pub fn Pollable::drop(self : Pollable) -> Unit {
  let Pollable(resource) = self
  wasmImportResourceDropPollable(resource)
}

///| Return the readiness of a pollable. This function never blocks.
///
/// Returns `true` when the pollable is ready, and `false` otherwise.
pub fn Pollable::ready(self : Pollable) -> Bool {
  let Pollable(handle) = self
  let result : Int = wasmImportMethodPollableReady(handle)
  return result != 0
}

///| `block` returns immediately if the pollable is ready, and otherwise
/// blocks until ready.
///
/// This function is equivalent to calling `poll.poll` on a list
/// containing only this pollable.
pub fn Pollable::block(self : Pollable) -> Unit {
  let Pollable(handle) = self
  wasmImportMethodPollableBlock(handle)
}

///| Poll for completion on a set of pollables.
///
/// This function takes a list of pollables, which identify I/O sources of
/// interest, and waits until one or more of the events is ready for I/O.
///
/// The result `list<u32>` contains one or more indices of handles in the
/// argument list that is ready for I/O.
///
/// This function traps if either:
/// - the list is empty, or:
/// - the list contains more elements than can be indexed with a `u32` value.
///
/// A timeout can be implemented by adding a pollable from the
/// wasi-clocks API to the list.
///
/// This function does not return a `result`; polling in itself does not
/// do any I/O so it doesn't fail. If any of the I/O sources identified by
/// the pollables has an error, it is indicated by marking the source as
/// being ready for I/O.
pub fn poll(in_ : Array[Pollable]) -> FixedArray[UInt] {
  let address = @ffi.malloc(in_.length() * 4)
  for index = 0; index < in_.length(); index = index + 1 {
    let element : Pollable = in_[index]
    let base = address + index * 4
    let Pollable(handle) = element
    @ffi.store32(base + 0, handle)
  }
  let return_area = @ffi.malloc(8)
  wasmImportPoll(address, in_.length(), return_area)
  let result = @ffi.ptr2uint_array(
    @ffi.load32(return_area + 0),
    @ffi.load32(return_area + 4),
  )
  @ffi.free(address)
  @ffi.free(return_area)
  return result
}


================================================
File 98: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/io/streams/README.md
================================================
WASI I/O is an I/O abstraction API which is currently focused on providing
stream types.

In the future, the component model is expected to add built-in stream types;
when it does, they are expected to subsume this API.

================================================
File 99: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/io/streams/ffi.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!

///|
fn wasmImportResourceDropInputStream(resource : Int) = "wasi:io/streams@0.2.1" "[resource-drop]input-stream"

///|
fn wasmImportResourceDropOutputStream(resource : Int) = "wasi:io/streams@0.2.1" "[resource-drop]output-stream"

///|
fn wasmImportMethodInputStreamRead(p0 : Int, p1 : Int64, p2 : Int) = "wasi:io/streams@0.2.1" "[method]input-stream.read"

///|
fn wasmImportMethodInputStreamBlockingRead(p0 : Int, p1 : Int64, p2 : Int) = "wasi:io/streams@0.2.1" "[method]input-stream.blocking-read"

///|
fn wasmImportMethodInputStreamSkip(p0 : Int, p1 : Int64, p2 : Int) = "wasi:io/streams@0.2.1" "[method]input-stream.skip"

///|
fn wasmImportMethodInputStreamBlockingSkip(p0 : Int, p1 : Int64, p2 : Int) = "wasi:io/streams@0.2.1" "[method]input-stream.blocking-skip"

///|
fn wasmImportMethodInputStreamSubscribe(p0 : Int) -> Int = "wasi:io/streams@0.2.1" "[method]input-stream.subscribe"

///|
fn wasmImportMethodOutputStreamCheckWrite(p0 : Int, p1 : Int) = "wasi:io/streams@0.2.1" "[method]output-stream.check-write"

///|
fn wasmImportMethodOutputStreamWrite(p0 : Int, p1 : Int, p2 : Int, p3 : Int) = "wasi:io/streams@0.2.1" "[method]output-stream.write"

///|
fn wasmImportMethodOutputStreamBlockingWriteAndFlush(
  p0 : Int,
  p1 : Int,
  p2 : Int,
  p3 : Int
) = "wasi:io/streams@0.2.1" "[method]output-stream.blocking-write-and-flush"

///|
fn wasmImportMethodOutputStreamFlush(p0 : Int, p1 : Int) = "wasi:io/streams@0.2.1" "[method]output-stream.flush"

///|
fn wasmImportMethodOutputStreamBlockingFlush(p0 : Int, p1 : Int) = "wasi:io/streams@0.2.1" "[method]output-stream.blocking-flush"

///|
fn wasmImportMethodOutputStreamSubscribe(p0 : Int) -> Int = "wasi:io/streams@0.2.1" "[method]output-stream.subscribe"

///|
fn wasmImportMethodOutputStreamWriteZeroes(p0 : Int, p1 : Int64, p2 : Int) = "wasi:io/streams@0.2.1" "[method]output-stream.write-zeroes"

///|
fn wasmImportMethodOutputStreamBlockingWriteZeroesAndFlush(
  p0 : Int,
  p1 : Int64,
  p2 : Int
) = "wasi:io/streams@0.2.1" "[method]output-stream.blocking-write-zeroes-and-flush"

///|
fn wasmImportMethodOutputStreamSplice(p0 : Int, p1 : Int, p2 : Int64, p3 : Int) = "wasi:io/streams@0.2.1" "[method]output-stream.splice"

///|
fn wasmImportMethodOutputStreamBlockingSplice(
  p0 : Int,
  p1 : Int,
  p2 : Int64,
  p3 : Int
) = "wasi:io/streams@0.2.1" "[method]output-stream.blocking-splice"


================================================
File 100: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/io/streams/top.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///| An error for input-stream and output-stream operations.
pub(all) type! StreamError {
  LastOperationFailed(@error.Error_)
  Closed
} derive(Show, Eq)

///| An input bytestream.
///
/// `input-stream`s are *non-blocking* to the extent practical on underlying
/// platforms. I/O operations always return promptly; if fewer bytes are
/// promptly available than requested, they return the number of bytes promptly
/// available, which could even be zero. To wait for data to be available,
/// use the `subscribe` function to obtain a `pollable` which can be polled
/// for using `wasi:io/poll`.
pub(all) type InputStream Int derive(Show, Eq)

///| Drops a resource handle.
pub fn InputStream::drop(self : InputStream) -> Unit {
  let InputStream(resource) = self
  wasmImportResourceDropInputStream(resource)
}

///| An output bytestream.
///
/// `output-stream`s are *non-blocking* to the extent practical on
/// underlying platforms. Except where specified otherwise, I/O operations also
/// always return promptly, after the number of bytes that can be written
/// promptly, which could even be zero. To wait for the stream to be ready to
/// accept data, the `subscribe` function to obtain a `pollable` which can be
/// polled for using `wasi:io/poll`.
///
/// Dropping an `output-stream` while there's still an active write in
/// progress may result in the data being lost. Before dropping the stream,
/// be sure to fully flush your writes.
pub(all) type OutputStream Int derive(Show, Eq)

///| Drops a resource handle.
pub fn OutputStream::drop(self : OutputStream) -> Unit {
  let OutputStream(resource) = self
  wasmImportResourceDropOutputStream(resource)
}

///| Perform a non-blocking read from the stream.
///
/// When the source of a `read` is binary data, the bytes from the source
/// are returned verbatim. When the source of a `read` is known to the
/// implementation to be text, bytes containing the UTF-8 encoding of the
/// text are returned.
///
/// This function returns a list of bytes containing the read data,
/// when successful. The returned list will contain up to `len` bytes;
/// it may return fewer than requested, but not more. The list is
/// empty when no bytes are available for reading at this time. The
/// pollable given by `subscribe` will be ready when more bytes are
/// available.
///
/// This function fails with a `stream-error` when the operation
/// encounters an error, giving `last-operation-failed`, or when the
/// stream is closed, giving `closed`.
///
/// When the caller gives a `len` of 0, it represents a request to
/// read 0 bytes. If the stream is still open, this call should
/// succeed and return an empty list, or otherwise fail with `closed`.
///
/// The `len` parameter is a `u64`, which could represent a list of u8 which
/// is not possible to allocate in wasm32, or not desirable to allocate as
/// as a return value by the callee. The callee may return a list of bytes
/// less than `len` in size while more bytes are available for reading.
pub fn InputStream::read(
  self : InputStream,
  len : UInt64
) -> Result[FixedArray[Byte], StreamError] {
  let InputStream(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodInputStreamRead(
    handle,
    len.reinterpret_as_int64(),
    return_area,
  )
  let lifted6 = match @ffi.load8_u(return_area + 0) {
    0 => {
      let result = @ffi.ptr2bytes(
        @ffi.load32(return_area + 4),
        @ffi.load32(return_area + 8),
      )
      Result::Ok(result)
    }
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 =>
          StreamError::LastOperationFailed(
            @error.Error_::Error_(@ffi.load32(return_area + 8)),
          )
        1 => StreamError::Closed
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted6
}

///| Read bytes from a stream, after blocking until at least one byte can
/// be read. Except for blocking, behavior is identical to `read`.
pub fn InputStream::blocking_read(
  self : InputStream,
  len : UInt64
) -> Result[FixedArray[Byte], StreamError] {
  let InputStream(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodInputStreamBlockingRead(
    handle,
    len.reinterpret_as_int64(),
    return_area,
  )
  let lifted6 = match @ffi.load8_u(return_area + 0) {
    0 => {
      let result = @ffi.ptr2bytes(
        @ffi.load32(return_area + 4),
        @ffi.load32(return_area + 8),
      )
      Result::Ok(result)
    }
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 =>
          StreamError::LastOperationFailed(
            @error.Error_::Error_(@ffi.load32(return_area + 8)),
          )
        1 => StreamError::Closed
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted6
}

///| Skip bytes from a stream. Returns number of bytes skipped.
///
/// Behaves identical to `read`, except instead of returning a list
/// of bytes, returns the number of bytes consumed from the stream.
pub fn InputStream::skip(
  self : InputStream,
  len : UInt64
) -> Result[UInt64, StreamError] {
  let InputStream(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodInputStreamSkip(
    handle,
    len.reinterpret_as_int64(),
    return_area,
  )
  let lifted6 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 8) {
        0 =>
          StreamError::LastOperationFailed(
            @error.Error_::Error_(@ffi.load32(return_area + 12)),
          )
        1 => StreamError::Closed
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted6
}

///| Skip bytes from a stream, after blocking until at least one byte
/// can be skipped. Except for blocking behavior, identical to `skip`.
pub fn InputStream::blocking_skip(
  self : InputStream,
  len : UInt64
) -> Result[UInt64, StreamError] {
  let InputStream(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodInputStreamBlockingSkip(
    handle,
    len.reinterpret_as_int64(),
    return_area,
  )
  let lifted6 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 8) {
        0 =>
          StreamError::LastOperationFailed(
            @error.Error_::Error_(@ffi.load32(return_area + 12)),
          )
        1 => StreamError::Closed
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted6
}

///| Create a `pollable` which will resolve once either the specified stream
/// has bytes available to read or the other end of the stream has been
/// closed.
/// The created `pollable` is a child resource of the `input-stream`.
/// Implementations may trap if the `input-stream` is dropped before
/// all derived `pollable`s created with this function are dropped.
pub fn InputStream::subscribe(self : InputStream) -> @poll.Pollable {
  let InputStream(handle) = self
  let result : Int = wasmImportMethodInputStreamSubscribe(handle)
  return @poll.Pollable::Pollable(result)
}

///| Check readiness for writing. This function never blocks.
///
/// Returns the number of bytes permitted for the next call to `write`,
/// or an error. Calling `write` with more bytes than this function has
/// permitted will trap.
///
/// When this function returns 0 bytes, the `subscribe` pollable will
/// become ready when this function will report at least 1 byte, or an
/// error.
pub fn OutputStream::check_write(
  self : OutputStream
) -> Result[UInt64, StreamError] {
  let OutputStream(handle) = self
  let return_area = @ffi.malloc(16)
  wasmImportMethodOutputStreamCheckWrite(handle, return_area)
  let lifted6 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 8) {
        0 =>
          StreamError::LastOperationFailed(
            @error.Error_::Error_(@ffi.load32(return_area + 12)),
          )
        1 => StreamError::Closed
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted6
}

///| Perform a write. This function never blocks.
///
/// When the destination of a `write` is binary data, the bytes from
/// `contents` are written verbatim. When the destination of a `write` is
/// known to the implementation to be text, the bytes of `contents` are
/// transcoded from UTF-8 into the encoding of the destination and then
/// written.
///
/// Precondition: check-write gave permit of Ok(n) and contents has a
/// length of less than or equal to n. Otherwise, this function will trap.
///
/// returns Err(closed) without writing if the stream has closed since
/// the last call to check-write provided a permit.
pub fn OutputStream::write(
  self : OutputStream,
  contents : FixedArray[Byte]
) -> Result[Unit, StreamError] {
  let OutputStream(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodOutputStreamWrite(
    handle,
    @ffi.bytes2ptr(contents),
    contents.length(),
    return_area,
  )
  let lifted6 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 =>
          StreamError::LastOperationFailed(
            @error.Error_::Error_(@ffi.load32(return_area + 8)),
          )
        1 => StreamError::Closed
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(contents)
  @ffi.free(return_area)
  return lifted6
}

///| Perform a write of up to 4096 bytes, and then flush the stream. Block
/// until all of these operations are complete, or an error occurs.
///
/// This is a convenience wrapper around the use of `check-write`,
/// `subscribe`, `write`, and `flush`, and is implemented with the
/// following pseudo-code:
///
/// ```text
/// let pollable = this.subscribe();
/// while !contents.is_empty() {
/// // Wait for the stream to become writable
/// pollable.block();
/// let Ok(n) = this.check-write(); // eliding error handling
/// let len = min(n, contents.len());
/// let (chunk, rest) = contents.split_at(len);
/// this.write(chunk  );            // eliding error handling
/// contents = rest;
/// }
/// this.flush();
/// // Wait for completion of `flush`
/// pollable.block();
/// // Check for any errors that arose during `flush`
/// let _ = this.check-write();         // eliding error handling
/// ```
pub fn OutputStream::blocking_write_and_flush(
  self : OutputStream,
  contents : FixedArray[Byte]
) -> Result[Unit, StreamError] {
  let OutputStream(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodOutputStreamBlockingWriteAndFlush(
    handle,
    @ffi.bytes2ptr(contents),
    contents.length(),
    return_area,
  )
  let lifted6 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 =>
          StreamError::LastOperationFailed(
            @error.Error_::Error_(@ffi.load32(return_area + 8)),
          )
        1 => StreamError::Closed
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  ignore(contents)
  @ffi.free(return_area)
  return lifted6
}

///| Request to flush buffered output. This function never blocks.
///
/// This tells the output-stream that the caller intends any buffered
/// output to be flushed. the output which is expected to be flushed
/// is all that has been passed to `write` prior to this call.
///
/// Upon calling this function, the `output-stream` will not accept any
/// writes (`check-write` will return `ok(0)`) until the flush has
/// completed. The `subscribe` pollable will become ready when the
/// flush has completed and the stream can accept more writes.
pub fn OutputStream::flush(self : OutputStream) -> Result[Unit, StreamError] {
  let OutputStream(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodOutputStreamFlush(handle, return_area)
  let lifted6 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 =>
          StreamError::LastOperationFailed(
            @error.Error_::Error_(@ffi.load32(return_area + 8)),
          )
        1 => StreamError::Closed
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted6
}

///| Request to flush buffered output, and block until flush completes
/// and stream is ready for writing again.
pub fn OutputStream::blocking_flush(
  self : OutputStream
) -> Result[Unit, StreamError] {
  let OutputStream(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodOutputStreamBlockingFlush(handle, return_area)
  let lifted6 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 =>
          StreamError::LastOperationFailed(
            @error.Error_::Error_(@ffi.load32(return_area + 8)),
          )
        1 => StreamError::Closed
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted6
}

///| Create a `pollable` which will resolve once the output-stream
/// is ready for more writing, or an error has occurred. When this
/// pollable is ready, `check-write` will return `ok(n)` with n>0, or an
/// error.
///
/// If the stream is closed, this pollable is always ready immediately.
///
/// The created `pollable` is a child resource of the `output-stream`.
/// Implementations may trap if the `output-stream` is dropped before
/// all derived `pollable`s created with this function are dropped.
pub fn OutputStream::subscribe(self : OutputStream) -> @poll.Pollable {
  let OutputStream(handle) = self
  let result : Int = wasmImportMethodOutputStreamSubscribe(handle)
  return @poll.Pollable::Pollable(result)
}

///| Write zeroes to a stream.
///
/// This should be used precisely like `write` with the exact same
/// preconditions (must use check-write first), but instead of
/// passing a list of bytes, you simply pass the number of zero-bytes
/// that should be written.
pub fn OutputStream::write_zeroes(
  self : OutputStream,
  len : UInt64
) -> Result[Unit, StreamError] {
  let OutputStream(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodOutputStreamWriteZeroes(
    handle,
    len.reinterpret_as_int64(),
    return_area,
  )
  let lifted6 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 =>
          StreamError::LastOperationFailed(
            @error.Error_::Error_(@ffi.load32(return_area + 8)),
          )
        1 => StreamError::Closed
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted6
}

///| Perform a write of up to 4096 zeroes, and then flush the stream.
/// Block until all of these operations are complete, or an error
/// occurs.
///
/// This is a convenience wrapper around the use of `check-write`,
/// `subscribe`, `write-zeroes`, and `flush`, and is implemented with
/// the following pseudo-code:
///
/// ```text
/// let pollable = this.subscribe();
/// while num_zeroes != 0 {
/// // Wait for the stream to become writable
/// pollable.block();
/// let Ok(n) = this.check-write(); // eliding error handling
/// let len = min(n, num_zeroes);
/// this.write-zeroes(len);         // eliding error handling
/// num_zeroes -= len;
/// }
/// this.flush();
/// // Wait for completion of `flush`
/// pollable.block();
/// // Check for any errors that arose during `flush`
/// let _ = this.check-write();         // eliding error handling
/// ```
pub fn OutputStream::blocking_write_zeroes_and_flush(
  self : OutputStream,
  len : UInt64
) -> Result[Unit, StreamError] {
  let OutputStream(handle) = self
  let return_area = @ffi.malloc(12)
  wasmImportMethodOutputStreamBlockingWriteZeroesAndFlush(
    handle,
    len.reinterpret_as_int64(),
    return_area,
  )
  let lifted6 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 4) {
        0 =>
          StreamError::LastOperationFailed(
            @error.Error_::Error_(@ffi.load32(return_area + 8)),
          )
        1 => StreamError::Closed
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted6
}

///| Read from one stream and write to another.
///
/// The behavior of splice is equivalent to:
/// 1. calling `check-write` on the `output-stream`
/// 2. calling `read` on the `input-stream` with the smaller of the
/// `check-write` permitted length and the `len` provided to `splice`
/// 3. calling `write` on the `output-stream` with that read data.
///
/// Any error reported by the call to `check-write`, `read`, or
/// `write` ends the splice and reports that error.
///
/// This function returns the number of bytes transferred; it may be less
/// than `len`.
pub fn OutputStream::splice(
  self : OutputStream,
  src : InputStream,
  len : UInt64
) -> Result[UInt64, StreamError] {
  let OutputStream(handle) = self
  let InputStream(handle0) = src
  let return_area = @ffi.malloc(16)
  wasmImportMethodOutputStreamSplice(
    handle,
    handle0,
    len.reinterpret_as_int64(),
    return_area,
  )
  let lifted7 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 8) {
        0 =>
          StreamError::LastOperationFailed(
            @error.Error_::Error_(@ffi.load32(return_area + 12)),
          )
        1 => StreamError::Closed
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted7
}

///| Read from one stream and write to another, with blocking.
///
/// This is similar to `splice`, except that it blocks until the
/// `output-stream` is ready for writing, and the `input-stream`
/// is ready for reading, before performing the `splice`.
pub fn OutputStream::blocking_splice(
  self : OutputStream,
  src : InputStream,
  len : UInt64
) -> Result[UInt64, StreamError] {
  let OutputStream(handle) = self
  let InputStream(handle0) = src
  let return_area = @ffi.malloc(16)
  wasmImportMethodOutputStreamBlockingSplice(
    handle,
    handle0,
    len.reinterpret_as_int64(),
    return_area,
  )
  let lifted7 = match @ffi.load8_u(return_area + 0) {
    0 => Result::Ok(@ffi.load64(return_area + 8).reinterpret_as_uint64())
    1 => {
      let lifted = match @ffi.load8_u(return_area + 8) {
        0 =>
          StreamError::LastOperationFailed(
            @error.Error_::Error_(@ffi.load32(return_area + 12)),
          )
        1 => StreamError::Closed
        _ => panic()
      }
      Result::Err(lifted)
    }
    _ => panic()
  }
  @ffi.free(return_area)
  return lifted7
}


================================================
File 101: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/random/random/README.md
================================================
WASI Random is a random data API.

It is intended to be portable at least between Unix-family platforms and
Windows.

================================================
File 102: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/random/random/ffi.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///|
fn wasmImportGetRandomBytes(p0 : Int64, p1 : Int) = "wasi:random/random@0.2.1" "get-random-bytes"

///|
fn wasmImportGetRandomU64() -> Int64 = "wasi:random/random@0.2.1" "get-random-u64"


================================================
File 103: /data/input/moonbit-docs/legacy/examples/wasi-http/interface/wasi/random/random/top.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
///| Return `len` cryptographically-secure random or pseudo-random bytes.
///
/// This function must produce data at least as cryptographically secure and
/// fast as an adequately seeded cryptographically-secure pseudo-random
/// number generator (CSPRNG). It must not block, from the perspective of
/// the calling program, under any circumstances, including on the first
/// request and on requests for numbers of bytes. The returned data must
/// always be unpredictable.
///
/// This function must always return fresh data. Deterministic environments
/// must omit this function, rather than implementing it with deterministic
/// data.
pub fn get_random_bytes(len : UInt64) -> FixedArray[Byte] {
  let return_area = @ffi.malloc(8)
  wasmImportGetRandomBytes(len.reinterpret_as_int64(), return_area)
  let result = @ffi.ptr2bytes(
    @ffi.load32(return_area + 0),
    @ffi.load32(return_area + 4),
  )
  @ffi.free(return_area)
  return result
}

///| Return a cryptographically-secure random or pseudo-random `u64` value.
///
/// This function returns the same type of data as `get-random-bytes`,
/// represented as a `u64`.
pub fn get_random_u64() -> UInt64 {
  let result : Int64 = wasmImportGetRandomU64()
  return result.reinterpret_as_uint64()
}


================================================
File 104: /data/input/moonbit-docs/legacy/examples/wasi-http/world/server/ffi_import.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!


================================================
File 105: /data/input/moonbit-docs/legacy/examples/wasi-http/world/server/import.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!


================================================
File 106: /data/input/moonbit-docs/legacy/examples/wasi-http/world/server/top.mbt
================================================
// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!


================================================
File 107: /data/input/moonbit-docs/legacy/examples/wasm-gc/README.md
================================================
# Illstration of MoonBit wasm gc

## Deps

This example works with the following versions of the environment.

```bash
moon 0.1.0 (dff5fcc 2023-11-05)
moonc 5258d5b95 ~/.moon/bin/moonc
chrome version 119
```

## How to run

### Browser

```bash
moon build --target wasm-gc
python3 -m http.server 8080 # or any thing else to start a server
```

Navigate to http://localhost:8080/index.html after launching the server, moonbit with wasm gc is running in the browser.

### Deno

```bash
moon build --target wasm-gc
deno run --allow-read main.mjs # allow-read is needed to load wasm module from path
```

### Node (version >= 22.0.0)

```bash
moon build --target wasm-gc
node main.mjs
```

================================================
File 108: /data/input/moonbit-docs/legacy/examples/wasm-gc/main/main.mbt
================================================
//  Copyright 2024 International Digital Economy Academy
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

fn main {
  println("hello")
}

================================================
File 109: /data/input/moonbit-docs/moonbit-tour/README-zh.md
================================================
# MoonBit Language Tour

查看该文件的英文版本：[English version](./README.md)

一个用于学习 MoonBit 编程语言的交互式教程。

## 开始

```sh
pnpm install
pnpm build
pnpm preview
```

打开 <http://localhost:3000> 查看 tour 网站。

## 如何添加新的教程

### 添加新的教程

1. 设置开发环境。

   ```sh
   pnpm install
   pnpm dev
   ```

1. 打开 <http://localhost:8080> 查看 tour 网站。

1. 在章节文件夹下创建一个新的文件夹，遵循命名惯例 `lesson<n>_<lesson-name>` (从 1 开始计数)。

1. 在创建的文件夹下编写教程内容（`index.md`），并编写教程代码（`index.mbt`）。

### 添加新的章节

1. 在 `tour` 文件夹下创建一个新的文件夹，遵循命名惯例 `chapter<n>_<chapter-name>`。
1. 按照上述步骤添加新的教程。

## 致谢

该项目深受 [Gleam Language Tour](https://github.com/gleam-lang/language-tour) 启发。


================================================
File 110: /data/input/moonbit-docs/moonbit-tour/README.md
================================================
# MoonBit Language Tour

view the [Chinese version](./README-zh.md) of this file.

An interactive tour to learn the MoonBit programming language.

## Get started

```sh
pnpm install
pnpm build
pnpm preview
```

open <http://localhost:3000> to view the tour.

## How to add new tour

### Add new lesson

1. Setup development environment.

   ```sh
   pnpm install
   pnpm dev
   ```

1. open <http://localhost:8080> to view the tour.

1. Create a new folder under the chapter folder following the naming convention `lesson<n>_<lesson-name>` (count start from 1).

1. Write the lesson content in `index.md` and lesson code in `index.mbt` under the created folder.

### Add new chapter

1. Create a new folder under `tour` following the naming convention `chapter<n>_<chapter-name>`.
1. Add new lessons following the instruction above.

## Credit

This project is highly inspired by [Gleam Language Tour](https://github.com/gleam-lang/language-tour).


================================================
File 111: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson10_loop/index.mbt
================================================
fn main {
  let array = [1, 2, 3]

  println("for loop:")
  for i = 0; i < array.length(); i = i + 1 {
    println("array[\{i}]: \{array[i]}")
  }

  println("\nfunctional for loop:")

  let sum = for i = 1, acc = 0; i <= 10; i = i + 1 {
    let even = i % 2 == 0
    continue i + 1, acc + i
  } else {
    acc
  }
  println(sum)

  println("\nwhile loop:")
  let mut j = 0
  while true {
    println("array[\{j}]: \{array[j]}")
    j = j + 1
    if j < array.length() {
      continue
    } else {
      break
    }
  }
}


================================================
File 112: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson10_loop/index.md
================================================
# Loop

In this example, we use for loops and while loops to iterate over an array.

## For Loop Expression

The for loop is analogous to a C-style for loop:

```
for init; condition; increment {
    // loop body
}
```

The loop initializes the variables in the `init` part before it starts. When the loop starts, it tests the `condition` and executes the loop body if the `condition` is true. After that, it runs the `increment` expression and repeats the process until the condition is false.

In MoonBit, the for loop is more expressive than the C-style for loop. We will
explain it in the following chapters.

## While Loop Expression

The while loop is also similar to the C-style while loop.

It tests the condition before executing the loop body. If the condition is true,
it executes the loop body and repeats the process until the condition is false.

MoonBit also supports both `continue` and `break` statements within the loop.


================================================
File 113: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson11_for_in_loop/index.mbt
================================================
fn main {
  println("for-in loop:")
  let array = [1, 2, 3]
  for element in array {
    println("element: \{element}")
  }

  println("for-in loop with index:")
  for i, element in array {
    println("index: \{i}, element: \{element}")
  }
  
  println("for-in loop for map:")
  let map = { "key1": 1, "key2": 2, "key3": 3 }
  for k, v in map {
    println("key: \{k}, value: \{v}")
  }
}


================================================
File 114: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson11_for_in_loop/index.md
================================================
# For-in loop

It's cumbersome to write a for loop and manually decide the end condition.

If you want to iterate over a collection, you can use the `for .. in ... {}` loop.

In the first for-in loop, we iterate over an array. The loop will bind each
element to the variable `element` in each iteration.

We can also iterate over a map with key-value pairs. The second loop will bind
the key to the first variable (`k`) and the value to the second variable (`v`).

Which collections can be iterated over with a for-in loop? And when does the for-in loop support two variables? The for-in loop functionality actually depends on the API of the collection:

- If the collection provides an `iter()` method to return an `Iter[V]` iterator, then the for-in loop can iterate over it with a single variable.

- If the collection provides an `iter2()` method to return an `Iter2[K,V]` iterator, you can use two variables to iterate over it.

We will explain more details about the iterator in a later chapter.


================================================
File 115: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson12_range/index.mbt
================================================
fn main {
  println("number 1 to 3:")
  for i in 1..<4 {
    println(i)
  }
  
  println("number 1 to 4:")
  for i in 1..=4 {
    println(i)
  }
}





================================================
File 116: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson12_range/index.md
================================================
# Range

You can also use *range* in a for-in loop.

- `start..<end` range is inclusive of the start value and exclusive of the end value. 
- `start..=end` range is inclusive of both the start and end values.



================================================
File 117: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson13_exception/index.mbt
================================================
///|
pub fn safe_add(i : Int, j : Int) -> Int! {
  let signum_i = i & 0x80000000
  let signum_j = j & 0x80000000
  let result = i + j
  if signum_i != signum_j {
    result
  } else {
    let result_signum = result & 0x80000000
    if result_signum != signum_i {
      fail!("overflow")
    } else {
      result
    }
  }
}

///|
fn main {
  let a = try {
    safe_add!(1, 2)
  } catch {
    _ => panic()
  }
  try {
    let result = safe_add!(@int.max_value, @int.max_value)

  } catch {
    Failure(error_message) => println(error_message)
    _ => panic()
  }
  let result = safe_add?(@int.max_value, @int.max_value)

}


================================================
File 118: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson13_exception/index.md
================================================
# Error handling

The `!` syntax is used to signal a potential error raised from a function.

You can use `try { ... } catch { ... }` syntax to handle such occasion, or use
`?` syntax to convert the result to `Result`, a type representing the
computation result.


================================================
File 119: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson14_test/index.mbt
================================================
test {
  assert_eq!(1, 1 + 2)
  assert_false!(1 == 2)
  assert_true!([1,2,3] == [1,2,3])
}

test {
  inspect!(fib(5))
  inspect!([1,2,3,4].map(fib))
}

// Add test name to make it more descriptive.
test "fibonacci" {
  inspect!(fib(5), content="5")
  inspect!(fib(6), content="8")
}

fn fib(n : Int) -> Int {
  if n < 2 {
    n
  } else {
    fib(n - 1) + fib(n - 2)
  }
}



================================================
File 120: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson14_test/index.md
================================================
# Test

MoonBit has built-in testing support. There is no need to import or configure extra packages or tools; just use the test block and write the test code inside.

**Note: this feature is not supported in this tour. You can try it in our [playground](https://try.moonbitlang.com) or in your terminal if the MoonBit toolchain is installed.**

In the first test block, we test some properties using the built-in functions `assert_eq`, `assert_false`, and `assert_true`.
By running `moon test` in the terminal or clicking the test button in your integrated development environment (IDE), the tests will be executed.

## Maintaining Tests

Sometimes it's tedious to maintain the expected value manually. MoonBit also supports built-in *snapshot tests*. Snapshot tests will run the tested code and store the expected result as a snapshot.

In the second test block, we use the `inspect` function to test the result of `fib` and the array's `map` method.
By running `moon test --update` in the terminal or clicking the `Update test` button in your IDE, the result will be automatically inserted as the second argument.

The next time you run the test, it will report any differences between the current result and the stored result. You can update the stored result to the new result by using the `--update` flag.




================================================
File 121: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson1_variable/index.mbt
================================================
fn main {
  let a : Int = 10 
  let b = 20 
  println(a + b)

  let mut  c = 10 
  c = c + 1
  println(c)

  let d = 20 
  // d = d + 1
  println(d)
}

================================================
File 122: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson1_variable/index.md
================================================
# Variables

The `let` keyword is used to define a variable.

The type of the variable can be annotated by using a colon followed by the type.
It is optional; if not provided, the type will be inferred from the value.

Variables are immutable by default in MoonBit. You can add an extra `mut`
keyword to make them mutable at the local level.

If you uncomment the `d = d + 1`, you will get an error.

================================================
File 123: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson2_numbers/index.mbt
================================================
fn main {
  let dec : Int = 1000000
  let dec2 : Int = 1_000_000 
  let hex : Int = 0xFFFF 
  let oct = 0o777
  let bin = 0b1001 

  println(1 + 2)
  println(1 - 2)
  println(1 * 2)
  println(5 / 2)
  println(10 % 3)

  let num1 : Double = 3.14
  let num2 : Float = 3.14
}



================================================
File 124: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson2_numbers/index.md
================================================
# Numbers

Integers and floats are the most common types in MoonBit.
`Int`(32 bit signed integer) can be represented in decimal, hexadecimal, octal, and binary,
and you can use the underscore to separate digits for better readability.
We call these *number literals*.

The `0xFFFF` is a hexadecimal number, `0o777` is an octal number, `0b1010` is a binary number,
and `1_000_000` is a decimal number equivalent to `1000000`.




================================================
File 125: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson3_function/index.mbt
================================================
fn add(a : Int, b : Int) -> Int {
  return a + b
}

fn compute() -> Unit {
  println(add(2, 40))
}

fn main {
  compute()
}



================================================
File 126: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson3_function/index.md
================================================
# Function

This example defines two functions, `add` and `compute`.

The `add` function takes two arguments, `a` and `b`, and returns their sum.

The `compute` function takes no arguments and returns nothing. 
Its return type is `Unit`, which is used to represent the absence of a return value.








================================================
File 127: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson4_block/index.mbt
================================================
fn main {
  let a = 100

  {
    let mut a = 0
    println("checkpoint 1")
    a = a + 1
  }

  println("checkpoint 2")
  println(f())
}

fn f() -> Int {
  let b = 3.14

  let result = {
    let b = 1
    println("checkpoint 3")
    b + 5 
  }

  result // same as `return result` here
}




================================================
File 128: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson4_block/index.md
================================================
# Block and Statements

A block is an expression contains sequence of statements and an optional 
expression.

```
{
  statement1
  statement2
  expression
}
```

For example, the code above will execute `statement1`, `statement2`
and evaluate `expression` in order. The evaluation result of the block is the 
evaluation result of the expression. If the last one expression is omitted, 
the block will result in `()`, which type is `Unit`.


A statement can be a variable declaration, variable assignment, or any 
expression which type is `Unit`.  


A block is also associated with a namespace scope. In the `main` clause, the variable `a` declared in the inner block will shadow the outer `a`. It is only visible within the inner block.







================================================
File 129: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson5_array/index.mbt
================================================
fn main {
  let arr1 : Array[Int] = [1, 2, 3, 4, 5]
  let arr2 = Array::make(4,1) 

  println(arr1.length()) // get the length of the array
  println(arr1[1]) // get the second element of the array

  // We can also use the spread operator to concatenate arrays.
  let arr3 = [..arr1, 1000, 2000, ..arr2, 3000, 4000]
  println("spread arrays:")
  println(arr3)

  let view : ArrayView[Int] = arr1[1:4]
  println("array view:")
  println(view)
  println("view[0]:")
  println(view[0])

  arr1.push(6) // push an element to the end
  println("updated array:")
  println(arr1)
}

================================================
File 130: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson5_array/index.md
================================================
# Array

Array is a collection of elements that have the same type.

You can create an array using *array literal syntax*, which is a comma-separated list
of elements enclosed in square brackets: `[1,2,3]`.

You can also create an array by using the `Array::make` function, which takes a size and an element value,
as shown in the example, `Array::make(4,1)` creates an array equal to `[1,1,1,1]`.

The `arr3` is an array consisting of elements in `arr1`, elements in `arr2` and a few more numbers.
`..arr1` in square brackets is called an *array spread*, which is used to expand an array into another array.

## Array view

You can use the `array[start:end]` syntax to get a view of the array from index `start` to `end` (exclusive). The `start` and `end` parts are optional. A view is a reference to the original array and is used to avoid copying the array.

## Mutability of array

You may notice that we push an element to the array `arr1`, which changes the content of the array. How does that work if `arr1` is not marked with `mut`?

The answer is that the elements inside the array are mutable, which is **defined by the array type itself**. The `mut` keyword in the `let` statement is only used to determine whether the variable name you defined can be reassigned.

If you try to reassign `arr1` to another array like `arr1 = [1,2,3]`, you will get a compilation error.


================================================
File 131: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson6_string/index.mbt
================================================
fn main {
  let str = "Hello, World!"
  // Access a character by index.
  let c : Char = str[4]
  println(c)
  let c2 = 'o'
  println(c == c2)

  // Use escape sequence.
  println("\nHello, \tWorld!")
  println("unicode \u{1F407} is a rabbit")

  // Concatenate two strings.
  println(str + " Hello, MoonBit!")

  // Use string interpolation.
  let moon = "Moon"
  let bit = "Bit"
  println("Use \{moon + bit}. Happy coding")
}

================================================
File 132: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson6_string/index.md
================================================
# String

A string is a sequence of characters encoded in UTF-16. In MoonBit, strings are immutable,
which means you cannot change the elements inside a string.

MoonBit supports C-style escape characters in strings and chars, such as `\n` (newline),
`\t` (tab), `\\` (backslash), `\"` (double-quote), and `\'` (single-quote).

Unicode escape characters are also supported. You can use `\u{...}` (where `...` represents
the Unicode character's hex code) to represent a Unicode character by its code point.

MoonBit also supports string interpolation written like `\{variable}`, which allows you to embed expressions into strings.



================================================
File 133: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson7_tuple/index.mbt
================================================
fn main {
  // create Tuple 
  let tuple = (3.14, false, [1,2,3])  
  let tuple2 : (Float, Bool, Int) = (2.1, true, 20)
  println(tuple)

  // Accessing tuple elements
  println(tuple.0)
  println(tuple.2)

  // Tuple can also be destructured. 
  let (a, b, c) = f()
  println("\{a}, \{b}, \{c}")
}

fn f() -> (Int, Bool, Double) {
  (1, false, 3.14) // return multiple values via tuple
}


================================================
File 134: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson7_tuple/index.md
================================================
# Tuple

A tuple is a collection of values that can have different types. It is immutable,
which means that once it is created, it cannot be changed. It is created using
parentheses.

You can access the elements of tuple via the index: `tuple.0`, `tuple.1`, etc.

A tuple can be destructed via syntax like `let (a,b) = tuple`, where the `tuple` on
the right side is a tuple with two elements, and `a` and `b` are the variables to
store the elements. This is a special use case of *pattern matching* which we will
introduce in a later chapter.

It's common to use a tuple to return multiple values from a function.



================================================
File 135: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson8_map/index.mbt
================================================
fn main {
  // Create a map by map literal
  let map1 = { "key1": 1, "key2": 2, "key3": 3 }
  println(map1)
  // You can also create a map by Map::of, from a list of key-value pairs
  let map2 = Map::of([("key1", 1), ("key2", 2), ("key3", 3)])
  println(map1 == map2)

  // Access a value by key
  println(map1["key1"])

  // Update a value by key
  map1["key1"] = 10
  println(map1)

  // test a if a key exists
  println(map1.contains("key1"))
}


================================================
File 136: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson8_map/index.md
================================================
# Map

A map is a collection of key-value pairs. Each key is unique in the map, and all keys are associated with a value. It is a mutable collection.

An expression like `{"key1": value1, "key2": value2}` represents a map, called a *map literal*.
If the key and value types of the map are basic types (`Int`, `String`,`Bool`, `Double`, etc.),
then the map can be written as a *map literal*.

In other cases, you can create the map using the `Map::of` function. It takes an array of two-element tuples, where the first element is the key and the second element is the value.

Values in a map can be accessed by the key using the `map[key]` syntax.

The elements in a map can be updated using the syntax: `map[key] = new_value`.


================================================
File 137: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson9_if_else/index.mbt
================================================
fn fib(x : Int) -> Int {
  if x < 2 {
    x
  } else {
    fib(x - 1) + fib(x - 2)
  }
}

fn main {
  if 5 > 1 {
    println("5 is greater than 1")
  }
  println(fib(5))
  println(weekday(3))
}

fn weekday(x : Int) -> String {
  if x == 1 {
    "Monday"
  } else if x == 2 {
    "Tuesday"
  } else if x == 3 {
    "Wednesday"
  } else if x == 4 {
    "Thursday"
  } else if x == 5 {
    "Friday"
  } else if x == 6 {
    "Saturday"
  } else if x == 7 {
    "Sunday"
  } else {
    "Invalid day"
  }
}


================================================
File 138: /data/input/moonbit-docs/moonbit-tour/tour/chapter1_basics/lesson9_if_else/index.md
================================================
# If expression

An if expression is a conditional control flow expression that has a result value.

In an if expression, each branch must have the same type. If the condition is true, it returns the result value of the first branch. Otherwise, it returns the result value of the second branch.

The `else` part is optional. If it is omitted, the type of the whole if expression will be `Unit`.

Nested if expressions in the else part can be shortened by using `else if`.







================================================
File 139: /data/input/moonbit-docs/moonbit-tour/tour/chapter2_data_types/lesson1_struct/index.mbt
================================================
struct Point {
  x : Int
  y : Int
} derive(Show)

fn main {
  // create a point
  let point = { x: 3, y: 4 }
  println("point: \{point}")
  println("point.x: \{point.x}")
  println("point.y: \{point.y}")
  
  // functional update
  let point2 = {..point, x: 20}
  println(point2)
}



================================================
File 140: /data/input/moonbit-docs/moonbit-tour/tour/chapter2_data_types/lesson1_struct/index.md
================================================
# Struct

Struct is a new type composed of other types.

In the example we define a struct `Point` with two fields, `x` and `y`, both of which are integers.

We can create an instance of `Point` by writing `{ x: 3, y: 4 }`. The struct name can be omitted since the compiler can infer it from the labels `x` and `y`.

We can also add a `Point::` prefix to create an instance explicitly to disambiguate its type.

Analogous to tuples, we can access the fields of a struct using the syntax `point.x`.

The `derive(Show)` after the struct definition means that we can print the struct using the `println` function.

The fields of a struct are immutable by default; they can't be changed after they are created. There is a syntax called *functional update* that allows you to create a new struct with some fields updated.

We will learn how to make the fields mutable in the next lesson.



================================================
File 141: /data/input/moonbit-docs/moonbit-tour/tour/chapter2_data_types/lesson2_mutable_field/index.mbt
================================================
struct MutPoint {
  mut mx : Int
  y : Int
} derive(Show)

fn main {
  let point = { mx: 3, y: 4 }
  println("point: \{point}")
  point.mx = 10
  println("point: \{point}")
}



================================================
File 142: /data/input/moonbit-docs/moonbit-tour/tour/chapter2_data_types/lesson2_mutable_field/index.md
================================================
# Mutable fields in Struct

Struct fields are immutable by default, but we can make them mutable by using the `mut` keyword in the field declaration.

In previous lessons, we have learned that collections in MoonBit can be either mutable or immutable. This is achieved by using the `mut` keyword in their type declaration.

The `MutPoint` struct in the example has two fields, mutable `mx` and immutable `y`.
You can change the value of the `mx` field via reassignment but not the value of `y`.


================================================
File 143: /data/input/moonbit-docs/moonbit-tour/tour/chapter2_data_types/lesson3_enum/index.mbt
================================================
enum Color {
  Red
  Green
  Blue
  RGB(Int, Int, Int)
  CMYK(Int, Int, Int, Int)
} derive(Show)

fn print_color(color : Color) -> Unit {
  match color {
    Red => println("Red")
    Green => println("Green")
    Blue => println("Blue")
    // Take the three Int values from RGB and print them.
    RGB(r, g, b) => println("RGB: \{r}, \{g}, \{b}")
    CMYK(c, m, y, k) => println("CMYK: \{c}, \{m}, \{y}, \{k}")
  }
}

fn main {
  let red = Red
  let green = Color::Green
  let blue = RGB(0, 0, 255)
  let black = CMYK(0, 0, 0, 100)
  print_color(red)
  print_color(green)
  print_color(blue)
  print_color(black)
}


================================================
File 144: /data/input/moonbit-docs/moonbit-tour/tour/chapter2_data_types/lesson3_enum/index.md
================================================
# Enum

An enum is used to define a type by enumerating its possible values.
Unlike traditional enums, MoonBit enums can have data associated with each enumeration.
We call each enumeration an *enum constructor*.

In this example, we define an enum `Color`, which has five enum constructors: `Red`, `Green`, `Blue`, `RGB`, and `CMYK`.
The `Red`, `Green`, and `Blue` values directly represent the colors they describe, while `RGB` and `CMYK` have data associated with them.

Values like `Red` and `RGB(255,255,255)` are both instances of the `Color` type. To create an instance more explicitly, you can use `Color::Red`, similar to creating an instance of a struct.

We use a bit of *pattern matching* to distinguish different *enum constructors* in `print_color`. It's a control flow similar to switch-case in C-like languages. Here is a slight difference: you can extract the associated data by giving them a name on the left of `=>`, and use them as variables on the right side.

We will explore more powerful features of *pattern matching* in the next chapter.



================================================
File 145: /data/input/moonbit-docs/moonbit-tour/tour/chapter2_data_types/lesson4_newtype/index.mbt
================================================
type UserId Int derive(Show)
type UserName String derive(Show)

fn main {
  let user_id : UserId = UserId(1)
  let user_name : UserName = UserName("Alice")
  println(user_id._)
  println(user_name._)
  // use some pattern matching to extract the values
  let UserId(id) = user_id 
  let UserName(name) = user_name
}


================================================
File 146: /data/input/moonbit-docs/moonbit-tour/tour/chapter2_data_types/lesson4_newtype/index.md
================================================
# Newtype

Newtypes are similar to enums with only one constructor (with the same name as the newtype itself). You can use the constructor to create values of the newtype and use `._` to extract the internal representation. 

You can also use *pattern matching* with newtypes.



================================================
File 147: /data/input/moonbit-docs/moonbit-tour/tour/chapter2_data_types/lesson5_option/index.mbt
================================================
fn first_char(s : String) -> Option[Char] {
  if s.length() == 0 {
    None
  } else {
    Some(s[0])
  }
}

fn main {
  let c1 : Char? = first_char("hello")
  let c2 : Option[Char] = first_char("")
  println("\{c1.is_empty()}, \{c1.unwrap()}")
  println("\{c2.is_empty()}, \{c2}")
}


================================================
File 148: /data/input/moonbit-docs/moonbit-tour/tour/chapter2_data_types/lesson5_option/index.md
================================================
# Option

`Option[Char]` is an enum that represents a `Char` value that may or may not be present. It is a common way to handle exceptional cases.

- `None` means the value is missing.
- `Some(e)` is a wrapper that contains the value `e`.

The `[Char]` part in the type is a type parameter, which means the value type in `Option` is `Char`. We can use `Option[String]`, `Option[Double]`, etc. We will cover generics later.

The type annotation `Option[A]` can be shortened to `A?`.

You can use `c1.is_empty()` to check if the value is missing and `c1.unwrap()` to get the value.



================================================
File 149: /data/input/moonbit-docs/moonbit-tour/tour/chapter2_data_types/lesson6_result/index.mbt
================================================
fn first_char(s : String) -> Result[Char, String] {
  if s.length() == 0 {
    Err("empty string")
  } else {
    Ok(s[0])
  }
}

fn main {
  let c1  = first_char("hello")
  let c2  = first_char("")
  println("\{c1.is_ok()}, \{c1}, \{c1.unwrap()}")
  println("\{c2.is_err()}, \{c2}")
}


================================================
File 150: /data/input/moonbit-docs/moonbit-tour/tour/chapter2_data_types/lesson6_result/index.md
================================================
# Result

Similar to `Option[Char]`, the enum `Result[Char, String]` represents a `Char` value that may or may not be present. If not present, it can contain an error message of type `String`.

- `Err("error message")` means the value is missing, and the error message is provided.
- `Ok('h')` is a wrapper that contains the value `'h'`.

The processing of `Option` and `Result` in examples so far is verbose and prone to bugs. To handle `Option` and `Result` values safely and cleanly, you can use *pattern matching*. It's recommended to use *error handling* to process errors effectively. These two topics will be covered in a later chapter.



================================================
File 151: /data/input/moonbit-docs/moonbit-tour/tour/chapter3_pattern_matching/lesson1_introduction/index.mbt
================================================
struct Point {
  x : Int
  y : Int
} derive(Show)

fn main {
  let tuple = (1, false, 3.14)
  let array = [1, 2, 3]
  let record = { x: 5, y: 6 }
  let (a, b, c) = tuple
  println("a:\{a}, b:\{b}, c:\{c}")
  let [d, e, f] = array
  println("d:\{d}, e:\{e}, f:\{f}")
  let { x, y } = record
  println("x:\{x}, y:\{y}")
}


================================================
File 152: /data/input/moonbit-docs/moonbit-tour/tour/chapter3_pattern_matching/lesson1_introduction/index.md
================================================
# Pattern Matching

We have seen pattern matching in the previous example.
It's a powerful feature in MoonBit that can be used in many places. It can help you test conditions conveniently and effectively, making your programs more precise and robust.

In this example, we give some basic use cases of pattern matching. Some other languages call it "destructuring" or "structured bindings", a way to extract values from a complex data structure.

"Destructuring" is just a subset of this feature.
In MoonBit, almost every type you can construct can have a form to "destruct", which we call a *pattern*.


================================================
File 153: /data/input/moonbit-docs/moonbit-tour/tour/chapter3_pattern_matching/lesson2_let_and_match/index.mbt
================================================
enum Resource {
  TextFile(String)
  Image(String)
  Folder(Map[String, Resource])
} derive(Show)

let assets : Resource = Folder(
  {
    "readme.md": TextFile("hello world"),
    "image.jpg": Image("https://someurl1"),
    "folder1": Folder(
      {
        "src1.mbt": TextFile("some code1"),
        "src2.mbt": TextFile("some MoonBit code 2"),
      },
    ),
    "folder2": Folder(
      {
        "src3.mbt": TextFile("some code3"),
        "image2.jpg": Image("https://someurl2"),
      },
    ),
  },
)

fn main {
  let Folder(top_level) = assets
  println("we have items in the root folder:\n \{top_level.keys()}")
  println("resource count: \{count(assets)}")
}

fn count(res : Resource) -> Int {
  match res {
    Folder(map) => {
      let mut sum = 0
      for name, res in map {
        sum += count(res)
      }
      sum
    }
    TextFile(_) => 1
    Image(_) => 1
  }
}



================================================
File 154: /data/input/moonbit-docs/moonbit-tour/tour/chapter3_pattern_matching/lesson2_let_and_match/index.md
================================================
# Pattern in let and match

There are two common places to use a pattern: `let` and `match`.

In this example, we define a `Resource` type that describes a file system.
The `Resource` can be a text file, an image, or a folder associated with more files.

## Pattern in let statement

In a `let` statement, the left side of `=` can be a pattern.
We know that `assets` is a folder so we just use `let Folder(top_level) = assets` to match it and extract the value into the immutable variable `top_level`.

You may notice that there is a partial match warning because the resource can also be `Image` or `TextFile`.
**Partial matches make the program more fragile: the pattern matching may fail in other cases and lead to the program aborting.**
Practically, the `match` expression is used more frequently than the `let` statement.

## Pattern in match expression

The `count` function traverses the input `res` recursively and returns the count of `Image` and `TextFile`, using a `match` expression.

Match expressions have *first match semantics*. They will try to find the first matching pattern sequentially from the first case to the last case and execute the corresponding matched expression. If no pattern matches, the program will abort.

The match expression has an `Int` return value because all the cases result in the same value type `Int`.

Patterns can be nested. If you don't care about the data associated with the enum constructor, you can use the *any pattern*, written as `_`, instead of introducing a new variable.
The underscore means that the value is discarded.


================================================
File 155: /data/input/moonbit-docs/moonbit-tour/tour/chapter3_pattern_matching/lesson3_constant_pattern/index.mbt
================================================
fn fibonacci(x : Int) -> Int {
  // assume x > 0
  match x {
    1 => 1
    2 => 2
    _ => fibonacci(x - 1) + fibonacci(x - 2)
  }
}

fn negate(x : Bool) -> Bool {
  match x {
    true => false
    false => true
  }
}

fn read(x : Char) -> Int? {
  match x {
    '1' => Some(1)
    '2' => Some(2)
    '3' => Some(3)
    _ => None
  }
}

fn contents(file : String) -> String? {
  match file {
    "README" => Some("# hello world")
    "hello.mbt" => Some("println(\"hello world\")")
    _ => None
  }
}

fn main {
  println("fib(5): \{fibonacci(5)}")
  println("negate(false): \{negate(false)}")
  println("read('2'): \{read('2')}, read('5'): \{read('5')}")
  println(contents("README"))
}


================================================
File 156: /data/input/moonbit-docs/moonbit-tour/tour/chapter3_pattern_matching/lesson3_constant_pattern/index.md
================================================
# Constant pattern

Almost all constants in MoonBit can be represented as a constant pattern.


================================================
File 157: /data/input/moonbit-docs/moonbit-tour/tour/chapter3_pattern_matching/lesson4_tuple_pattern/index.mbt
================================================
fn logical_and(x : Bool, y : Bool) -> Bool {
  match (x, y) {
    (true, true) => true
    (false, _) => false
    (_, false) => false
  }
}

fn logical_or(x : Bool, y : Bool) -> Bool {
  match (x, y) {
    (true, _) => true
    (_, true) => true
    _ => false
  }
}

fn main {
  println("true and false: \{logical_and(true, false)}")
  println("true or false: \{logical_or(true, false)}")
}


================================================
File 158: /data/input/moonbit-docs/moonbit-tour/tour/chapter3_pattern_matching/lesson4_tuple_pattern/index.md
================================================
# Tuple pattern

Use a tuple pattern to match multiple conditions at once.

This example simulates *logical and* and *logical or* operations via pattern matching.

In this scenario, the overhead of creating the tuple in the condition will be optimized out by the compiler.




================================================
File 159: /data/input/moonbit-docs/moonbit-tour/tour/chapter3_pattern_matching/lesson5_alias_pattern/index.mbt
================================================
fn main {
  let (a, (b, _) as tuple, _) as triple = (1, (true, 5), false)
  println("a: \{a}, b: \{b}")
  println("tuple: \{tuple}")
  println("triple: \{triple}")
}


================================================
File 160: /data/input/moonbit-docs/moonbit-tour/tour/chapter3_pattern_matching/lesson5_alias_pattern/index.md
================================================
# Alias Pattern

Any pattern can be bound to an extra new name via an *alias pattern*. The syntax is `pattern as name`. In this example, we use this feature to preserve the original tuples while pattern matching them.






================================================
File 161: /data/input/moonbit-docs/moonbit-tour/tour/chapter3_pattern_matching/lesson6_array_pattern/index.mbt
================================================
fn main {
  let array = [1, 2, 3, 4, 5, 6]
  let [a, b, ..] = array
  let [.., c, d] = array
  let [e,  ..,  f] = array
  println("a: \{a}, b: \{b}")
  println("c: \{c}, d: \{d}")
  println("e: \{e}, f: \{f}")
  println("sum of array: \{sum(array[:])}")
}

fn sum(array : ArrayView[Int]) -> Int {
  match array {
    [] => 0
    [x, .. xs] => x + sum(xs)
  }
}


================================================
File 162: /data/input/moonbit-docs/moonbit-tour/tour/chapter3_pattern_matching/lesson6_array_pattern/index.md
================================================
# Array Pattern

An array pattern is a sequence of patterns enclosed in `[]` that matches an array.

You can use `..` to match the rest of the array at the start, end, or middle elements of the array.

In an array pattern, the `..` part can be bound to a new variable via an *alias pattern*. The type of that variable is `ArrayView`. The `sum` function uses this feature to calculate the sum of the array recursively.


================================================
File 163: /data/input/moonbit-docs/moonbit-tour/tour/chapter3_pattern_matching/lesson7_or_pattern/index.mbt
================================================
enum Color {
  Blue
  Red
  Green
  RGB(Int, Int, Int)
  RGBA(Int, Int, Int, Int)
} derive(Show)

fn get_green(color : Color) -> Int {
  match color {
    Blue | Red => 0
    Green => 255
    RGB(_, g, _) | RGBA(_, g, _, _) => g
  }
}

fn main {
  println("The green part of Red is \{get_green(Red)}")
  println("The green part of Green is \{get_green(Green)}")
  println("The green part of Blue is \{get_green(Blue)}")
  println("The green part of RGB(0,0,0) is \{get_green(RGB(0,0,0))}")
  println("The green part of RGBA(50,5,0,6) is \{get_green(RGBA(50,5,0,6))}")
}


================================================
File 164: /data/input/moonbit-docs/moonbit-tour/tour/chapter3_pattern_matching/lesson7_or_pattern/index.md
================================================
# Or Pattern

It's a little verbose if any two cases have common data and the same code to handle them. For example, here is an enum `RGB` and a function `get_green` to get the green value from it.

The `RGB` and `RGBA` cases can be combined as well. In an *or pattern*, the sub-patterns can introduce new variables, but they must be of the same type and have the same name in all sub-patterns. This restriction allows us to handle them uniformly.



================================================
File 165: /data/input/moonbit-docs/moonbit-tour/tour/chapter3_pattern_matching/lesson8_range_pattern/index.mbt
================================================
fn score_to_grade(score : Int) -> String {
  match score {
    0..<60 => "F"
    60..<70 => "D"
    70..<80 => "C"
    80..<90 => "B"
    90..=100 => "A"
    _ => "Invalid score"
  }
}

fn classify_char(c : Char) -> String {
  match c {
    'A'..='Z' => "UpperCase"
    'a'..='z' => "LowerCase"
    '0'..='9' => "Digit"
    _ => "Special"
  }
}

fn is_scalar_value(codepoint : Int) -> Bool {
  match codepoint {
    0x0000..=0xD7FF | 0xE000..=0x10FFFF => true
    _ => false
  }
}

fn main {
  println(score_to_grade(50))
  println(score_to_grade(85))
  println(score_to_grade(95))
  println(classify_char('A'))
  println(classify_char('1'))
  println(classify_char('!'))
  println(is_scalar_value(0xD500))
}


================================================
File 166: /data/input/moonbit-docs/moonbit-tour/tour/chapter3_pattern_matching/lesson8_range_pattern/index.md
================================================
# Range Pattern

For consecutive values, using the previously introduced *or-patterns* can be somewhat cumbersome. To address this issue, we can use *range patterns*. *Range patterns* can match values within a specified range.


Recall the syntax we learned in Chapter 1:

- `start..<end` range is inclusive of the start value and exclusive of the end value.
- `start..=end` range is inclusive of both the start and end values.


Range patterns support built-in integer-like types, such as `Byte`, `Int`, `UInt`, `Int64`, `UInt64`, and `Char`.



================================================
File 167: /data/input/moonbit-docs/moonbit-tour/tour/chapter4_more_data_types/lesson1_immutable_list/index.mbt
================================================
fn count[A](list : @immut/list.T[A]) -> UInt {
  match list {
    Nil => 0
    Cons(_, rest) => count(rest) + 1 // may overflow
  }
}

///|
fn main {
  let empty_list : @immut/list.T[Int] = Nil
  let list_1 = @immut/list.Cons(1, empty_list)
  let list_2 = @immut/list.Cons(2, list_1)
  let list_3 = @immut/list.Cons(3, empty_list)
  let reversed_1 = list_1.rev()
  let n = count(reversed_1)
}


================================================
File 168: /data/input/moonbit-docs/moonbit-tour/tour/chapter4_more_data_types/lesson1_immutable_list/index.md
================================================
# Immutable List

The immutable list resides in the package `@immut/list`.

It is either:

- `Nil` : an empty list
- `Cons` : an element and the rest of the list.

<!-- As such, many operations such as reversing the list have complexity of O(n) and
may cause stack overflow. -->


================================================
File 169: /data/input/moonbit-docs/moonbit-tour/tour/chapter4_more_data_types/lesson2_immutable_set/index.mbt
================================================
///|
fn main {
  let a = @immut/hashset.of([5, 4, 3, 2, 1])
  let b = @immut/sorted_set.of([5, 4, 3, 2, 1])
  let arraya = a.iter().collect()
  let arrayb = b.iter().collect()
  let c = a.add(6)
  let d = b.add(6)
  let except_one = d.remove_min()
  println(d)
}


================================================
File 170: /data/input/moonbit-docs/moonbit-tour/tour/chapter4_more_data_types/lesson2_immutable_set/index.md
================================================
# Immutable Set

The immutable set has two variants:

- Hash set in the `@immut/hashset`
- Sorted set in the `@immut/sorted_set`

The first one is hash based and hence unordered while the second one require its key
to be ordered.
<!-- Thus behavors differently and have different APIs. -->

================================================
File 171: /data/input/moonbit-docs/moonbit-tour/tour/chapter4_more_data_types/lesson3_immutable_map/index.mbt
================================================
///|
fn main {
  let a = @immut/hashmap.of([(1, "a"), (2, "b"), (3, "c")])
  let b = a.add(4, "d")
  let c = @immut/sorted_map.from_iter(b.iter())
  println(c.keys())
}


================================================
File 172: /data/input/moonbit-docs/moonbit-tour/tour/chapter4_more_data_types/lesson3_immutable_map/index.md
================================================
# Immutable Map

Similar to the immutable set, there are two immutable maps:

- Hash map in the `@immut/hashmap`
- Sorted map in the `@immut/sorted_map`

The first one is hash based and hence unordered while the second one require its 
key to be ordered.

================================================
File 173: /data/input/moonbit-docs/moonbit-tour/tour/chapter5_methods_and_traits/lesson1_methods/index.mbt
================================================
type MyInt Int

fn increment(self : MyInt) -> MyInt {
  MyInt(self._ + 1)
}

fn MyInt::println(x : MyInt) -> Unit {
  println("MyInt(\{x._})")
}

fn main {
  let x = MyInt(39)
  let y = x.increment() // call method via dot syntax
  let z = increment(y) // `fn increment(..)` can be called directly
  let w = MyInt::increment(z) // call methods using qualified syntax
  w.println()
  MyInt::println(w) // `fn MyInt::println` cannot be called via `println(..)` directly
}


================================================
File 174: /data/input/moonbit-docs/moonbit-tour/tour/chapter5_methods_and_traits/lesson1_methods/index.md
================================================
# Methods

In MoonBit, methods are toplevel functions associated with a type.

There are two ways to declare a method:

- `fn method_name(self : T, ..) -> ..`. The name of the first parameter must be `self` here.
  The declared method will be associated with the type `T`
- `fn T::method_name(..) -> ..`, where the method is associated with type `T`

Methods allow more flexible call syntax compared to regular functions:

- methods can always be invoked with the syntax `T::method_name(..)`
- methods can also be invoked with the syntax `x.method_name(..)`,
  which is equivalent to `T::method_name(x, ..)`, where `T` is the type of `x`
- methods declared with `fn method_name(self : T, ..)` can be invoked using `method_name(..)`, just like regular function

There are already a lot of methods in previous lessons, such as `Array::make(..)` and `arr.length()`.

The difference between two ways to declare method, and guideline for choosing between them is:

- the `fn method_name(self : T, ..)` syntax declares a method in toplevel name space,
  just like regular function.
  So this kind of method can be called via `method_name(..)` directly,
  and cannot have name clash with other regular functions.
  if the method is for a primary type of your package,
  and has no name clash with other regular functions,
  use the `fn method_name(..)` syntax
- the `fn T::method_name(..)` syntax declares a method in a small namespace `T`,
  so this kind of method can only be called via `T::method_name(..)` or `x.method_name(..)`.
  But the benefit is, you can have multiple methods with the same name in this way,
  provided that the types of the methods are different.
  So, this syntax can be used to resolve ambiguity or make the scope of your package cleaner.


================================================
File 175: /data/input/moonbit-docs/moonbit-tour/tour/index.mbt
================================================
fn main {
  println("hello")
}

================================================
File 176: /data/input/moonbit-docs/moonbit-tour/tour/index.md
================================================
# Welcome to the MoonBit language tour! 💫

This tour covers all aspects of the MoonBit language, and assumes you have some prior programming experience. It should teach you everything you need to write real programs in MoonBit.

The tour is interactive! The code shown is editable and will be compiled and evaluated as you type. Anything you print using `println` will be shown in the bottom section. To evaluate MoonBit code the tour compiles MoonBit to [WebAssembly](https://webassembly.org/) and runs it, all entirely within your browser window.

If at any point you get stuck or have a question do not hesitate to ask in the [MoonBit Discord server](https://discord.com/invite/5d46MfXkfZ). We're here to help, and if you find something confusing then it's likely others will too, and we want to know about it so we can improve the tour.

OK, let's go. Click "Next" to get started, or click "Contents" to jump to a specific topic.


================================================
File 177: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson10_loop/index.mbt
================================================
fn main {
  let array = [1, 2, 3]

  println("for loop:")
  for i = 0; i < array.length(); i = i + 1 {
    println("array[\{i}]: \{array[i]}")
  }

  println("\nfunctional for loop:")

  let sum = for i = 1, acc = 0; i <= 10; i = i + 1 {
    let even = i % 2 == 0
    continue i + 1, acc + i
  } else {
    acc
  }
  println(sum)

  println("\nwhile loop:")
  let mut j = 0
  while true {
    println("array[\{j}]: \{array[j]}")
    j = j + 1
    if j < array.length() {
      continue
    } else {
      break
    }
  }
}


================================================
File 178: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson10_loop/index.md
================================================
# 循环

本示例展示了使用 for 循环和 while 循环遍历数组。

## for 循环表达式

for 循环类似于 C 风格的 for 循环：

```
for 初始化; 条件; 增量 {
    // 循环体
}
```

循环开始前执行初始化部分。每次迭代时：
1. 检查条件表达式
2. 若条件为真则执行循环体
3. 执行增量表达式
4. 重复上述步骤直到条件为假

MoonBit 的 for 循环比 C 风格更灵活，后续章节将详细说明。

## while 循环表达式

while 循环同样类似 C 风格：

```
while 条件 {
    // 循环体
}
```

执行流程：
1. 检查条件表达式
2. 若条件为真则执行循环体
3. 重复上述步骤直到条件为假

MoonBit 也支持在循环中使用`continue`和`break`语句。


================================================
File 179: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson11_for_in_loop/index.mbt
================================================
fn main {
  println("for-in loop:")
  let array = [1, 2, 3]
  for element in array {
    println("element: \{element}")
  }

  println("for-in loop with index:")
  for i, element in array {
    println("index: \{i}, element: \{element}")
  }
  
  println("for-in loop for map:")
  let map = { "key1": 1, "key2": 2, "key3": 3 }
  for k, v in map {
    println("key: \{k}, value: \{v}")
  }
}


================================================
File 180: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson11_for_in_loop/index.md
================================================
# For-in 循环

手动编写 for 循环并决定结束条件较为繁琐。

若需遍历集合，可使用 `for .. in ... {}` 循环。

第一个 for-in 循环遍历数组，每次迭代会将元素绑定至变量 `element`。

第二个循环遍历键值对映射（Map），将键绑定至第一个变量 (`k`)，值绑定至第二个变量 (`v`)。

哪些集合支持 for-in 循环？何时支持双变量遍历？这取决于集合的 API 设计：

- 若集合提供 `iter()` 方法返回 `Iter[V]` 迭代器，则支持单变量遍历
- 若集合提供 `iter2()` 方法返回 `Iter2[K,V]` 迭代器，则支持双变量遍历

我们将在后续章节详解迭代器机制。


================================================
File 181: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson12_range/index.mbt
================================================
fn main {
  println("number 1 to 3:")
  for i in 1..<4 {
    println(i)
  }
  
  println("number 1 to 4:")
  for i in 1..=4 {
    println(i)
  }
}





================================================
File 182: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson12_range/index.md
================================================
# 范围表达式

可在 for-in 循环中使用*范围表达式*：

- `start..<end`：包含起始值，不包含结束值
- `start..=end`：同时包含起始值和结束值


================================================
File 183: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson13_exception/index.mbt
================================================
///|
pub fn safe_add(i : Int, j : Int) -> Int! {
  let signum_i = i & 0x80000000
  let signum_j = j & 0x80000000
  let result = i + j
  if signum_i != signum_j {
    result
  } else {
    let result_signum = result & 0x80000000
    if result_signum != signum_i {
      fail!("overflow")
    } else {
      result
    }
  }
}

///|
fn main {
  let a = try {
    safe_add!(1, 2)
  } catch {
    _ => panic()
  }
  try {
    let result = safe_add!(@int.max_value, @int.max_value)

  } catch {
    Failure(error_message) => println(error_message)
    _ => panic()
  }
  let result = safe_add?(@int.max_value, @int.max_value)

}


================================================
File 184: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson13_exception/index.md
================================================
# 错误处理

`!` 语法用于表示函数可能引发错误。

你可以使用 `try { ... } catch { ... }` 语法来处理这种情况，或者使用 `?`
语法将结果转换为 `Result`，这是一个用于表示计算结果的类型。


================================================
File 185: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson14_test/index.mbt
================================================
test {
  assert_eq!(1, 1 + 2)
  assert_false!(1 == 2)
  assert_true!([1,2,3] == [1,2,3])
}

test {
  inspect!(fib(5))
  inspect!([1,2,3,4].map(fib))
}

// Add test name to make it more descriptive.
test "fibonacci" {
  inspect!(fib(5), content="5")
  inspect!(fib(6), content="8")
}

fn fib(n : Int) -> Int {
  if n < 2 {
    n
  } else {
    fib(n - 1) + fib(n - 2)
  }
}



================================================
File 186: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson14_test/index.md
================================================
# 测试

MoonBit 内置测试支持，无需导入或配置额外包和工具。只需使用测试块并在其中编写测试代码。

**注意：本教程暂不支持此功能。您可以在我们的 [playground](https://try.moonbitlang.com) 或安装 MoonBit 工具链后在终端中尝试。**

在第一个测试块中，我们使用内置函数 `assert_eq`、`assert_false` 和 `assert_true` 测试一些属性。通过在终端运行 `moon test` 或点击集成开发环境 (IDE) 中的测试按钮，即可执行测试。

## 维护测试

手动维护预期值有时很繁琐。MoonBit 也支持内置的*快照测试*。快照测试会运行被测代码并将预期结果存储为快照。

在第二个测试块中，我们使用 `inspect` 函数测试 `fib` 的结果和数组的 `map` 方法。通过在终端运行 `moon test --update` 或点击 IDE 中的 `Update test` 按钮，结果将自动插入为第二个参数。

下次运行测试时，它将报告当前结果与存储结果之间的差异。您可以使用 `--update` 标志将存储结果更新为新结果。

================================================
File 187: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson1_variable/index.mbt
================================================
fn main {
  let a : Int = 10 
  let b = 20 
  println(a + b)

  let mut  c = 10 
  c = c + 1
  println(c)

  let d = 20 
  // d = d + 1
  println(d)
}

================================================
File 188: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson1_variable/index.md
================================================
# 变量

`let`关键字用于定义变量。

可通过在变量名后添加冒号和类型进行类型注解，此注解为可选项。当省略类型注解时，编译器会自动从赋值表达式推断变量类型。

MoonBit 中变量默认不可变。如需创建可变变量，需额外添加`mut`关键字，该可变性仅作用于当前作用域。

若取消`d = d + 1`的注释，将触发编译错误。（注：因尝试修改不可变变量）

================================================
File 189: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson2_numbers/index.mbt
================================================
fn main {
  let dec : Int = 1000000
  let dec2 : Int = 1_000_000 
  let hex : Int = 0xFFFF 
  let oct = 0o777
  let bin = 0b1001 

  println(1 + 2)
  println(1 - 2)
  println(1 * 2)
  println(5 / 2)
  println(10 % 3)

  let num1 : Double = 3.14
  let num2 : Float = 3.14
}



================================================
File 190: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson2_numbers/index.md
================================================
# 数值类型

整型（Int）和浮点型（Float）是 MoonBit 中最基础的数值类型。

整型（32 位有符号整数）支持十进制、十六进制、八进制和二进制表示法，可使用下划线分隔数字以提升可读性。这些表示法统称为*数值字面量*。

示例说明：
- `0xFFFF` 表示十六进制数
- `0o777` 表示八进制数
- `0b1010` 表示二进制数
- `1_000_000` 等效于十进制数`1000000`（增强可读性写法）


================================================
File 191: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson3_function/index.mbt
================================================
fn add(a : Int, b : Int) -> Int {
  return a + b
}

fn compute() -> Unit {
  println(add(2, 40))
}

fn main {
  compute()
}



================================================
File 192: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson3_function/index.md
================================================
# 函数

本示例定义了两个函数：`add`和`compute`。

`add`函数接收两个参数`a`和`b`，返回它们的和。

`compute`函数无参数且无返回值，其返回类型为`Unit`，该类型用于表示没有返回值的函数。


================================================
File 193: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson4_block/index.mbt
================================================
fn main {
  let a = 100

  {
    let mut a = 0
    println("checkpoint 1")
    a = a + 1
  }

  println("checkpoint 2")
  println(f())
}

fn f() -> Int {
  let b = 3.14

  let result = {
    let b = 1
    println("checkpoint 3")
    b + 5 
  }

  result // same as `return result` here
}




================================================
File 194: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson4_block/index.md
================================================
# 代码块与语句

代码块是由若干语句和可选结尾表达式组成的复合结构：

```
{
  statement1
  statement2
  expression
}
```

以上代码块将按顺序执行`statement1`、`statement2`，最后计算`expression`的值作为整个代码块的返回值。若省略结尾表达式，代码块将返回`()`（其类型为`Unit`）。

语句可以是以下形式：
- 变量声明
- 变量赋值
- 任何返回`Unit`类型的表达式

代码块同时关联着命名空间作用域。在`main`函数示例中，内部代码块声明的变量`a`会遮蔽（shadow）外部同名变量`a`，且仅在内部代码块中可见。

================================================
File 195: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson5_array/index.mbt
================================================
fn main {
  let arr1 : Array[Int] = [1, 2, 3, 4, 5]
  let arr2 = Array::make(4,1) 

  println(arr1.length()) // get the length of the array
  println(arr1[1]) // get the second element of the array

  // We can also use the spread operator to concatenate arrays.
  let arr3 = [..arr1, 1000, 2000, ..arr2, 3000, 4000]
  println("spread arrays:")
  println(arr3)

  let view : ArrayView[Int] = arr1[1:4]
  println("array view:")
  println(view)
  println("view[0]:")
  println(view[0])

  arr1.push(6) // push an element to the end
  println("updated array:")
  println(arr1)
}

================================================
File 196: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson5_array/index.md
================================================
# 数组

数组是存储相同类型元素的集合。

可通过*数组字面量语法*创建数组，即用方括号包裹逗号分隔的元素列表：`[1,2,3]`。

也可使用`Array::make`函数创建数组，该函数接收长度和元素值作为参数。如示例中`Array::make(4,1)`将创建等同于`[1,1,1,1]`的数组。

`arr3`示例展示了由`arr1`元素、`arr2`元素及额外数字组成的数组。方括号中的`..arr1`语法称为*数组展开*（array spread），用于将数组元素展开到新数组中。

## 数组视图

使用`array[start:end]`语法可获取数组的视图（索引范围包含 start 但不包含 end）。`start`和`end`参数可省略。视图是原数组的引用，可避免数组复制。

## 数组可变性

可能注意到我们对未标记`mut`的数组`arr1`执行了`push`操作。这是因为数组元素的 mutability 由**数组类型自身决定**。`let`声明中的`mut`关键字仅控制变量名能否被重新赋值。

若尝试将`arr1`重新赋值为其他数组（如`arr1 = [1,2,3]`），将触发编译错误。

================================================
File 197: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson6_string/index.mbt
================================================
fn main {
  let str = "Hello, World!"
  // Access a character by index.
  let c : Char = str[4]
  println(c)
  let c2 = 'o'
  println(c == c2)

  // Use escape sequence.
  println("\nHello, \tWorld!")
  println("unicode \u{1F407} is a rabbit")

  // Concatenate two strings.
  println(str + " Hello, MoonBit!")

  // Use string interpolation.
  let moon = "Moon"
  let bit = "Bit"
  println("Use \{moon + bit}. Happy coding")
}

================================================
File 198: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson6_string/index.md
================================================
# 字符串

字符串是 UTF-16 编码的字符序列。在 MoonBit 中，字符串是不可变的，这意味着无法直接修改字符串中的字符。

MoonBit 支持字符串和字符中的 C 风格转义字符，例如`\n`（换行符）、`\t`（制表符）、`\\`（反斜杠）、`\"`（双引号）和`\'`（单引号）。

Moonbit 同时也支持 Unicode 转义字符，可使用`\u{...}`表示（其中`...`代表 Unicode 字符的十六进制码点）。

MoonBit 还支持`\{变量}`形式的字符串插值语法，允许在字符串中嵌入表达式。

================================================
File 199: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson7_tuple/index.mbt
================================================
fn main {
  // create Tuple 
  let tuple = (3.14, false, [1,2,3])  
  let tuple2 : (Float, Bool, Int) = (2.1, true, 20)
  println(tuple)

  // Accessing tuple elements
  println(tuple.0)
  println(tuple.2)

  // Tuple can also be destructured. 
  let (a, b, c) = f()
  println("\{a}, \{b}, \{c}")
}

fn f() -> (Int, Bool, Double) {
  (1, false, 3.14) // return multiple values via tuple
}


================================================
File 200: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson7_tuple/index.md
================================================
# 元组

元组是包含不同类型值的不可变集合，使用圆括号创建。其特性包括：

元组是不可变的，即创建后无法修改其内容。可通过索引访问元素：`tuple.0`、`tuple.1`等。

元组可通过`let (a,b) = tuple`语法进行解构，其中右侧`tuple`必须是包含两个元素的元组，`a`和`b`将分别存储这两个元素。这是*模式匹配*的特例应用，将在后续章节详细讲解。

元组常用于函数返回多个值。

================================================
File 201: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson8_map/index.mbt
================================================
fn main {
  // Create a map by map literal
  let map1 = { "key1": 1, "key2": 2, "key3": 3 }
  println(map1)
  // You can also create a map by Map::of, from a list of key-value pairs
  let map2 = Map::of([("key1", 1), ("key2", 2), ("key3", 3)])
  println(map1 == map2)

  // Access a value by key
  println(map1["key1"])

  // Update a value by key
  map1["key1"] = 10
  println(map1)

  // test a if a key exists
  println(map1.contains("key1"))
}


================================================
File 202: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson8_map/index.md
================================================
# 映射

映射是键值对的集合。每个键在映射中是唯一的，并且所有键都与一个值相关联。它是一个可变的集合。

形如 `{"key1": value1, "key2": value2}` 的表达式可以用来表示一个映射，称为 *映射字面量*。
如果映射的键和值类型是基本类型（`Int`、`String`、`Bool`、`Double` 等），则映射可以使用 *映射字面量*的语法来表示。

其他情况下，我们可以使用 `Map::of` 函数创建映射。它接受一个由两个元素的元组组成的数组，其中第一个元素是键，第二个元素是值。

可以使用 `map[key]` 语法通过键访问映射中的值。

可以使用以下语法更新映射中的元素：`map[key] = new_value`。


================================================
File 203: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson9_if_else/index.mbt
================================================
fn fib(x : Int) -> Int {
  if x < 2 {
    x
  } else {
    fib(x - 1) + fib(x - 2)
  }
}

fn main {
  if 5 > 1 {
    println("5 is greater than 1")
  }
  println(fib(5))
  println(weekday(3))
}

fn weekday(x : Int) -> String {
  if x == 1 {
    "Monday"
  } else if x == 2 {
    "Tuesday"
  } else if x == 3 {
    "Wednesday"
  } else if x == 4 {
    "Thursday"
  } else if x == 5 {
    "Friday"
  } else if x == 6 {
    "Saturday"
  } else if x == 7 {
    "Sunday"
  } else {
    "Invalid day"
  }
}


================================================
File 204: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter1_basics/lesson9_if_else/index.md
================================================
# if 表达式

if 表达式是带有返回值的条件控制流表达式。

在 if 表达式中：
- 每个分支必须具有相同类型
- 当条件为真时返回第一个分支的值
- 否则返回第二个分支的值

`else` 部分可省略。若省略，整个 if 表达式类型将为 `Unit`

在 else 部分中嵌套 if 表达式时，可简写为 `else if` 形式

================================================
File 205: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter2_data_types/lesson1_struct/index.mbt
================================================
struct Point {
  x : Int
  y : Int
} derive(Show)

fn main {
  // create a point
  let point = { x: 3, y: 4 }
  println("point: \{point}")
  println("point.x: \{point.x}")
  println("point.y: \{point.y}")
  
  // functional update
  let point2 = {..point, x: 20}
  println(point2)
}



================================================
File 206: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter2_data_types/lesson1_struct/index.md
================================================
# 结构体

结构体是由其他类型组合而成的新类型。

在示例中，我们定义了一个包含两个整数字段`x`和`y`的结构体`Point`。

我们可以通过编写`{ x: 3, y: 4 }`的语法形式来创建`Point`实例。由于编译器可以通过字段标签`x`和`y`推断类型，因此可以省略结构体名称。

我们也可以显式添加`Point::`前缀来明确指定实例类型，这在需要消除类型歧义时非常有用。

与元组类似，我们可以使用`point.x`语法来访问结构体的字段。

结构体定义后的`derive(Show)`表示我们可以通过`println`函数直接打印结构体内容。

结构体字段默认是不可变的（immutable），创建后不可修改。Moonbit 提供称为*功能更新*（functional update）的语法，允许通过现有结构体创建包含更新字段的新结构体。

我们将在下一课中学习如何使结构体字段可变。

================================================
File 207: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter2_data_types/lesson2_mutable_field/index.mbt
================================================
struct MutPoint {
  mut mx : Int
  y : Int
} derive(Show)

fn main {
  let point = { mx: 3, y: 4 }
  println("point: \{point}")
  point.mx = 10
  println("point: \{point}")
}



================================================
File 208: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter2_data_types/lesson2_mutable_field/index.md
================================================
# 结构体的可变字段

结构体字段默认不可变，但可以通过在字段声明中使用`mut`关键字实现可变性。

在前面的课程中，我们已经了解 MoonBit 的集合类型可以通过类型声明中的`mut`关键字实现可变与不可变的控制。

示例中的`MutPoint`结构体包含两个字段：可变的`mx`和不可变的`y`。  
您可以通过重新赋值修改`mx`字段的值，但无法修改`y`字段的值。

================================================
File 209: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter2_data_types/lesson3_enum/index.mbt
================================================
enum Color {
  Red
  Green
  Blue
  RGB(Int, Int, Int)
  CMYK(Int, Int, Int, Int)
}

fn print_color(color : Color) -> Unit {
  match color {
    Red => println("Red")
    Green => println("Green")
    Blue => println("Blue")
    // Take the three Int values from RGB and print them.
    RGB(r, g, b) => println("RGB: \{r}, \{g}, \{b}")
    CMYK(c, m, y, k) => println("CMYK: \{c}, \{m}, \{y}, \{k}")
  }
}

fn main {
  let red = Red
  let green = Color::Green
  let blue = RGB(0, 0, 255)
  let black = CMYK(0, 0, 0, 100)
  print_color(red)
  print_color(green)
  print_color(blue)
  print_color(black)
}


================================================
File 210: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter2_data_types/lesson3_enum/index.md
================================================
# 枚举类型

枚举类型通过列举可能值来定义新类型。与传统枚举不同，MoonBit 的枚举类型允许每个枚举项关联数据。我们将每个枚举项称为*枚举构造器*。

本示例中定义的`Color`枚举包含五个构造器：`Red`、`Green`、`Blue`、`RGB`和`CMYK`。其中`Red`、`Green`和`Blue`直接表示颜色值，而`RGB`和`CMYK`构造器则携带关联数据。

`Red`和`RGB(255,255,255)`都属于`Color`类型的实例。如需显式创建实例，可采用类似结构体的`Color::Red`语法。

在`print_color`函数中，我们使用*模式匹配*来区分不同的枚举构造器。这种控制流类似于 C 系语言中的 switch-case 语句，不同之处在于：可以通过在`=>`左侧为关联数据命名，并在右侧作为变量使用这些数据。

我们将在后续章节深入探讨*模式匹配*的更强大功能。

================================================
File 211: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter2_data_types/lesson4_newtype/index.mbt
================================================
type UserId Int
type UserName String

fn main {
  let user_id : UserId = UserId(1)
  let user_name : UserName = UserName("Alice")
  println(user_id._)
  println(user_name._)
  // use some pattern matching to extract the values
  let UserId(id) = user_id 
  let UserName(name) = user_name
}


================================================
File 212: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter2_data_types/lesson4_newtype/index.md
================================================
# 新类型模式（Newtype）

新类型模式（Newtype）类似于仅包含单个构造器的枚举类型（构造器名称与新类型模式（Newtype）本身相同）。您可以通过该构造器创建新类型值，并使用`._`操作符提取其内部表示。

新类型模式同样支持*模式匹配*的使用。

================================================
File 213: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter2_data_types/lesson5_option/index.mbt
================================================
fn first_char(s : String) -> Option[Char] {
  if s.length() == 0 {
    None
  } else {
    Some(s[0])
  }
}

fn main {
  let c1 : Char? = first_char("hello")
  let c2 : Option[Char] = first_char("")
  println("\{c1.is_empty()}, \{c1.unwrap()}")
  println("\{c2.is_empty()}, \{c2}")
}


================================================
File 214: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter2_data_types/lesson5_option/index.md
================================================
# Option 类型

`Option[Char]`是表示可能存在的字符值的枚举类型，常用于处理可能缺失值的场景。其构造器包含两种可能：

- `None` 表示值缺失
- `Some(e)` 作为包装器包含实际值`e`

类型声明中的`[Char]`是类型参数，表示`Option`中值的类型为`Char`。同理可使用`Option[String]`、`Option[Double]`等类型。关于泛型的详细内容将在后续章节展开。

类型注解`Option[A]`可简写为`A?`。

您可以通过`c1.is_empty()`检查值是否缺失，使用`c1.unwrap()`获取包装值。

================================================
File 215: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter2_data_types/lesson6_result/index.mbt
================================================
fn first_char(s : String) -> Result[Char, String] {
  if s.length() == 0 {
    Err("empty string")
  } else {
    Ok(s[0])
  }
}

fn main {
  let c1  = first_char("hello")
  let c2  = first_char("")
  println("\{c1.is_ok()}, \{c1}, \{c1.unwrap()}")
  println("\{c2.is_err()}, \{c2}")
}


================================================
File 216: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter2_data_types/lesson6_result/index.md
================================================
# Result 类型

与`Option[Char]`类似，枚举类型`Result[Char, String]`表示可能存在的字符值。当值缺失时，可携带`String`类型的错误信息。

其构造器包含两种形式：
- `Err("错误信息")` 表示值缺失并携带错误描述
- `Ok('h')` 作为包装器包含实际值`'h'`

当前示例中`Option`和`Result`的处理方式较为冗长且易出错。为安全、简洁地处理这些类型，推荐使用：
1. *模式匹配* 进行安全处理
2. *错误处理* 机制有效管理错误

这两个主题将在后续章节详细讲解。

================================================
File 217: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter3_pattern_matching/lesson1_introduction/index.mbt
================================================
struct Point {
  x : Int
  y : Int
} derive(Show)

fn main {
  let tuple = (1, false, 3.14)
  let array = [1, 2, 3]
  let record = { x: 5, y: 6 }
  let (a, b, c) = tuple
  println("a:\{a}, b:\{b}, c:\{c}")
  let [d, e, f] = array
  println("d:\{d}, e:\{e}, f:\{f}")
  let { x, y } = record
  println("x:\{x}, y:\{y}")
}


================================================
File 218: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter3_pattern_matching/lesson1_introduction/index.md
================================================
# 模式匹配

我们在之前的示例中已经演示过模式匹配的用法。
作为 MoonBit 的核心特性之一，模式匹配可应用于多种场景。它能帮助开发者高效实现条件判断，提升代码的精确性和健壮性。

本节将展示模式匹配的基础用法。该特性在其他语言中可能被称为"解构"或"结构化绑定"，主要用于从复杂数据结构中提取值。

需要明确的是："解构"只是模式匹配功能的子集。
在 MoonBit 中，几乎所有可构造的数据类型都支持对应的解构操作，这种解构形式我们称之为*模式*。


================================================
File 219: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter3_pattern_matching/lesson2_let_and_match/index.mbt
================================================
enum Resource {
  TextFile(String)
  Image(String)
  Folder(Map[String, Resource])
}

let assets : Resource = Folder(
  {
    "readme.md": TextFile("hello world"),
    "image.jpg": Image("https://someurl1"),
    "folder1": Folder(
      {
        "src1.mbt": TextFile("some code1"),
        "src2.mbt": TextFile("some MoonBit code 2"),
      },
    ),
    "folder2": Folder(
      {
        "src3.mbt": TextFile("some code3"),
        "image2.jpg": Image("https://someurl2"),
      },
    ),
  },
)

fn main {
  let Folder(top_level) = assets
  println("we have items in the root folder:\n \{top_level.keys()}")
  println("resource count: \{count(assets)}")
}

fn count(res : Resource) -> Int {
  match res {
    Folder(map) => {
      let mut sum = 0
      for name, res in map {
        sum += count(res)
      }
      sum
    }
    TextFile(_) => 1
    Image(_) => 1
  }
}



================================================
File 220: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter3_pattern_matching/lesson2_let_and_match/index.md
================================================
# let 和 match 中的模式

有两个常见的地方可以使用模式：`let` 和 `match`。

在这个例子中，我们定义了一个描述文件系统的 `Resource` 类型。
`Resource` 可以是文本文件、图像或包含更多文件的文件夹。

## let 语句中的模式

在 `let` 语句中，`=` 左边可以是一个模式。
我们知道 `assets` 是一个文件夹，所以我们只需使用 `let Folder(top_level) = assets` 来匹配它并将值提取到不可变变量 `top_level` 中。

你可能会注意到有一个部分匹配警告，因为资源也可以是 `Image` 或 `TextFile`。
**部分匹配使程序更加脆弱：模式匹配可能在其他情况下失败并导致程序中止。**
实际上，`match` 表达式比 `let` 语句更常用。

## match 表达式中的模式

`count` 函数递归地遍历输入 `res` 并返回 `Image` 和 `TextFile` 的计数，使用 `match` 表达式。

匹配表达式具有*第一个匹配语义*。它们将尝试从第一个情况到最后一个情况按顺序找到第一个匹配的模式并执行相应的匹配表达式。如果没有模式匹配，程序将中止。

匹配表达式具有 `Int` 返回值，因为所有情况都产生相同的值类型 `Int`。

模式支持嵌套匹配。当不需要处理枚举构造器关联的具体数据时，可使用通配符模式`_`（下划线）代替变量绑定，该符号表示直接丢弃对应数据值。


================================================
File 221: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter3_pattern_matching/lesson3_constant_pattern/index.mbt
================================================
fn fibonacci(x : Int) -> Int {
  // assume x > 0
  match x {
    1 => 1
    2 => 2
    _ => fibonacci(x - 1) + fibonacci(x - 2)
  }
}

fn negate(x : Bool) -> Bool {
  match x {
    true => false
    false => true
  }
}

fn read(x : Char) -> Int? {
  match x {
    '1' => Some(1)
    '2' => Some(2)
    '3' => Some(3)
    _ => None
  }
}

fn contents(file : String) -> String? {
  match file {
    "README" => Some("# hello world")
    "hello.mbt" => Some("println(\"hello world\")")
    _ => None
  }
}

fn main {
  println("fib(5): \{fibonacci(5)}")
  println("negate(false): \{negate(false)}")
  println("read('2'): \{read('2')}, read('5'): \{read('5')}")
  println(contents("README"))
}


================================================
File 222: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter3_pattern_matching/lesson3_constant_pattern/index.md
================================================
# 常量模式

MoonBit 中几乎所有常量都可以作为常量模式使用。

================================================
File 223: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter3_pattern_matching/lesson4_tuple_pattern/index.mbt
================================================
fn logical_and(x : Bool, y : Bool) -> Bool {
  match (x, y) {
    (true, true) => true
    (false, _) => false
    (_, false) => false
  }
}

fn logical_or(x : Bool, y : Bool) -> Bool {
  match (x, y) {
    (true, _) => true
    (_, true) => true
    _ => false
  }
}

fn main {
  println("true and false: \{logical_and(true, false)}")
  println("true or false: \{logical_or(true, false)}")
}


================================================
File 224: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter3_pattern_matching/lesson4_tuple_pattern/index.md
================================================
# 元组模式

元组模式可用于同时匹配多个条件。

本示例通过模式匹配模拟*逻辑与*和*逻辑或*运算。

在此场景中，条件判断中创建元组的开销会被编译器优化消除。

================================================
File 225: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter3_pattern_matching/lesson5_alias_pattern/index.mbt
================================================
fn main {
  let (a, (b, _) as tuple, _) as triple = (1, (true, 5), false)
  println("a: \{a}, b: \{b}")
  println("tuple: \{tuple}")
  println("triple: \{triple}")
}


================================================
File 226: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter3_pattern_matching/lesson5_alias_pattern/index.md
================================================
# 别名模式

通过*别名模式*可将任意模式绑定到新名称，语法形式为`模式 as 名称`。本示例中，我们利用该特性在模式匹配过程的中可以保留原始元组结构。

================================================
File 227: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter3_pattern_matching/lesson6_array_pattern/index.mbt
================================================
fn main {
  let array = [1, 2, 3, 4, 5, 6]
  let [a, b, ..] = array
  let [.., c, d] = array
  let [e,  ..,  f] = array
  println("a: \{a}, b: \{b}")
  println("c: \{c}, d: \{d}")
  println("e: \{e}, f: \{f}")
  println("sum of array: \{sum(array[:])}")
}

fn sum(array : ArrayView[Int]) -> Int {
  match array {
    [] => 0
    [x, .. as xs] => x + sum(xs)
  }
}


================================================
File 228: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter3_pattern_matching/lesson6_array_pattern/index.md
================================================
# 或模式

当多个分支存在共享数据且处理逻辑相同时，单独处理会显得冗余。例如，本示例定义枚举类型`RGB`和用于提取绿色通道值的`get_green`函数。

通过*或模式*可将`RGB`和`RGBA`分支合并处理。在或模式中，子模式可引入新变量，但所有子模式的变量必须类型相同且命名一致，该限制确保后续能统一处理这些变量。

================================================
File 229: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter3_pattern_matching/lesson7_or_pattern/index.mbt
================================================
enum Color {
  Blue
  Red
  Green
  RGB(Int, Int, Int)
  RGBA(Int, Int, Int, Int)
} derive(Show)

fn get_green(color : Color) -> Int {
  match color {
    Blue | Red => 0
    Green => 255
    RGB(_, g, _) | RGBA(_, g, _, _) => g
  }
}

fn main {
  println("The green part of Red is \{get_green(Red)}")
  println("The green part of Green is \{get_green(Green)}")
  println("The green part of Blue is \{get_green(Blue)}")
  println("The green part of RGB(0,0,0) is \{get_green(RGB(0,0,0))}")
  println("The green part of RGBA(50,5,0,6) is \{get_green(RGBA(50,5,0,6))}")
}


================================================
File 230: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter3_pattern_matching/lesson7_or_pattern/index.md
================================================
# 或模式

当多个分支存在共享数据且处理逻辑相同时，单独处理会显得冗余。例如，本示例定义枚举类型`RGB`和用于提取绿色通道值的`get_green`函数。

通过*或模式*可将`RGB`和`RGBA`分支合并处理。在或模式中，子模式可引入新变量，但所有子模式的变量必须类型相同且命名一致，该限制确保后续能统一处理这些变量。

================================================
File 231: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter3_pattern_matching/lesson8_range_pattern/index.mbt
================================================
fn score_to_grade(score : Int) -> String {
  match score {
    0..<60 => "F"
    60..<70 => "D"
    70..<80 => "C"
    80..<90 => "B"
    90..=100 => "A"
    _ => "Invalid score"
  }
}

fn classify_char(c : Char) -> String {
  match c {
    'A'..='Z' => "UpperCase"
    'a'..='z' => "LowerCase"
    '0'..='9' => "Digit"
    _ => "Special"
  }
}

fn is_scalar_value(codepoint : Int) -> Bool {
  match codepoint {
    0x0000..=0xD7FF | 0xE000..=0x10FFFF => true
    _ => false
  }
}

fn main {
  println(score_to_grade(50))
  println(score_to_grade(85))
  println(score_to_grade(95))
  println(classify_char('A'))
  println(classify_char('1'))
  println(classify_char('!'))
  println(is_scalar_value(0xD500))
}


================================================
File 232: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter3_pattern_matching/lesson8_range_pattern/index.md
================================================
# 范围模式

当需要匹配连续值时，使用之前介绍的*或模式*会显得繁琐。为此，我们可以使用*范围模式*来匹配指定区间内的值。

回顾第一章学过的语法：
- `start..<end` 表示左闭右开区间
- `start..=end` 表示闭区间

范围模式支持内置的整数类型，包括：`Byte`、`Int`、`UInt`、`Int64`、`UInt64`以及`Char`类型。

================================================
File 233: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter4_more_data_types/lesson1_immutable_list/index.mbt
================================================
fn count[A](list : @immut/list.T[A]) -> UInt {
  match list {
    Nil => 0
    Cons(_, rest) => count(rest) + 1 // may overflow
  }
}

///|
fn main {
  let empty_list : @immut/list.T[Int] = Nil
  let list_1 = @immut/list.Cons(1, empty_list)
  let list_2 = @immut/list.Cons(2, list_1)
  let list_3 = @immut/list.Cons(3, empty_list)
  let reversed_1 = list_1.rev()
  let n = count(reversed_1)
}


================================================
File 234: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter4_more_data_types/lesson1_immutable_list/index.md
================================================
# 不可变列表

不可变列表位于包 `@immut/list` 中。

它可以是：

- `Nil` : 一个空列表
- `Cons` : 一个元素和列表的其余部分。

因此，许多操作（例如反转列表）的复杂度为 O(n)，并且可能会栈溢出。



================================================
File 235: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter4_more_data_types/lesson2_immutable_set/index.mbt
================================================
///|
fn main {
  let a = @immut/hashset.of([5, 4, 3, 2, 1])
  let b = @immut/sorted_set.of([5, 4, 3, 2, 1])
  let arraya = a.iter().collect()
  let arrayb = b.iter().collect()
  let c = a.add(6)
  let d = b.add(6)
  let except_one = d.remove_min()
  println(d)
}


================================================
File 236: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter4_more_data_types/lesson2_immutable_set/index.md
================================================
# 不可变集合

不可变集合有两种实现：

- `@immut/hashset` 中的哈希集合
- `@immut/sorted_set` 中的排序集合

因此，它们的行为不同，API 也不同。

================================================
File 237: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter4_more_data_types/lesson3_immutable_map/index.mbt
================================================
///|
fn main {
  let a = @immut/hashmap.of([(1, "a"), (2, "b"), (3, "c")])
  let b = a.add(4, "d")
  let c = @immut/sorted_map.from_iter(b.iter())
  println(c.keys())
}


================================================
File 238: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter4_more_data_types/lesson3_immutable_map/index.md
================================================
# 不可变映射

与不可变集合类似，有两种不可变映射：

- `@immut/hashmap` 中的哈希映射
- `@immut/sorted_map` 中的排序映射



================================================
File 239: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter5_methods_and_traits/lesson1_methods/index.mbt
================================================
type MyInt Int

fn increment(self : MyInt) -> MyInt {
  MyInt(self._ + 1)
}

fn MyInt::println(x : MyInt) -> Unit {
  println("MyInt(\{x._})")
}

fn main {
  let x = MyInt(39)
  let y = x.increment() // 用 `.` 语法调用方法
  let z = increment(y) // `fn increment(..)` 可以直接调用
  let w = MyInt::increment(z) // 也可以用 `T::method_name` 调用
  w.println()
  MyInt::println(w) // `fn MyInt::println` 不能直接用 `println(..)` 调用
}


================================================
File 240: /data/input/moonbit-docs/moonbit-tour/tour/zh/chapter5_methods_and_traits/lesson1_methods/index.md
================================================
# 方法

在 MoonBit 里，方法是关联到某个类型上的顶层函数。

有两种方式来定义方法：

- `fn method_name(self : T, ..) -> ..`。第一个参数的名字必须是 `self`，定义出来的方法会被关联到类型 `T` 上
- `fn T::method_name(..) -> ..`，定义出来的方法会被关联到类型 `T` 上

和普通函数相比，方法可以用更灵活的方式来调用：

- 所有方法都可以用 `T::method_name(..)` 的形式调用
- 方法也可以用 `x.method_name(..)` 的形式调用，假设 `x` 的类型是 `T`，这种写法等价于 `T::method_name(x, ..)`
- 用 `fn method_name(self : T, ..)` 形式声明的方法可以像普通函数一样直接用 `method_name(..)` 的形式调用

之前的章节中已经出现了很多方法，例如 `Array::make(..)` 和 `array.length()`。

关于方法的两种定义方式的不同之处是什么，应该如何选择：

- `fn method_name(self : T, ..)` 声明的方法就是一个普通的顶层函数，所以它可以像普通函数一样直接调用。但这也意味着它不能和其他函数重名。如果一个方法是给它所在的包的一个比较主要的类型定义的，并且不会和其他函数重名，则推荐用 `fn method_name(self : T, ..)` 的形式定义它，这样用户调用时可以省去 `T::`
- `fn T::method_name(..)` 声明的方法会被放到 `T` 这个小命名空间里，所以这种方法只能用 `T::method_name(..)` 或者 `x.method_name(..)` 的方式调用。但相应的，这种方法可以和普通函数以及其他类型的方法重名。所以，这种定义方式可以用来解决名字冲突或简化包的顶层作用域。


================================================
File 241: /data/input/moonbit-docs/moonbit-tour/tour/zh/index.mbt
================================================
fn main {
  println("hello")
}

================================================
File 242: /data/input/moonbit-docs/moonbit-tour/tour/zh/index.md
================================================
# 欢迎来到 MoonBit 语言之旅！💫

本次教程涵盖了 MoonBit 语言的所有方面，需要您具备一定的编程基础。它将教您编写 MoonBit 实际程序所需的一切。

本次教程是互动的！显示的代码是可编辑的，并在您输入时实时编译和评估。使用 `println` 打印的任何内容都将显示在底部部分。为了评估 MoonBit 代码，本次教程将 MoonBit 编译为 wasm gc 并运行，整个过程全部在您的浏览器窗口内完成。

如果您遇到困难或有问题，欢迎随时在 MoonBit Discord 服务器上提问。我们非常乐意为您提供帮助，如果您对某些内容感到困惑，那么很可能其他人也会有同样的困惑，我们希望了解这些问题以改进本次教程。

好了，让我们开始吧。点击“下一步”开始，或点击“目录”跳转到特定主题。



================================================
File 243: /data/input/moonbit-docs/next/README-zh.md
================================================
# Next gen moonbit-docs

查看[README.md](./README.md) 获取英文版本。

基于 Sphinx 的新一代 MoonBit 文档框架。

## 开发指南

### 安装

- 对于 Python 环境，可以在 VSCode 中执行 `> Python: Create Environment` 命令，为 `next` 项目使用 `requirement.txt` 创建环境，或者：

  ```bash
  python3 -m venv .env
  source .env/bin/activate
  pip install -r requirements.txt
  ```

- 使用 Latex 构建 PDF 时，需要安装 `latexmk`：
  - MacOS:
    - 安装 [Mactex](https://www.tug.org/mactex/)
    - 使用 TeX Live Utility 安装 `latexmk`

### 开发

在 VSCode 中执行 `Watch Document` 任务，或者：

```bash
sphinx-autobuild . ./_build/html
# 或者 sphinx-autobuild -D language='zh_CN' . ./_build/html
```

### 构建

在 VSCode 中执行 `Build Document` 任务，或者：

```bash
make html
python3 -m http.server -d _build/html
```

对于中文版本：

```bash
LANGUAGE="zh_CN" make html
python3 -m http.server -d _build/html
```

对于 PDF：

```bash
make latexpdf
open ./_build/latex/moonbitdocument.pdf
```

对于 Markdown：

```bash
pip install sphinx-markdown-builder
make markdown
```

### 更新翻译模板

在 VSCode 中执行 `Translate Document` 任务，或者：

```bash
make gettext
sphinx-intl update -p _build/gettext -l zh_CN
```

================================================
File 244: /data/input/moonbit-docs/next/README.md
================================================
# Next gen moonbit-docs

view [README-zh.md](./README-zh.md) for Chinese version.

A new MoonBit docs framework based on Sphinx.

## Develop

### Install

- For Python Environment, execute command `> Python: Create Environment` for `next` using `requirement.txt` in VSCode, or:

  ```bash
  python3 -m venv .env
  source .env/bin/activate
  pip install -r requirements.txt
  ```

- For building PDF using Latex, `latexmk` needs to be installed:
  - MacOS:
    - install [Mactex](https://www.tug.org/mactex/)
    - install `latexmk` using TeX Live Utility

### Development

Execute task `Watch Document` in VSCode, or:

```bash
sphinx-autobuild . ./_build/html
# or sphinx-autobuild -D language='zh_CN' . ./_build/html
```

### Build

Execute task `Build Document` in VSCode, or:

```bash
make html
python3 -m http.server -d _build/html
```

For Chinese version:

```bash
LANGUAGE="zh_CN" make html
python3 -m http.server -d _build/html
```

For PDF:

```bash
make latexpdf
open ./_build/latex/moonbitdocument.pdf
```

For Markdown:

```bash
pip install sphinx-markdown-builder
make markdown
```

### Update translation template

Execute task `Translate Document` in VSCode, or:

```bash
make gettext
sphinx-intl update -p _build/gettext -l zh_CN
```

================================================
File 245: /data/input/moonbit-docs/next/example/gmachine/gmachine-1.md
================================================
# G-Machine 1

This article is the first in the series on implementing lazy evaluation in MoonBit. In this article, we will exploring the purposes of lazy evaluation and a typical abstract machine for lazy evaluation, the G-Machine.

## Higher-Order Functions and Performance Challenges

Higher-order functions such as `map` and `filter` often serve as many people's first impression of functional programming (although it goes far beyond these functions). They simplify many list processing tasks, but another problem emerges: nesting these higher-order functions too deep can lead to poor performance (because it requires multiple traversals of the list).

To enhance code efficiency, some propose leveraging compiler optimizations based on recurring patterns within higher-order functions. For instance, by rewriting `map(f, map(g, list))` as：

```
map(fn (x) { f(g(x)) }, list)
```

Nice try, but it's important to recognize that such optimization techniques have inherent limitations, particularly when navigating more complex scenarios. Consolidating all processes into a single function might circumvent the need for repeated list traversals, yet it detrimentally affects code readability and complicates the process of making modifications. Could there be a more equitable solution that balances efficiency with maintainability?

Lazy evaluation is a technique that can reduce unnecessary costs to some extent in such scenarios. This strategy can be integrated into specific data structures (for example, the Stream type added in Java 8, and the stream in the earlier Scheme language), or the entire language can be designed to be lazy (successful examples include the Miranda language of the 1980s and later by Haskell and Clean languages).

Let's first explore how lazy lists (`Stream`) can avoid multiple traversals in such cases.

```{note}
The `List[T]` here is a `typealias` of `@immut/list.T[T]`
```

## Lazy List Implementation

First, let's define its type:

```moonbit
enum Stream[T] {
  Empty
  Cons(T, () -> Stream[T])
}
```

The only real difference between `Stream[T]` and `List[T]` is in the `Cons`: the place holding the rest of the list is replaced with a parameterless function (in jargon, called a thunk). This is a simple implementation of lazy evaluation: wrapping things you don't want to compute right away in a thunk.

We also need a function to convert a regular list into a lazy list:

```moonbit
fn Stream::from_list[T](l : List[T]) -> Stream[T] {
  match l {
    Nil => Empty
    Cons(x, xs) => Cons(x, fn () { Stream::from_list(xs) })
  }
}
```

This function does not need to traverse the entire list to convert it into `Stream`. For operations that are not urgent (here, `Stream::from_list(xs)`), we wrap them directly in a thunk and return. The following `map` function will adopt this approach (though here, `xs` is already a thunk).

```moonbit
fn map[X, Y](self : Stream[X], f : (X) -> Y) -> Stream[Y] {
  match self {
    Empty => Empty
    Cons(x, xs) => Cons(f(x), fn () { xs().map(f) })
  }
}
```

The `take` function is responsible for performing computations, and it can extract n elements as needed.

```moonbit
fn take[T](self : Stream[T], n : Int) -> List[T] {
  if n == 0 {
    Nil
  } else {
    match self {
      Empty => Nil
      Cons(x, xs) => Cons(x, xs().take(n - 1))
    }
  }
}
```

The implementation of lazy data structures using thunks is straightforward and effectively addresses the problems mentioned above. This method requires users to explicitly indicate where in the code computation should be delayed, whereas the strategy of lazy languages is much more aggressive: it defaults to using lazy evaluation for all user-defined functions! In the following sections, we will present a minimal implementation of a lazy functional language and briefly introduce its underlying theoretical model.

## A Lazy Evaluation Language and Its Abstract Syntax Tree

The example used in this article is a lazy evaluation language, deliberately made to resemble Clojure (a Lisp dialect) and named coreF. This design choice allows for the use of Clojure's syntax highlighting in markdown. Don't worry, though the syntax might seem a bit complex at first, it is straightforward enough.

Functions are defined using the `defn` keyword:

```clojure
(defn factorial[n] ;; n is the parameter, this function calculates the factorial of n
  (if (eq n 0) ;; The definition starts here and continues for the next three lines
    1
    (mul n (factorial (sub n 1)))))
```

Referring to it as a function in general conversation is acceptable. However, when discussing lazy functional languages, we must introduce a specialized term: _Super Combinator_. In the definition of a super combinator, all free variables should be included in an initial pair of `[]`.

Execution of a coreF program begins with `main`, calling a specific super combinator as if replacing it with its definition.

```clojure
(defn main[] (factorial 42))
```

Super combinators without parameters, such as `main`, are referred to by a specific term: _Constant Applicative Forms (CAF)_.

coreF also possesses several language features, including custom data structures, `case` expressions for dismantling structures, and `let` and `letrec` for the declaration of local variables. However, the scope of this article is limited to the aforementioned features (actually, even less, as built-in functions like `eq`, `mul`, `sub`, etc., are planned for future implementation).

coreF excludes anonymous functions because anonymous functions introduce extra free variables. Removing them requires an additional transformation step: lambda lifting. This technique can transform a lambda expression into an external Super Combinator, but this is not a main point of lazy evaluation, hence its omission here.

Super combinators will eventually be parsed into `ScDef[String]`, but writing a parser is a tedious task. I will provide it along with the final code.

```{literalinclude} /sources/gmachine/src/part1/ast.mbt
:language: moonbit
:start-after: start expr_and_scdef definition
:end-before: end expr_and_scdef definition
```

Additionally, some predefined coreF programs are required.

```{literalinclude} /sources/gmachine/src/part1/ast.mbt
:language: moonbit
:start-after: start prelude_defs definition
:end-before: end prelude_defs definition
```

## Why Graph

In the coreF language, expressions (not `RawExpr[T]` mentioned earlier, but runtime expressions) are stored in memory in the form of a graph rather than a tree when being evaluated.)

Why is this approach taken? Let's examine this through a program example:

```clojure
(defn square[x]  (mul x x))
(defn main[] (square (square 3)))
```

If we evaluate according to the conventional expression tree, it would be reduced to:

```clojure
(mul (square 3) (square 3))
```

In this case, `(square 3)` would be evaluated twice, which is certainly not desirable for lazy evaluation.

To illustrate this more clearly, let's make a somewhat improper analogy using MoonBit code:

```moonbit
fn square(thunk : () -> Int) -> Int {
  thunk() * thunk()
}
```

To represent the program using a graph is to facilitate sharing of computation results and avoid redundant calculations. To achieve this purpose, it's crucial to implement an in-place update algorithm when reducing the graph. Regarding in-place update, let's simulate it using MoonBit code:

```{literalinclude} /sources/gmachine/src/part1/lazy.mbt
:language: moonbit
:start-after: start lazy definition
:end-before: end lazy definition
```

Regardless of which side executes the `extract` method first, it will update the referenced mutable field and replace its content with the computed result. Therefore, there's no need to recompute it during the second execution of the `extract` method.

## Conventions

Before delving into how graph reduction works, let's establish some key terms and basic facts. We'll continue using the same program as an example:

```clojure
(defn square[x]  (mul x x)) ;; multiplication
(defn main[] (square (square 3)))
```

- Built-in primitives like `mul` are predefined operations.

* Evaluating an expression (of course, lazy) and updating its corresponding node in the graph in place is called reduction.
* `(square 3)` is a reducible expression (often abbreviated as redex), consisting of `square` and its argument. It can be reduced to `(mul 3 3)`. `(mul 3 3)` is also a redex, but it's a different type of redex compared to `(square 3)` because `square` is a user-defined combinator while `mul` is an implemented built-in primitive.
* The reduction result of `(mul 3 3)` is the expression `9`, which cannot be further reduced. Such expressions that cannot be further reduced are called Normal forms.
* An expression may contain multiple sub-expressions (e.g., `(mul (add 3 5) (mul 7 9))`). In such cases, the order of reduction of expressions is crucial – some programs only halt under specific reduction orders.

- There's a special reduction order that always selects the outermost redex for reduction, known as _normal order reduction_. This reduction order will be uniformly adopted in the following discussion.

So, the graph reduction can be described with the following pseudocode:

```
While there exist reducible expressions in the graph {
    Select the outermost reducible expression.
    Reduce the expression.
    Update the graph with the result of reduction.
}
```

Dizzy now? Let's find a few examples to demonstrate how to perform reductions on paper.

### Step 1: Find the next redex

The execution of the entire program starts from the `main` function.

```clojure
(defn square[x]  (mul x x))
(defn main[] (add 33 (square 3)))
```

`main` itself is a CAF - the simplest kind of redex. If we perform the substitution, the current expression to be handled is:

```clojure
(add 33 (square 3))
```

According to the principle of finding the outermost redex, it seems like we've immediately found the redex formed by `add` and its two parameters (let's assume it for now).

But wait! Due to the presence of default currying, the abstract syntax tree corresponding to this expression is actually composed of multiple nested `App` nodes. It roughly looks like this (simplified for readability):

```moonbit
App(App(add, 33), App(square, 3))
```

This chain-like structure from `add` to the outermost `App` node is called the "Spine"

Going back to check, `add` is an internally defined primitive. However, since its second argument `(square 3)` is not in normal form, we cannot reduce it (adding an unevaluated expression to an integer seems a bit absurd). So, we can't definitively say that `(add 33 (square 3))` is a redex; it's just the outermost function application. To reduce it, we must first reduce `(square 3)`.

### Step 2: Reduce

Since `square` is a user-defined super combinator, reducing `(square 3)` involves only parameter substitution.

If a redex has fewer arguments than required by the super combinator, which is common in higher-order functions, it becomes a `weak head normal form` (often abbreviated as WHNF). In this situation, even if its sub-expressions contain redexes, no action is needed. Consider the example of tripling all integers in a list.

```clojure
(map (mul 3) list-of-int)
```

Here, `(mul 3)` cannot be treated as a redex because it lacks sufficient arguments.

### Step 3: Update

This step only affects execution efficiency and can be skipped during paper deductions.

These operations are easy to perform on paper (when the amount of code doesn't exceed half a sheet), but when we switch to computers, how do we translate these steps into executable code?

To answer this question, pioneers in the world of lazy evaluation programming languages have proposed various **abstract machines** for modeling lazy evaluation. These include:

- G-Machine
- Three Instruction Machine
- ABC Machine (used by the Clean language)
- Spineless Tagless G-Machine (abbreviated as STG, used by Haskell language)

They are execution models used to guide compiler implementations. It's important to note that, unlike various popular virtual machines today (such as the JVM), abstract machines are more like intermediate representations (IR) for compilers. Taking Haskell's compiler GHC as an example, after generating STG code, it doesn't directly pass it to an interpreter for execution. Instead, it further transforms it into LLVM, C code, or machine code based on the selected backend.

To simplify implementation, this article will directly use MoonBit to write an interpreter for G-Machine instructions, starting from a minimal example and gradually adding more features.

## G-Machine Overview

While the G-Machine is an abstract machine for lazy functional languages, its structure and concepts are not significantly different from what one encounters when writing general imperative languages. It also features structures like heap and stack, and its instructions are executed sequentially. Some key differences include:

- The basic unit of memory in the heap is not bytes, but graph nodes.
- The stack only contains pointers to addresses in the heap, not actual data.

> This design may not be practical, but it's relatively simple.

In coreF, super combinators are compiled into a series of G-Machine instructions. These instructions can be roughly categorized as follows:

- Access Data Instructions, For example, `PushArg` (access function arguments), and `PushGlobal` (access other super combinators).
- Construct/update graph nodes in the heap, like `MkApp`, `PushInt`, `Update`
- The `Pop` instruction to cleanup the unused addresses from the stack.
- The `Unwind` instruction to express the control flow.

## Dissecting the G-Machine State

In this simple version of the G-Machine, the state includes:

- Heap: This is where the expression graph and the sequences of instructions corresponding to super combinators are stored.

  ```{literalinclude} /sources/gmachine/src/part1/vm.mbt
  :language: moonbit
  :start-after: start heap definition
  :end-before: end heap definition
  ```

- Stack: The stack only holds addresses pointing to the heap. A simple implementation can use `List[Addr]`.
- Global Table: It's a mapping table that records the names of super combinators (including predefined and user-defined) and their corresponding addresses as `NGlobal` nodes. Here I implement it using a Robin Hood hash table.
- Current code sequence to be executed.
- Execution status statistics: A simple implementation involves calculating how many instructions have been executed.

The entire state is represented using the type `GState`.

```{literalinclude} /sources/gmachine/src/part1/vm.mbt
:language: moonbit
:start-after: start state definition
:end-before: end state definition
```

Now, we can map each step of the graph reduction algorithm we deduced on paper to this abstract machine:

- At the initial state of the machine, all compiled super combinators have been placed in `NGlobal` nodes on the heap. At this point, the current code sequence in the G-Machine contains only two instructions. The first instruction pushes the address of the `main` node onto the stack, and the second instruction loads the corresponding code sequence of `main` into the current code sequence.
- The corresponding code sequence of `main` is instantiated on the heap, where nodes are allocated and data is loaded accordingly, ultimately constructing a graph in memory. This process is referred to as "instantiating" `main`. Once instantiation is complete, the address of the entry point of this graph is pushed onto the stack.
- After instantiation is finished, cleanup work is done, which involves updating graph nodes (since `main` has no parameters, there is no need to clean up residual unused addresses in the stack) and finding the next redex.

All of these tasks have corresponding instruction implementations.

## Corresponding Effect of Each Instruction

The highly simplified G-Machine currently consists of 7 instructions.

```{literalinclude} /sources/gmachine/src/part1/instruction.mbt
:language: moonbit
:start-after: start instr definition
:end-before: end instr definition
```

The `PushInt` instruction is the simplest. It allocates an `NNum` node on the heap and pushes its address onto the stack.

```{literalinclude} /sources/gmachine/src/part1/vm.mbt
:language: moonbit
:start-after: start push_int definition
:end-before: end push_int definition
```

The `PushGlobal` instruction retrieves the address of the specified super combinator from the global table and then pushes the address onto the stack.

```{literalinclude} /sources/gmachine/src/part1/vm.mbt
:language: moonbit
:start-after: start push_global definition
:end-before: end push_global definition
```

The `PushArg` instruction is a bit more complex. It has specific requirements regarding the layout of addresses on the stack: the first address should point to the super combinator node, followed by n addresses pointing to N `NApp` nodes. `PushArg` retrieves the Nth parameter, starting from the `offset + 1`.

```{literalinclude} /sources/gmachine/src/part1/vm.mbt
:language: moonbit
:start-after: start push_arg definition
:end-before: end push_arg definition
```

The `MkApp` instruction takes two addresses from the top of the stack, constructs an `NApp` node, and pushes its address onto the stack.

```{literalinclude} /sources/gmachine/src/part1/vm.mbt
:language: moonbit
:start-after: start mk_apply definition
:end-before: end mk_apply definition
```

The `Update` instruction assumes that the first address on the stack points to the current redex's evaluation result. It skips the addresses of the immediately following super combinator nodes and replaces the Nth `NApp` node with an indirect node pointing to the evaluation result. If the current redex is a CAF, it directly replaces its corresponding `NGlobal` node on the heap. From this, we can see why in lazy functional languages, there is not much distinction between functions without parameters and ordinary variables.

```{literalinclude} /sources/gmachine/src/part1/vm.mbt
:language: moonbit
:start-after: start update definition
:end-before: end update definition
```

The `Unwind` instruction in the G-Machine is akin to an evaluation loop. It has several branching conditions based on the type of node corresponding to the address at the top of the stack:

- For `Nnum` nodes: Do nothing.
- For `NApp` nodes: Push the address of the left node onto the stack and `Unwind` again.
- For `NGlobal` nodes: If there are enough parameters on the stack, load this super combinator into the current code.
- For `NInd` nodes: Push the address contained within this indirect node onto the stack and Unwind again.

```{literalinclude} /sources/gmachine/src/part1/vm.mbt
:language: moonbit
:start-after: start unwind definition
:end-before: end unwind definition
```

The `Pop` instruction pops N addresses, eliminating the need for a separate function implementation.

## Compiling Super Combinators into Instruction Sequences

In the G-Machine Overview section, we roughly described the behavior of compiled super combinators. Now we can precisely describe the compilation process of super combinators.

Firstly, before the instruction sequence of a compiled super combinator is executed, there must be certain addresses already present in the stack:

- The topmost address points to an `NGlobal` node (the super combinator itself).
- Following are N addresses (N being the number of parameters for this super combinator), pointing to a series of App nodes - corresponding exactly to the spine of a redex. The bottommost address in the stack points to the outermost App node of the expression, and the rest follow suit.

When compiling a super combinator, we need to maintain an environment that allows us to find the relative position of parameters in the stack during the compilation process by their names. Additionally, since clearing the preceding N+1 addresses is necessary after completing the instantiation of a super combinator, the number of parameters N needs to be passed as well.

> Here, "parameters" refer to addresses pointing to App nodes on the heap, and the actual parameter addresses can be accessed through the `PushArg` instruction.

```{literalinclude} /sources/gmachine/src/part1/compile.mbt
:language: moonbit
:start-after: start compile_sc definition
:end-before: end compile_sc definition
```

The `compileR` function generates code for instantiating super combinators by calling the `compileC` function, and then appends three instructions:

- `Update(N)`: Updates the original redex in the heap to an `NInd` node, which then points to the newly instantiated super combinator.
- `Pop(N)`: Clears the stack of redundant addresses.
- `Unwind`: Searches for the next redex to start the next reduction.

```{literalinclude} /sources/gmachine/src/part1/compile.mbt
:language: moonbit
:start-after: start compile_r definition
:end-before: end compile_r definition
```

When compiling the definition of super combinators, a rather crude approach is used: if a variable is not a parameter, it is treated as another super combinator (writing it incorrectly will result in a runtime error). For function application, the right-hand expression is compiled first, then all offsets corresponding to parameters in the environment are incremented (because an extra address pointing to the instantiated right-hand expression is added to the top of the stack), then the left-hand expression is compiled, and finally the `MkApp` instruction is added.

```{literalinclude} /sources/gmachine/src/part1/compile.mbt
:language: moonbit
:start-after: start compile_c definition
:end-before: end compile_c definition
```

## Running the G-Machine

Once the super combinators are compiled, they need to be placed on the heap (along with adding their addresses to the global table). This can be done recursively.

```{literalinclude} /sources/gmachine/src/part1/vm.mbt
:language: moonbit
:start-after: start build_ih definition
:end-before: end build_ih definition
```

Define a function "step" that updates the state of the G-Machine by one step, returning false if the final state has been reached.

```{literalinclude} /sources/gmachine/src/part1/vm.mbt
:language: moonbit
:start-after: start step definition
:end-before: end step definition
```

Additionally, define a function "reify" that continuously executes the "step" function until the final state is reached.

```{literalinclude} /sources/gmachine/src/part1/vm.mbt
:language: moonbit
:start-after: start reify definition
:end-before: end reify definition
```

Combine the above components.

```{literalinclude} /sources/gmachine/src/part1/top.mbt
:language: moonbit
:start-after: start run definition
:end-before: end run definition
```

## Conclusion

The features of the G-Machine we've constructed so far are too limited to run even a somewhat decent program. In the next article, we will incrementally add features such as primitives and custom data structures. Towards the end, we'll introduce lazy evaluation techniques after covering the G-Machine.

## Reference

Peyton Jones, Simon & Lester, David. (2000). Implementing functional languages: a tutorial.


================================================
File 246: /data/input/moonbit-docs/next/example/gmachine/gmachine-2.md
================================================
# G-Machine 2

This article is the second in the series on implementing lazy evaluation in MoonBit. In the first part, we explored the purposes of lazy evaluation and a typical abstract machine for lazy evaluation, the G-Machine, and implemented some basic G-Machine instructions. In this article, we will further extend the G-Machine implementation from the previous article to support `let` expressions and basic arithmetic, comparison, and other operations.

## let Expressions

The `let` expression in coref differs slightly from that in MoonBit. A `let` expression can create multiple variables but can only be used within a limited scope. Here is an example:

```moonbit
{
  let x = n + m
  let y = x + 42
  x * y
}
```

Equivalent coref expression:

```clojure
(let ([x (add n m)]
      [y (add x 42)])
  (mul x y)) ;; xy can only be used within let
```

It is important to note that coref's `let` expressions must follow a sequential order. For example, the following is not valid:

```clojure
(let ([y (add x 42)]
      [x (add n m)])
  (mul x y))
```

In contrast, `letrec` is more complex as it allows the local variables defined to reference each other without considering the order of their definitions.

Before implementing `let` (and the more complex `letrec`), we first need to modify the current parameter passing method. The local variables created by `let` should intuitively be accessed in the same way as parameters, but the local variables defined by `let` do not correspond to `NApp` nodes. Therefore, we need to adjust the stack parameters before calling the supercombinator.

The adjustment is done in the implementation of the `Unwind` instruction. If the supercombinator has no parameters, it is the same as the original unwind. When there are parameters, the top address of the supercombinator node is discarded, and the `rearrange` function is called.

```{literalinclude} /sources/gmachine/src/part2/vm.mbt
:language: moonbit
:start-after: start rearrange definition
:end-before: end rearrange definition
```

The `rearrange` function assumes that the first N addresses on the stack point to a series of `NApp` nodes. It keeps the bottommost one (used as Redex update), cleans up the top N-1 addresses, and then places N addresses that directly point to the parameters.

After this, both parameters and local variables can be accessed using the same command by changing the `PushArg` instruction to a more general `Push` instruction.

```{literalinclude} /sources/gmachine/src/part2/vm.mbt
:language: moonbit
:start-after: start push definition
:end-before: end push definition
```

The next issue is that we need something to clean up. Consider the following expression:

```clojure
(let ([x1 e1]
      [x2 e2])
  expr)
```

After constructing the graph corresponding to the expression `expr`, the stack still contains addresses pointing to e1 and e2 (corresponding to variables x1 and x2), as shown below (the stack grows from bottom to top):

```
<Address pointing to expr>
       |
<Address pointing to x2>
       |
<Address pointing to x1>
       |
...remaining stack...
```

Therefore, we need a new instruction to clean up these no longer needed addresses. It is called `Slide`. As the name suggests, the function of `Slide(n)` is to skip the first address and delete the following N addresses.

```{literalinclude} /sources/gmachine/src/part2/vm.mbt
:language: moonbit
:start-after: start slide definition
:end-before: end slide definition
```

Now we can compile `let`. We will compile the expressions corresponding to local variables using the `compileC` function. Then, traverse the list of variable definitions (`defs`), compile and update the corresponding offsets in order. Finally, use the passed `comp` function to compile the main expression and add the `Slide` instruction to clean up the unused addresses.

> Compiling the main expression using the passed function makes it easy to reuse when adding subsequent features.

```{literalinclude} /sources/gmachine/src/part2/compile.mbt
:language: moonbit
:start-after: start compile_let definition
:end-before: end compile_let definition
```

The semantics of `letrec` are more complex - it allows the N variables within the expression to reference each other, so we need to pre-allocate N addresses and place them on the stack. We need a new instruction: `Alloc(N)`, which pre-allocates N `NInd` nodes and pushes the addresses onto the stack sequentially. The addresses in these indirect nodes are negative and only serve as placeholders.

```{literalinclude} /sources/gmachine/src/part2/vm.mbt
:language: moonbit
:start-after: start alloc definition
:end-before: end alloc definition
```

The steps to compile letrec are similar to `let`:

- Use `Alloc(n)` to allocate N addresses.
- Use the `loop` expression to build a complete environment.
- Compile the local variables in `defs`, using the `Update` instruction to update the results to the pre-allocated addresses after compiling each one.
- Compile the main expression and use the `Slide` instruction to clean up.

```{literalinclude} /sources/gmachine/src/part2/compile.mbt
:language: moonbit
:start-after: start compile_letrec definition
:end-before: end compile_letrec definition
```

## Adding Primitives

From this step, we can finally perform basic integer operations such as arithmetic, comparison, and checking if two numbers are equal. First, modify the `Instruction` type to add related instructions.

```rust
  Add
  Sub
  Mul
  Div
  Neg
  Eq // ==
  Ne // !=
  Lt // <
  Le // <=
  Gt // >
  Ge // >=
  Cond(List[Instruction], List[Instruction])
```

At first glance, implementing these instructions seems simple. Take `Add` as an example: just pop two top addresses from the stack, retrieve the corresponding numbers from memory, perform the operation, and push the result address back onto the stack.

```rust
fn add(self : GState) -> Unit {
  let (a1, a2) = self.pop2() // Pop two top addresses
  match (self.heap[a1], self.heap[a2]) {
    (NNum(n1), NNum(n2)) => {
      let newnode = Node::NNum(n1 + n2)
      let addr = self.heap.alloc(newnode)
      self.putStack(addr)
    }
    ......
  }
}
```

However, the next problem we face is that this is a lazy evaluation language. The parameters of `add` are likely not yet computed (i.e., not `NNum` nodes). We also need an instruction that can force a computation to give a result or never stop computing. We call it `Eval` (short for Evaluation).

> In jargon, the result of such a computation is called Weak Head Normal Form (WHNF).

At the same time, we need to modify the structure of `GState` and add a state called `dump`. Its type is `List[(List[Instruction], List[Addr])]`, used by `Eval` and `Unwind` instructions.

The implementation of the `Eval` instruction is not complicated:

- Pop the top address of the stack.

- Save the current unexecuted instruction sequence and stack (by putting them into the dump).

- Clear the current stack and place the previously saved address.

- Clear the current instruction sequence and place the `Unwind` instruction.

> This is similar to how strict evaluation languages handle saving caller contexts, but practical implementations would use more efficient methods.

```{literalinclude} /sources/gmachine/src/part2/vm.mbt
:language: moonbit
:start-after: start eval definition
:end-before: end eval definition
```

This simple definition requires modifying the `Unwind` instruction to restore the context when `Unwind` in the `NNum` branch finds that there is a recoverable context (`dump` is not empty).

```{literalinclude} /sources/gmachine/src/part2/vm.mbt
:language: moonbit
:start-after: start unwind definition
:end-before: end unwind definition
```

Next, we need to implement arithmetic and comparison instructions. We use two functions to simplify the form of binary operations. The result of the comparison instruction is a boolean value, and for simplicity, we use numbers to represent it: 0 for `false`, 1 for `true`.

```{literalinclude} /sources/gmachine/src/part2/vm.mbt
:language: moonbit
:start-after: start op definition
:end-before: end op definition
```

Finally, implement branching:

```{literalinclude} /sources/gmachine/src/part2/vm.mbt
:language: moonbit
:start-after: start cond definition
:end-before: end cond definition
```

No major adjustments are needed in the compilation part, just add some predefined programs:

```{literalinclude} /sources/gmachine/src/part2/compile.mbt
:language: moonbit
:start-after: start prim definition
:end-before: end prim definition
```

and modify the initial instruction sequence

```{literalinclude} /sources/gmachine/src/part2/top.mbt
:language: moonbit
:dedent:
:start-after: start init definition
:end-before: end init definition
```

## Conclusion

In the next part, we will improve the code generation for primitives and add support for data structures.


================================================
File 247: /data/input/moonbit-docs/next/example/gmachine/gmachine-3.md
================================================
# G-Machine 3

This article is the third in a series on implementing Haskell's lazy evaluation in MoonBit. In the previous article, we learned how to compile `let` expressions and how to implement basic arithmetic and comparison operations. In this article, we will implement a context-based optimization method and add support for data structures.

## Tracking Context

Let's review how we implemented primitives in the [last tutorial](gmachine-2.md).

```{literalinclude} /sources/gmachine/src/part2/compile.mbt
:language: moonbit
:start-after: start prim definition
:end-before: end prim definition
```

This implementation introduces many `Eval` instructions, but they are not always necessary. For example:

```clojure
(add 3 (mul 4 5))
```

The two arguments of `add` are already in WHNF (Weak Head Normal Form) before executing `Eval`. Therefore, the `Eval` instructions here are redundant.

One feasible optimization method is to consider the context when compiling expressions. For example, `add` requires its arguments to be evaluated to WHNF, so its arguments are in a strict context during compilation. By doing this, we can identify some expressions that can be safely compiled with strict evaluation (only a subset).

- An expression in a supercombinator definition is in a strict context.

- If `(op e1 e2)` is in a strict context (where `op` is a primitive), then `e1` and `e2` are also in a strict context.

- If `(let (.....) e)` is in a strict context, then `e` is also in a strict context (but the expressions corresponding to the local variables are not, as `e` may not need their results).

We use the `compileE` function to implement compilation in a strict context, ensuring that _the value at the top of the stack is always in WHNF_.

For the default branch, we simply add an `Eval` instruction after the result of `compileC`.

```{literalinclude} /sources/gmachine/src/part3/compile.mbt
:language: moonbit
:dedent:
:start-after: start default definition
:end-before: end default definition
```

Constants are pushed directly.

```{literalinclude} /sources/gmachine/src/part3/compile.mbt
:language: moonbit
:dedent:
:start-after: start num definition
:end-before: end num definition
```

For `let/letrec` expressions, the specially designed `compileLet` and `compileLetrec` become useful. Compiling a `let/letrec` expression in a strict context only requires using `compileE` to compile its main expression.

```{literalinclude} /sources/gmachine/src/part3/compile.mbt
:language: moonbit
:dedent:
:start-after: start let definition
:end-before: end let definition
```

The `if` and `negate` functions, with 3 and 1 arguments respectively, require special handling.

```{literalinclude} /sources/gmachine/src/part3/compile.mbt
:language: moonbit
:dedent:
:start-after: start if_and_neg definition
:end-before: end if_and_neg definition
```

Basic binary operations can be handled uniformly through a lookup table. First, construct a hash table called `builtinOpS` to query the corresponding instructions by the name of the primitive.

```{literalinclude} /sources/gmachine/src/part3/compile.mbt
:language: moonbit
:start-after: start builtin definition
:end-before: end builtin definition
```

The rest of the handling is not much different.

```{literalinclude} /sources/gmachine/src/part3/compile.mbt
:language: moonbit
:dedent:
:start-after: start binop definition
:end-before: end binop definition
```

Are we done? It seems so, but there's another WHNF besides integers: partially applied functions.

A partial application is when the number of arguments is insufficient. This situation is common in higher-order functions, for example:

```clojure
(map (add 1) listofnumbers)
```

Here, `(add 1)` is a partial application.

To ensure that the code generated by the new compilation strategy works correctly, we need to modify the implementation of the `Unwind` instruction for the `NGlobal` branch. When the number of arguments is insufficient and the dump has saved stacks, we should only retain the original redex and restore the stack.

```{literalinclude} /sources/gmachine/src/part3/vm.mbt
:language: moonbit
:dedent:
:start-after: start unwind_g definition
:end-before: end unwind_g definition
```

This context-based strictness analysis technique is useful but cannot do anything with supercombinator calls. Here we briefly introduce a strictness analysis technique based on boolean operations, which can analyze which arguments of a supercombinator call should be compiled using strict mode.

We first define a concept: bottom, which conceptually represents a value that never terminates or causes an exception. For a supercombinator `f a[1] ...... a[n]`, if one argument `a[i]` satisfies `a[i] = bottom`, then `f a[1] .... a[i] .... a[n] = bottom` (other arguments are not bottom). This indicates that no matter how complex the internal control flow of `f` is, it **must** need the result of argument `a[i]` to get the final result. Therefore, a`[i]` should be strictly evaluated.

> If this condition is not met, it does not necessarily mean that the argument is not needed at all; it may be used only in certain branches and its use is determined at runtime. Such an argument is a typical example of one that should be lazily evaluated.

Let's consider bottom as `false` and non-bottom values as `true`. In this way, all functions in coref can be considered boolean functions. Take `abs` as an example:

```clojure
(defn abs[n]
  (if (lt n 0) (negate n) n))
```

We analyze how to translate it into a boolean function from top to bottom:

- For an expression like `(if x y z)`, x must be evaluated, but only one of `y` or `z` needs to be evaluated. This can be translated into `x and (y or z)`. Taking the example of the function above, if `n` is bottom, then the condition `(lt n 0)` is also bottom, and thus the result of the entire expression is also bottom.

- For primitive expressions, using `and` for all parts is sufficient.

To determine whether a parameter needs to be compiled strictly, you can convert the above condition into a Boolean function: `a[i] = false` implies `f a[1] .... a[i] .... a[n] = false` (with all other parameters being true).

> This is essentially a method of program analysis called "abstract interpretation."

## Custom Data Structures

The data structure type definition in Haskell is similar to the `enum` in MoonBit. However, since CoreF is a simple toy language used to demonstrate lazy evaluation, it does not allow custom data types. The only built-in data structure is the lazy list.

```clojure
(defn take[n l]
  (case l
    [(Nil) Nil]
    [(Cons x xs)
      (if (le n 0)
        Nil
        (Cons x (take (sub n 1) xs)))]))
```

As shown above, you can use the `case` expression for simple pattern matching on lists.

The corresponding graph node for a list is `NConstr(Int, List[Addr])`, which consists of two parts:

- A tag for different value constructors: the tag for `Nil` is 0, and the tag for `Cons` is 1.
- A list of addresses for storing substructures, whose length corresponds to the number of parameters (arity) of a value constructor.

> This graph node structure can be used to implement various data structures, but CoreF does not have a type system. For demonstration purposes, only lazy lists are implemented.

We need to add two instructions, `Split` and `Pack`, to deconstruct and construct lists.

```{literalinclude} /sources/gmachine/src/part3/vm.mbt
:language: moonbit
:dedent:
:start-after: start split_pack definition
:end-before: end split_pack definition
```

Additionally, a `CaseJump` instruction is needed to implement the `case` expression.

```{literalinclude} /sources/gmachine/src/part3/vm.mbt
:language: moonbit
:start-after: start casejump definition
:end-before: end casejump definition
```

After adding the above instructions, we need to modify the `compileC` and `compileE` functions. Since the object matched by the `case` expression needs to be evaluated to WHNF, only the `compileE` function can compile it.

```{literalinclude} /sources/gmachine/src/part3/compile.mbt
:language: moonbit
:dedent:
:start-after: start c_constr definition
:end-before: end c_constr definition
```

```{literalinclude} /sources/gmachine/src/part3/compile.mbt
:language: moonbit
:dedent:
:start-after: start e_constr_case definition
:end-before: end e_constr_case definition
```

At this point, a new problem arises. Previously, printing the evaluation result only needed to handle simple `NNum` nodes, but `NConstr` nodes have substructures. When the list itself is evaluated to WHNF, its substructures are mostly unevaluated `NApp` nodes. We need to add a `Print` instruction, which will recursively evaluate and write the result into the `output` component of `GState`.

```{literalinclude} /sources/gmachine/src/part3/vm.mbt
:language: moonbit
:start-after: start gprint definition
:end-before: end gprint definition
```

Finally, change the initial code of the G-Machine to:

```{literalinclude} /sources/gmachine/src/part3/top.mbt
:language: moonbit
:dedent:
:start-after: start init definition
:end-before: end init definition
```

Now, we can write some classic functional programs using lazy lists, such as the infinite Fibonacci sequence:

```clojure
(defn fibs[] (Cons 0 (Cons 1 (zipWith add fibs (tail fibs)))))
```

After introducing data structures, strictness analysis becomes more complex. For lazy lists, there are various evaluation modes:

- Fully strict (requires the list to be finite and all elements to be non-bottom).
- Fully lazy.
- Head strict (the list can be infinite, but its elements cannot be bottom).
- Tail strict (the list must be finite, but its elements can be bottom).

Moreover, the context in which a function is used can change the evaluation mode of its parameters (it cannot be analyzed in isolation and requires cross-function analysis). Such complex strictness analysis usually employs projection analysis techniques. Relevant literature includes:

- Projections for Strictness Analysis

- Static Analysis and Code Optimizations in Glasgow Haskell Compiler

- Implementing Projection-based Strictness Analysis

- Theory and Practice of Demand Analysis in Haskell

## Epilogue

Lazy evaluation can reduce runtime redundant calculations, but it also introduces new problems, such as:

- The notorious side effect order issue.

- Excessive redundant nodes. Some computations that are not shared still store their results on the heap, which is detrimental to utilizing the CPU's caching mechanism.

The representative of lazy evaluation languages, Haskell, offers a controversial solution to the side effect order problem: Monads. This solution has some value for eagerly evaluated languages as well, but many online tutorials emphasize its mathematical background too much and fail to explain how to use it effectively.

Idris2, Haskell's successor (which is no longer a lazy language), retains Monads and introduces another mechanism for handling side effects: Algebraic Effects.

The Spineless G-Machine designed by SPJ improved the problem of excessive redundant nodes, and its successor, the STG, unified the data layout of different types of nodes.

In addition to improvements in abstract machine models, GHC's optimization of Haskell programs heavily relies on inline-based optimizations and projection analysis-based strictness analysis techniques.

In 2004, several GHC designers discovered that the previous push-enter model, where parameters are pushed onto the stack and then a function is called, was less effective than the eval-apply model, where the responsibility is handed to the caller. They published a paper titled "Making a Fast Curry: Push/Enter vs. Eval/Apply for Higher-order Languages."

In 2007, Simon Marlow found that jump and execute code in the tagless design significantly affected the performance of modern CPU branch predictors. The paper "_Faster laziness using dynamic pointer tagging_" described several solutions.

Lazy purely functional languages have shown many interesting possibilities, but they have also faced much criticism and reflection. Nevertheless, it is undoubtedly an intriguing technology!


================================================
File 248: /data/input/moonbit-docs/next/example/gmachine/index.md
================================================
# G-Machine

Lazy evaluation stands as a foundational concept in the realm of programming languages. Haskell, renowned as a purely functional programming language, boasts a robust lazy evaluation mechanism. This mechanism not only empowers developers to craft code that's both more efficient and concise but also enhances program performance and responsiveness, especially when tackling sizable datasets or intricate data streams. 

In this article, we'll delve into the Lazy Evaluation mechanism, thoroughly examining its principles and implementation methods, and then explore how to implement Haskell's evaluation semantics in [MoonBit](https://www.moonbitlang.com/).

```{toctree}
:maxdepth: 2
:caption: Contents:
gmachine-1
gmachine-2
gmachine-3

================================================
File 249: /data/input/moonbit-docs/next/example/index.md
================================================
# Examples

Here are some examples built with MoonBit.

```{only} html
[Download this section in Markdown](path:/download/example/summary.md)
```

```{toctree}
:maxdepth: 2
:caption: Contents:
sudoku/index
lambda/index
gmachine/index
myers-diff/index
segment-tree/index

================================================
File 250: /data/input/moonbit-docs/next/example/lambda/index.md
================================================
# Lambda calculus

Functional programming rises with the fall of Moore's Law. The full utilization of multi-core processors has become an increasingly important optimization method, while functional programming also becomes more popularized with its affinity for parallel computation. The reasons behind this trend can be traced back to one of its theoretical ancestors—Lambda calculus.

Lambda calculus originated from the 1930s. Created by Turing's mentor Alonzo Church, formal systems have now evolved a vast and flourishing family tree. This article will illustrate one of its most fundamental forms: untyped Lambda calculus (which was also one of the earliest forms proposed by Alonzo Church).

## Basic rules of untyped Lambda calculus

The only actions allowed in untyped Lambda calculus are defining Lambdas (often referred to as Abstraction) and calling Lambdas (often referred to as Application). These actions constitute the basic expressions in Lambda calculus.

Most programmers are no strange to the name "Lambda expression" as most mainstream programming languages are hugely influenced by functional language paradigm. Lambdas in untyped Lambda calculus are simpler than those in mainstream programming languages. A Lambda typically looks like this: `λx.x x`, where `x` is its parameter (each Lambda can only have one parameter), `.` is the separator between the parameter and the expression defining it, and `x x` is its definition.

```{note}
Some materials may omit spaces, so the above example can be rewritten as `λx.xx`.
```

If we replace `x x` with `x(x)`, it might be more in line with the function calls we see in general languages. However, in the more common notation of Lambda calculus, calling a Lambda only requires a space between it and its parameter. Here, we call the parameter given by `x`, which is `x` itself.

The combination of the above two expressions and the variables introduced when defining Lambdas are collectively referred to as the Lambda term. In MoonBit, we use an enum type to represent it:

```{literalinclude} /sources/lambda-expression/src/top.mbt
:language: moonbit
:start-at: enum Term
:end-at: }
```

Concepts encountered in daily programming such as boolean values, if expressions, natural number arithmetic, and even recursion can all be implemented using Lambda expressions. However, this is not the focus of this article.

```{seealso}
Interested readers can refer to: [Programming with Nothing](https://tomstu.art/programming-with-nothing)
```

To implement an interpreter for untyped Lambda calculus, the basic things we need to understand are just two rules: Alpha conversion and Beta reduction.

**Alpha conversion** describes the fact that the structure of Lambda is crucial, and the names of variables are not that important. `λx.x` and `λfoo.foo` can be interchanged. For certain nested Lambdas with repeated variable names, such as `λx.(λx.x) x`, when renaming, the inner variables cannot be renamed. For example, the above example can be rewritten using Alpha conversion as `λy.(λx.x) y`.

**Beta reduction** focuses on handling Lambda calls. Let's take an example:

```
(λx.(λy.x)) (λs.(λz.z))
```

In untyped Lambda calculus, all that needs to be done after calling a Lambda is to substitute the parameter. In the example above, we need to replace the variable `x` with `(λs.(λz.z))`, resulting in:

```
(λy.(λs.(λz.z)))
```

## Free Variables and Variable Capture

If a variable in a Lambda term is not defined in its context, we call it a free variable. For example, in the Lambda term `(λx.(λy.fgv h))`, the variables `fgv` and `h` do not have corresponding Lambda definitions.

During Beta reduction, if the Lambda term used for variable substitution contains free variables, it may lead to a behavior called "variable capture":

```
(λx.(λy.x)) (λz.y)
```

After substitution:

```
λy.λz.y
```

The free variable in `λz.y` is treated as a parameter of some Lambda, which is obviously not what we want.

A common solution to the variable capture problem when writing interpreters is to traverse the expression before substitution to obtain a set of free variables. When encountering an inner Lambda during substitution, check if the variable name is in this set of free variables:

<!-- Pseudo code. MANUAL CHECK -->

```moonbit
// (λx.E) T => E.subst(x, T)
fn subst(self : Term, var : String, term : Term) -> Term {
  let freeVars : Set[String] = term.get_free_vars()
  match self {
    Abs(variable, body) => {
      if freeVars.contains(variable) {
        // The variable name is in the set of free variables 
        // of the current inner Lambda, indicating variable capture
        abort("subst(): error while encountering \{variable}")
      } else {
        ...
      }
    }
    ...
  }
}
```

Next, I'll introduce a less popular but somewhat convenient method: de Bruijn index.

## De Bruijn Index

De Bruijn index is a technique for representing variables in Lambda terms using integers. Specifically, it replaces specific variables with Lambdas between the variable and its original imported position.

```
λx.(λy.x (λz.z z))

λ.(λ.1 (λ.0 0))
```

In the example above, there is one Lambda `λy` between the variable `x` and its introduction position `λx`, so `x` is replaced with `1`. For variable `z`, there are no other Lambdas between its introduction position and its usage, so it is directly replaced with `0`. In a sense, the value of the de Bruijn index describes the relative distance between the variable and its corresponding Lambda. Here, the distance is measured by the number of nested Lambdas.

```{note}
The same variable may be replaced with different integers in different positions.
```

We define a new type `TermDBI` to represent Lambda terms using de Bruijn indices:

```{literalinclude} /sources/lambda-expression/src/top.mbt
:language: moonbit
:start-at: enum TermDBI
:end-at: }
```

However, directly writing and reading Lambda terms in de Bruijn index form is painful, so we need to write a function `bruijn()` to convert `Term` to `TermDBI`. This is also why there is still a `String` in the definition of the `TermDBI` type, so that the original variable name can be used for its `Show` implementation, making it easy to print and view the evaluation results with `println`.

```{literalinclude} /sources/lambda-expression/src/top.mbt
:language: moonbit
:start-at: impl Show for TermDBI
:end-at: App(t1, t2)
:append: "  }\n}"
```

To simplify implementation, if the input `Term` contains free variables, the `bruijn()` function will report an error directly. MoonBit provides a `Result[V, E]` type in the standard library, which has two constructors, `Ok(V)` and `Err(E)`, representing success and failure in computation, respectively.

```{hint}
Readers familiar with Rust should find this familiar.
```

<!-- MANUAL CHECK -->
```moonbit
fn bruijn(self : Term) -> Result[TermDBI, String]
```

We take a clumsy approach to save variable names and their associated nesting depth. First, we define the `Index` type:

```{literalinclude} /sources/lambda-expression/src/top.mbt
:language: moonbit
:start-at: struct Index
:end-at: }
```

Then we write a helper function to find the corresponding `depth` based on a specific `name` from `@immut/list.T[Index]`:

```{literalinclude} /sources/lambda-expression/src/top.mbt
:language: moonbit
:dedent:
:start-at: // Find
:end-before: fn go
```

Now we can complete the `bruijn()` function.

- Handling `Var` is the simplest, just look up the table to find the corresponding `depth`.
- `Abs` is a bit more complicated. First, add one to the `depth` of all `index` in the list (because the Lambda nesting depth has increased by one), and then add `{ name : varname, depth : 0 }` to the beginning of the list.
- `App` succeeds when both sub-items can be converted; otherwise, it returns an `Err`.

```{literalinclude} /sources/lambda-expression/src/top.mbt
:language: moonbit
:start-at: fn go
:end-at: go(Nil, self)
:dedent:
```

## Reduce on TermDBI

Reduction mainly deals with App, i.e., calls:

```{literalinclude} /sources/lambda-expression/src/top.mbt
:language: moonbit
:start-at: fn eval
:end-before: test
```

First, attempt reduction on both sub-items, then see if `eval(t1)` results in a Lambda. If so, perform one step of variable substitution (via the `subst` function) and then continue simplifying. For Lambdas (`Abs`), simply return them as they are.

The implementation of the `subst` function becomes much simpler when we don't need to consider free variables. We just need to keep track of the current depth recursively and compare it with the encountered variables. If they match, it's the variable to be replaced.

```{literalinclude} /sources/lambda-expression/src/top.mbt
:language: moonbit
:start-at: fn subst
:end-before: fn eval
```

The full code: [GitHub repository](https://github.com/moonbitlang/moonbit-docs/tree/main/next/sources/lambda-expression/src/top.mbt)

## Improvement

When mapping variable names to indices, we used the `@immut/list.T[Index]` type and updated the entire list every time we added a new Lambda. However, this is actually quite a clumsy method. I believe you can quickly realize that to store a `@immut/list.T[String]` should simply suffice. If you're interested, you can try it yourself.


================================================
File 251: /data/input/moonbit-docs/next/example/myers-diff/index.md
================================================
# Myers Diff

```{toctree}
:maxdepth: 2
:caption: Contents:
myers-diff
myers-diff2
myers-diff3

================================================
File 252: /data/input/moonbit-docs/next/example/myers-diff/myers-diff.md
================================================
# Myers diff

Have you ever used the Unix tool `diff`? In short, it is a tool for comparing the differences between two text files. What's more, Unix has a tool called `patch`.

Nowadays, few people manually apply patches to software packages, but `diff` still retains its usefulness in another area: version control systems. It's quite handy to have the function of being able to see what changes have been made to source code files after a particular commit (and highlighted with different colors). Take the most popular version control system today, git, as an example:

```diff
diff --git a/main/main.mbt b/main/main.mbt
index 99f4c4c..52b1388 100644
--- a/main/main.mbt
+++ b/main/main.mbt
@@ -3,7 +3,7 @@

 fn main {
   let a = lines("A\nB\nC\nA\nB\nB\nA")
-  let b = lines("C\nB\nA\nB\nA\nC")
+  let b = lines("C\nB\nA\nB\nA\nA")
   let r = shortst_edit(a, b)
   println(r)
 }
```

But how exactly do we calculate the differences between two text files?

git's default diff algorithm was proposed by _Eugene W. Myers_ in his paper **An O(ND) Difference Algorithm and Its Variations**. This paper mainly focuses on proving the correctness of the algorithm. In the following text, we will understand the basic framework of this algorithm in a less rigorous way and use MoonBit to write a simple implementation.

## Defining "Difference" and Its Measurement Criteria

When we talk about the "difference" between two text files, what we are actually referring to is a series of editing steps that can transform text a into text b.

Assume the content of text a is

```
A
B
C
A
B
B
A
```

Assume the content of text b is

```
C
B
A
B
A
C
```

To transform text a into text b, the simplest edit sequence is to delete each character in a (indicated with a minus sign) and then insert each character in b (indicated with a plus sign).

```diff
- A
- B
- C
- A
- B
- B
- A
+ C
+ B
+ A
+ B
+ A
+ C
```

But such a result might not be very helpful for programmers reading the code. The following edit sequence is much better, at least it is shorter.

```diff
- A
- B
  C
+ B
  A
  B
- B
  A
+ C
```

In fact, it is one of the shortest edit sequences that can transform text a into text b, with 5 operations. If we only measure the length of the edit sequence, this result is satisfactory. But when we look at the various programming languages, we find that there are other metrics that are equally important for user experience. Let's look at the following examples:

```diff
// good quality
  struct RHSet[T] {
    set : RHTable[T, Unit]
  }
+
+ fn RHSet::new[T](capacity : Int) -> RHSet[T] {
+  let set : RHTable[T, Unit]= RHTable::new(capacity)
+  { set : set }
+ }


// bad quality
  struct RHSet[T] {
    set : RHTable[T, Unit]
+ }
+
+ fn RHSet::new[T](capacity : Int) -> RHSet[T] {
+  let set : RHTable[T, Unit]= RHTable::new(capacity)
+  { set : set }
  }
```

When we insert a new function definition at the end of a file, the calculated edit sequence should ideally locate the changes at the end. In similar cases, when there are both deletions and insertions, it is best not to calculate an edit sequence that interleaves these two operations. Here's another example.

```
Good:   - one         Bad:    - one
        - two                 + four
        - three               - two
        + four                + five
        + five                + six
        + six                 - three
```

Myers' diff algorithm can fulfill all those requirements. It is a greedy algorithm that skips over matching lines whenever possible (avoiding inserting text before `{`), and it also tries to place deletions before insertions, avoiding the latter situation.

## Algorithm Overview

The basic idea in Myers' paper is to construct a grid graph of edit sequences and then search for the shortest path on this graph. Using the previous example `a = ABCABBA` and `b = CBABAC`, we create an `(x, y)` coordinate grid.

```
    0     1     2     3     4     5     6     7

0   o-----o-----o-----o-----o-----o-----o-----o
    |     |     | \   |     |     |     |     |
    |     |     |  \  |     |     |     |     |   C
    |     |     |   \ |     |     |     |     |
1   o-----o-----o-----o-----o-----o-----o-----o
    |     | \   |     |     | \   | \   |     |
    |     |  \  |     |     |  \  |  \  |     |   B
    |     |   \ |     |     |   \ |   \ |     |
2   o-----o-----o-----o-----o-----o-----o-----o
    | \   |     |     | \   |     |     | \   |
    |  \  |     |     |  \  |     |     |  \  |   A
    |   \ |     |     |   \ |     |     |   \ |
3   o-----o-----o-----o-----o-----o-----o-----o
    |     | \   |     |     | \   | \   |     |
    |     |  \  |     |     |  \  |  \  |     |   B
    |     |   \ |     |     |   \ |   \ |     |
4   o-----o-----o-----o-----o-----o-----o-----o
    | \   |     |     | \   |     |     | \   |
    |  \  |     |     |  \  |     |     |  \  |   A
    |   \ |     |     |   \ |     |     |   \ |
5   o-----o-----o-----o-----o-----o-----o-----o
    |     |     | \   |     |     |     |     |
    |     |     |  \  |     |     |     |     |   C
    |     |     |   \ |     |     |     |     |
6   o-----o-----o-----o-----o-----o-----o-----o


       A     B     C     A     B     B     A
```

The upper left of this grid is the starting point `(0, 0)`, and the lower right is the endpoint `(7, 6)`. Moving one step right along the x-axis deletes the corresponding character in a, moving one step down along the y-axis inserts the corresponding character in b, and diagonal lines indicate matching characters that can be skipped without triggering any edits.

Before writing the actual search code, let's manually perform two rounds of searching:

- The first round starts at `(0, 0)` and moves one step to reach `(0,1)` and `(1,0)`.

- The second round starts at `(0,1)` and `(1,0)`. From `(0,1)`, moving down reaches `(0,2)`, but there is a diagonal line leading to `(1,3)`, so the final point is `(1,3)`.

The entire Myers algorithm is based on this kind of breadth-first search.

## Implementation

We have outlined the basic idea, now it's time to consider the design in detail. The input to the algorithm is two strings, but the search needs to be conducted on a graph. It's a waste of both memory and time to construct the graph and then search it.

The implementation of the Myers algorithm adopts a clever approach by defining a new coordinate `k = x - y`.

- Moving right increases `k` by one.

- Moving left decreases `k` by one.

- Moving diagonally down-left keeps `k` unchanged.

Let's define another coordinate `d` to represent the depth of the search. Using `d` as the horizontal axis and `k` as the vertical axis, we can draw a tree diagram of the search process.

```
    |      0     1     2     3     4     5
----+--------------------------------------
    |
 4  |                             7,3
    |                           /
 3  |                       5,2
    |                     /
 2  |                 3,1         7,5
    |               /     \     /     \
 1  |           1,0         5,4         7,6
    |         /     \           \
 0  |     0,0         2,2         5,5
    |         \                       \
-1  |           0,1         4,5         5,6
    |               \     /     \
-2  |                 2,4         4,6
    |                     \
-3  |                       3,6
```

You can see that in each round of searching, `k` is strictly within the range `[-d, d]` (because in one move, it can at most increase or decrease by one from the previous round), and the `k` values between points have an interval of 2. The basic idea of Myers' algorithm comes from this idea: searching by iterating over `d` and `k`. Of course, it also needs to save the `x` coordinates of each round for use in the next round of searching.

Let's first define the `Line` struct, which represents a line in the text.

```{literalinclude} /sources/diff/src/part1/line.mbt
:language: moonbit
:start-after: start line definition
:end-before: end line definition
```

Then, define a helper function that splits a string into `Array[Line]` based on newline characters. Note that line numbers start from 1.

```{literalinclude} /sources/diff/src/part1/line.mbt
:language: moonbit
:start-after: start lines definition
:end-before: end lines definition
```

Next, we need to wrap the array so that it supports negative indexing because we will use the value of `k` as an index.

```{literalinclude} /sources/diff/src/part1/bparray.mbt
:language: moonbit
:start-after: start bparray definition
:end-before: end bparray definition
```

Now we can start writing the search function. Before searching for the complete path, let's start with our first goal to find the length of the shortest path (equal to the search depth). Here is the basic framework:

<!-- MANUAL CHECK -->
```moonbit
fn shortest_edit(old~ : Array[Line], new~ : Array[Line]) -> Int {
  let n = old.length()
  let m = new.length()
  let max = n + m
  let v = BPArray::make(2 * max + 1, 0)
  for d = 0; d < max + 1; d = d + 1 {
    for k = -d; k < d + 1; k = k + 2 {
    ......
    }
  }
}
```

In the most extreme case (the two texts have no matching lines), it can be inferred that the maximum number of steps needed is `n + m`, and the minimum is 0. Therefore, set the variable `max = n + m`. The array `v` uses `k` as an index to store the historical record of `x` values. Since `k` ranges from `[-d, d]`, the size of this array is set to `2 * max + 1`.

But even at this point, it is still difficult to figure out what to do next, so let's only consider the case `d = 0; k = 0` for now. At this point, it must be at `(0, 0)`. Also, if the beginnings of the two texts are the same, they can be skipped directly. We write the final coordinates of this round into the array `v`.

<!-- MANUAL CHECK -->
```moonbit
if d == 0 { // When d equals 0, k must also equal 0
  x = 0
  y = x - k
  while x < n && y < m && old[x].text == new[y].text {
    // Skip all matching lines
    x = x + 1
    y = y + 1
  }
  v[k] = x
}
```

When `d > 0`, the coordinate information stored from the previous round is required. When we know the `k` value of a point and the coordinates of the points from the previous round of searching, the value of `v[k]` is easy to deduce. Because with each step k can only increase or decrease by one, `v[k]` in the search tree must extend from either `v[k - 1]` or `v[k + 1]`. The next question is: how to choose between the two paths ending at `v[k - 1]` and `v[k + 1]`?

There are two boundary cases: `k == -d` and `k == d`.

- When `k == -d`, you can only choose `v[k + 1]`.

- When `k == d`, you can only choose `v[k - 1]`.

Recalling the requirement mentioned earlier: arranging deletions before insertions as much as possible, this essentially means choosing the position with the largest `x` value from the previous position.

<!-- MANUAL CHECK -->
```moonbit
if k == -d {
  x = v[k + 1]
} else if k == d {
  x = v[k - 1] + 1 // add 1 to move horizontally
} else if v[k - 1] < v[k + 1] {
  x = v[k + 1]
} else {
  x = v[k - 1] + 1
}
```

Merging these four branches, we get the following code:

<!-- MANUAL CHECK -->
```moonbit
if k == -d || (k != d && v[k - 1] < v[k + 1]) {
  x = v[k + 1]
} else {
  x = v[k - 1] + 1
}
```

Combining all the steps above, we get the following code:

```{literalinclude} /sources/diff/src/part1/diff.mbt
:language: moonbit
:start-after: start shortest_edit definition
:end-before: end shortest_edit definition
```

Since the initial value of the array is 0, we can omit the branch for `d == 0`.

## Epilogue

We have implemented an incomplete version of Myers' algorithm, which completes the forward path search. In the next article, we will implement the backtracking to restore the complete edit path and write a function to output a colored diff.

This article references:

- [https://blog.jcoglan.com/2017/02/15/the-myers-diff-algorithm-part-2/](https://blog.jcoglan.com/2017/02/15/the-myers-diff-algorithm-part-2/)

Thanks to the author James Coglan.


================================================
File 253: /data/input/moonbit-docs/next/example/myers-diff/myers-diff2.md
================================================
# Myers diff 2

This is the second post in the diff series. In the [previous one](https://www.moonbitlang.com/docs/examples/myers-diff), we learned how to transform the process of computing diffs into a graph search problem and how to search for the shortest edit distance. In this article, we will learn how to extend the search process from the previous post to obtain the complete edit sequence.

## Recording the Search Process

The first step to obtaining the complete edit sequence is to save the entire editing process. This step is relatively simple; we just need to save the current search depth `d` and the graph node with depth `d` at the beginning of each search round.

```{literalinclude} /sources/diff/src/part2/diff.mbt
:language: moonbit
:start-after: start shortest_edit definition
:end-before: end shortest_edit definition
```

## Backtracking the Edit Path

After recording the entire search process, the next step is to walk back from the endpoint to find the path taken. But before we do that, let's first define the `Edit` type.

```{literalinclude} /sources/diff/src/part2/edit.mbt
:language: moonbit
:start-after: start edit definition
:end-before: end edit definition
```

Next, let's perform the backtracking.

```{literalinclude} /sources/diff/src/part2/diff.mbt
:language: moonbit
:start-after: start backtrack_fst definition
:end-before: end backtrack_fst definition
```

The method of backtracking is essentially the same as forward search, just in reverse.

- Calculate the current `k` value using `x` and `y`.

- Access the historical records and use the same judgment criteria as in forward search to find the `k` value at the previous search round.

- Restore the coordinates of the previous search round.

- Try free movement and record the corresponding edit actions.

- Determine the type of edit that caused the change in `k` value.

- Continue iterating.

```{literalinclude} /sources/diff/src/part2/diff.mbt
:language: moonbit
:dedent:
:start-after: start backtrack_snd definition
:end-before: end backtrack_snd definition
```

Combining the two functions, we get a complete `diff` implementation.

```{literalinclude} /sources/diff/src/part2/diff.mbt
:language: moonbit
:start-after: start diff definition
:end-before: end diff definition
```

## Printing the Diff

To print a neat diff, we need to left-align the text. Also, due to the order issue during backtracking, we need to print from back to front.

```{literalinclude} /sources/diff/src/part2/edit.mbt
:language: moonbit
:start-after: start pprint definition
:end-before: end pprint definition
```

The result is as follows:

```diff
-    1         A
-    2         B
     3    1    C
+         2    B
     4    3    A
     5    4    B
-    6         B
     7    5    A
+         6    C
```

## Conclusion

The Myers algorithm demonstrated above is complete, but due to the frequent copying of arrays, it has a very large space overhead. Therefore, most software like Git uses a linear variant of the diff algorithm (found in the appendix of the original paper). This variant may sometimes produce diffs of lower quality (harder for humans to read) than the standard Myers algorithm but can still ensure the shortest edit sequence.


================================================
File 254: /data/input/moonbit-docs/next/example/myers-diff/myers-diff3.md
================================================
# Myers diff 3

This article is the third in the [diff series](https://docs.moonbitlang.com/examples/myers-diff). In the [previous part](https://docs.moonbitlang.com/examples/myers-diff2), we explored the full Myers algorithm and its limitations. In this post, we'll learn how to implement a variant of the Myers algorithm that operates with linear space complexity.

## Divide and Conquer

The linear variant of Myers' diff algorithm used by Git employs a concept called the _Snake_ (sometimes referred to as the _Middle Snake_) to break down the entire search process. A Snake in the edit graph represents a diagonal movement of 0 to N steps after a single left or down move. The linear Myers algorithm finds the middle Snake on the optimal edit path and uses it to divide the entire edit graph into two parts. The subsequent steps apply the same technique to the resulting subgraphs, eventually producing a complete edit path.

```bash
    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14
 0  o---o---o---o---o---o---o
    |   |   |   |   |   |   |
 1  o---o---o---o---o---o---o
    |   | \ |   |   |   |   |
 2  o---o---o---o---o---o---o
    |   |   |   |   |   |   |
 3  o---o---o---o---o---o---o
    |   |   |   |   | \ |   |
 4  o---o---o---o---o---o---o
    |   |   |   |   |   |   |
 5  o---o---o---o---o---o---o
                              \
 6                              @
                                  \
 7                                  @---o---o---o---o---o---o
                                        |   |   |   |   |   |
 8                                      o---o---o---o---o---o
                                        | \ |   |   |   |   |
 9                                      o---o---o---o---o---o
                                        |   |   |   |   |   |
10                                      o---o---o---o---o---o
                                        |   |   |   |   |   |
11                                      o---o---o---o---o---o
                                        |   |   | \ |   |   |
12                                      o---o---o---o---o---o
                                        |   |   |   |   |   |
13                                      o---o---o---o---o---o
                                        |   |   |   |   | \ |
14                                      o---o---o---o---o---o
```

> A quick recap: The optimal edit path is the one that has the shortest distance to the endpoint (a diagonal distance of zero), and there can be more than one such path.

Attentive readers may have noticed a chicken-and-egg problem: to find a Snake, you need an optimal edit path, but to get an optimal edit path, it seems like you need to run the original Myers algorithm first.

In fact, the idea behind the linear Myers algorithm is somewhat unconventional: it alternates the original Myers algorithm from both the top-left and bottom-right corners, but without storing the history. Instead, it simply checks if the searches from both sides overlap. When they do, the overlapping portion is returned as the Middle Snake.

This approach seems straightforward, but there are still some details to sort out.

When searching from the bottom-right, the diagonal coordinate can no longer be referred to as _k_. We need to define a new diagonal coordinate **c = k - delta**. This coordinate is the mirror image of _k_, perfectly suited for reverse direction search.

```bash
        x                       k
                                  0     1     2     3
        0     1     2     3         \     \     \     \
  y  0  o-----o-----o-----o           o-----o-----o-----o
        |     |     |     |      -1   |     |     |     | \
        |     |     |     |         \ |     |     |     |   2
     1  o-----o-----o-----o           o-----o-----o-----o
        |     | \   |     |      -2   |     | \   |     | \
        |     |   \ |     |         \ |     |   \ |     |   1
     2  o-----o-----o-----o           o-----o-----o-----o
                                        \     \     \     \
                                        -3    -2    -1      0
                                                              c
```

How do we determine if the searches overlap? Simply check if the position on a diagonal line in the forward search has an _x_ value greater than that in the reverse search. However, since the _k_ and _c_ coordinates differ for the same diagonal, the conversion can be a bit tricky.

### Code Implementation

We'll start by defining `Snake` and `Box` types, representing the middle snake and the sub-edit graphs (since they're square, we call them `Box`).

```{literalinclude} /sources/diff/src/part3/diff.mbt
:language: moonbit
:start-after: start box definition
:end-before: end box definition
```

To avoid getting bogged down in details too early, let's assume we already have a function `midpoint : (Box, Array[Line], Array[Line]) -> Snake?` to find the middle snake. Then, we can build the function `find_path` to search for the complete path.

```{literalinclude} /sources/diff/src/part3/diff.mbt
:language: moonbit
:start-after: start findpath definition
:end-before: end findpath definition
```

The implementation of `find_path` is straightforward, but `midpoint` is a bit more complex:

- For a `Box` of size 0, return `None`.
- Calculate the search boundaries. Since forward and backward searches each cover half the distance, divide by two. However, if the size of the `Box` is odd, add one more to the forward search boundary.
- Store the results of the forward and backward searches in two arrays.
- Alternate between forward and backward searches, returning `None` if no result is found.

```{literalinclude} /sources/diff/src/part3/diff.mbt
:language: moonbit
:start-after: start midpoint definition
:end-before: end midpoint definition
```

The forward and backward searches have some modifications compared to the original Myers algorithm, which need a bit of explanation:

- Since we need to return the snake, the search process must calculate the previous coordinate (`px` stands for previous x).
- The search now works within a `Box` (not the global edit graph), so calculating `y` from `x` (or vice versa) requires conversion.
- The backward search minimizes `y` as a heuristic strategy, but minimizing `x` would also work.

```{literalinclude} /sources/diff/src/part3/diff.mbt
:language: moonbit
:start-after: start search definition
:end-before: end search definition
```

## Conclusion

In addition to the default diff algorithm, Git also offers another diff algorithm called patience diff. It differs significantly from Myers diff in approach and sometimes produces more readable diff results.


================================================
File 255: /data/input/moonbit-docs/next/example/segment-tree/index.md
================================================
# Segment Tree

The Segment Tree is a common data structure used to solve various range modification and query problems. For instance, consider the following problem:

- Given a known-length array of numbers with initial values, we need to perform multiple range addition operations (adding a value to all elements in a range) and range sum operations (calculating the sum of elements in a range).

Using a standard array, assuming the length og this array is N, each modification and query would take O(N) time. However, after constructing a Segment Tree in O(log N) time, both operations can be performed in O(log N), highlighting the importance of Segment Trees for range queries.

This example illustrates just one simple problem that Segment Trees can address. They can handle much more complex and interesting scenarios. In the upcoming articles, we will explore the concept of Segment Trees and how to implement them in MoonBit, ultimately creating a tree that supports range addition and multiplication, enables range sum queries, and has immutable properties.

In this section, we will learn the basic principles of Segment Trees and how to write a simple Segment Tree in MoonBit that supports point modifications and queries.

```{toctree}
:maxdepth: 2
:caption: Contents:
:hidden:
segment-tree
segment-tree2

================================================
File 256: /data/input/moonbit-docs/next/example/segment-tree/segment-tree.md
================================================
# Segment Trees (Part 1)

## What is a Segment Tree?

This section focuses on concepts and theory. If you're already familiar with Segment Trees and their principles, feel free to skip to the next section.

As mentioned in the introduction, Segment Trees address a class of range problems, but what do they look like, and what is the principle behind their excellent complexity?

Let's consider a linear sequence of numbers as an example. If we want to build a Segment Tree from it, it will look like this:

![build segment tree](/imgs/segment-tree-build.png)

We can see that we recursively divide the linear sequence into two equal parts (with one side having an extra element if the length is odd) until we reach segments of length one. During this process, we compute the sum of each segment (shown in parentheses), thereby creating a Segment Tree that supports range sum queries from a linear sequence.

So, how does it work when querying a range sum? Let's take the example of querying the sum from index 1 to 6:

![query segment tree](/imgs/segment-tree-query.png)

The highlighted parts in the diagram sum up to the total for the range 1-6, and we didn't have to consider all elements; we simply selected the minimum number of segments needed to obtain our result and combined them. We can traverse the Segment Tree from top to bottom to determine the intersections and containment relationships between segments to select the appropriate ranges.

Specifically:

- First, we check the relationship between the ranges 1-7 and 1-6. The latter is a subset of the former, so the data from 1-7 cannot be used in our calculation, and we proceed to explore its two child nodes.
- Next, we check the relationship between 1-3 and 1-6. The former is a subset of the latter, contributing to our result.
- Then, we examine the relationship between 4-7 and 1-6, which overlap, requiring us to explore both child nodes further.
- And we examine the relationship between 4-5 and 1-6, just as the third step.
- We repeat this process...

Based on binary decomposition, we will query at most Log N segments for any range of length N, ensuring guaranteed complexity.

This section only discusses the query operation; we will elaborate on the principles and implementation of modification operations in the next section.

## Implementation

### Basic Definition

We use a classic approach to represent the Segment Tree:

```{literalinclude} /sources/segment-tree/src/part1/top.mbt
:language: moonbit
:start-after: start node definition
:end-before: end node definition
```

Here, `Nil` represents an empty tree, while a `Node` contains the stored data (of type Int) and its left and right children.

### Building the Tree

Building the tree refers to the process of abstracting a linear sequence into a Segment Tree, commonly referred to as `build`.

To start, we should write an overloaded `op_add` function for the `Node` type to assist with the tree-building process:

```{literalinclude} /sources/segment-tree/src/part1/top.mbt
:language: moonbit
:start-after: start op_add definition
:end-before: end op_add definition
```

With this operation defined, we can easily merge two `Node` instances while maintaining the segment sums, laying the foundation for building the tree. In some descriptions of Segment Trees, this process is also called `pushup`.

We can leverage MoonBit's `ArrayView` feature (known as `slice` in some languages) to recursively build the tree from a segment of a linear structure at a low cost, achieving O(Log N) complexity:

```{literalinclude} /sources/segment-tree/src/part1/top.mbt
:language: moonbit
:start-after: start build definition
:end-before: end build definition
```

Let’s analyze this code:

- If the current length is 1, the segment does not need further subdivision, so we return a leaf node with empty left and right branches.
- Otherwise, we split the segment at the midpoint and recursively build the left and right segments, then merge the results.

This code is concise, highly readable, and optimization-friendly, serving as a great learning paradigm for other data structures.

Now, let's build a tree and test it:

```{literalinclude} /sources/segment-tree/src/part1/top.mbt
:language: moonbit
:start-after: start build test
:end-before: end build test
```

Great! We've successfully built the tree!

### Querying

Next, we need to implement the query function. Since the nodes of our Segment Tree maintain segment sums, we can write a `query` function to retrieve these sums:

```{literalinclude} /sources/segment-tree/src/part1/top.mbt
:language: moonbit
:start-after: start query definition
:end-before: end query definition
:emphasize-lines: 9
```

Here, `l` and `r` represent the currently queried range, while `query_l` and `query_r` denote the range we need to query. Let's break down this implementation:

- If the queried range does not overlap with the current range, it contributes nothing to the result. We define an `empty_node` to represent a zero-contribution node and return it.
- If the current range is a subset of the queried range, it fully contributes to the result, so we return it directly.
- If the current range overlaps with the queried range, we continue searching downwards to find the exact covering ranges, merging the results of the left and right nodes.

#### Before We Continue

Notice the highlighted line. When using the `let` to destructure `Node`, we could be sure that the enum being destructured wasn’t `Nil`. However, the compiler couldn't guarantee this, so we would have received a warning for using:

```moonbit
let Node(x, y) = z
```

Although it didn’t affect execution, it was somewhat misleading. With MoonBit’s newly introduced `guard` statement, we can now handle this better using:

```moonbit
guard let Node(x, y) = z
```

### Q&A

- **Q:** Why use `Node` as the return value? Can't I destructure and sum the values directly?
- **A:** We have defined an addition operation for `Node`. Consider a scenario where we need to maintain not just the sum but also the minimum value of a range. In that case, we can modify the `op_add` logic to maintain the minimum while the `query` function remains unaffected. It ultimately returns a `Node` that can contain all necessary information, so let's stick with using `Node`!

- **Q:** Shouldn't the `empty_node` change in this case?
- **A:** Yes, the `empty_node` ensures that it doesn’t affect the result when added to any other `Node`. It's a zero-contribution node, akin to how 0 contributes nothing in sum operations. For minimum value maintenance, it can represent a value that won't affect the outcome, making the process flexible!

Now, let's test the query process:

```{literalinclude} /sources/segment-tree/src/part1/top.mbt
:language: moonbit
:start-after: start query test
:end-before: end query test
```

The output is `6`.

Fantastic! We've obtained the correct output!

### Code

For the complete code, please check the [GitHub repository](https://github.com/moonbitlang/moonbit-docs/tree/main/next/sources/segment-tree/src/part1/top.mbt).

## Conclusion

Today, we learned how to build and query a simple Segment Tree. In the next lesson, we will explore more complex principles and implementations of Segment Trees. Interested readers can solidify their knowledge and expand on it by implementing the following:

- Try implementing a Segment Tree that maintains multiple pieces of information (e.g., range sum, maximum, and minimum).
- Understand how to implement point query/modification operations for Segment Trees.
- Explore range modification operations for Segment Trees and related Lazy Tags.


================================================
File 257: /data/input/moonbit-docs/next/example/segment-tree/segment-tree2.md
================================================
# Segment Trees (Part 2)

## Introduction

In the previous article, we discussed the basic implementation of a segment tree. That tree only allowed range queries (single-point modifications and queries were also possible), but it couldn't handle range modifications, such as adding a value to all elements in a given range.

In this session, we will deepen the abstraction by introducing the concept of **LazyTag** to handle range modifications, creating a more functional segment tree.

## How to Implement Range Modifications?

First, let's imagine what happens if we add a number to all elements in a range on the segment tree. How would we do this using a straightforward approach?

![add to segment tree](/imgs/segment-tree-add.png)

Take the segment tree from the last lesson as an example. In the figure below, we add 1 to the range [4, 7]. You'll notice that we need to rebuild and maintain all parts of the tree that cover this range, which is too costly.

Is there a better way? Of course! We can use **LazyTag**.

![lazytag](/imgs/segment-tree-lazytag.png)

Consider that instead of modifying every affected part, we mark the smallest covering range with a "+1" tag. Based on the length of the range, we calculate its value and merge it upward. Following the complexity of querying from the last lesson, this operation would be O(log N).

However, there's a problem. While querying ranges like [1, 7] or [4, 7] works fine, what if we query [4, 6]? The minimal covering ranges are [4, 5] and [6, 6], not [4, 7], so our tag doesn't propagate to lower nodes.

Here’s where the **Lazy** aspect of LazyTag comes into play.

![add using lazytag](/imgs/segment-tree-add-lazytag.png)

We define that when querying a node with a tag, the tag is distributed to its child nodes. These child nodes inherit the tag and compute their values based on their length. The following diagram shows the propagation of the tag downward when querying [4, 6].

This "lazy propagation" ensures that each modification is completed in O(log N), while ensuring correct query results.

```{note}
Some may wonder about overlapping tags. However, additive tags like these merge seamlessly without affecting the total sum of a node.
```

Let’s dive into the code!

## Implementation

### Basic Definition

In the previous code, we defined the segment tree using `enum`. However, none of the elements were clearly named, which was manageable when the data size was small. Now, we need to add **Tag** and **Length** attributes, so it makes sense to use labeled arguments in the `enum` definition:

```{literalinclude} /sources/segment-tree/src/part2/top.mbt
:language: moonbit
:start-after: start data definition
:end-before: end data definition
```

This allows for clearer initialization and pattern matching, making the code easier to follow. We've also abstracted the `Data` type, adding a `len` attribute to represent the length of the current range, which is useful for calculating the node's value.

### Building the Tree

Similar to the last lesson, before building the tree, we need to define the addition operations between `Node` types. However, since we’ve abstracted `Data`, we must account for its addition too:

```{literalinclude} /sources/segment-tree/src/part2/top.mbt
:language: moonbit
:start-after: start op_add definition
:end-before: end op_add definition
```

Here, we’ve ignored merging LazyTags for now and set the resulting tag to `Nil` because once a node is reached, its parent’s LazyTag no longer applies.

Now, we can implement the tree-building function:

```{literalinclude} /sources/segment-tree/src/part2/top.mbt
:language: moonbit
:start-after: start build definition
:end-before: end build definition
```

### LazyTag and Range Modifications

We define a node receiving a LazyTag as `apply`. The key logic lies in here: the node receiving the LazyTag may not own a LazyTag, and if it did own one, how do we merge them? And how do we compute the new value of the node based on the LazyTag?

A decent implementation is to define a new addition operation to merge LazyTags, and define an `apply` function for Node to receive it.


```{literalinclude} /sources/segment-tree/src/part2/top.mbt
:language: moonbit
:start-after: start lazytag definition
:end-before: end lazytag definition
```

Here is the core part of this section: compute the correct node's value with the segment's length and the value of LazyTag.

Then how do we implement range modifications?

```{literalinclude} /sources/segment-tree/src/part2/top.mbt
:language: moonbit
:start-after: start modify definition
:end-before: end modify definition
```

The logic is similar to the query function from the previous lesson, but now each relevant node applies the necessary LazyTag for the modification.

When we arrive here, we find that, even with the range modification, it's still a persistent, or **Immutable** segment tree. The `modify` function will return the recently created segment tree, without changing the original one, and the semantics of recurring and merging represent this vividly.

This means that using these kind of implementations (ADT(enum), recursion) for meeting immutable requirements is natural and elegant. With the garbage collection mechanism of MoonBit, we don't need to use pointers **explicitly** for some relationships in recurring ADT(enum), and we don't need to take care of the memory.

Readers unfamiliar with the functional programming languages may not notice this, but we actually always profit from it. For example, writing a `ConsList` in Rust using ADT(enum), we usually need:

```rust
enum List<T> {
    Cons(T, Box<List<T>>),
    Nil,
}
```

But in MoonBit, we only need:

```moonbit
enum List[T] {
  Cons(T, List[T])
  Nil
}
```

GC is really interesting!

### Queries

For queries, we need to remember to push the LazyTag downwards:

```{literalinclude} /sources/segment-tree/src/part2/top.mbt
:language: moonbit
:start-after: start query definition
:end-before: end query definition
```

## Conclusion

With this, we have a segment tree that supports range modifications and is much more functional!

In the next lesson, we’ll add multiplication support to the segment tree and explore some use cases for immutable segment trees. Stay tuned!

Full code is available [here](https://github.com/moonbitlang/moonbit-docs/tree/main/next/sources/segment-tree/src/part2/top.mbt).


================================================
File 258: /data/input/moonbit-docs/next/example/sudoku/index.md
================================================
# Sudoku Solver

Sudoku is a logic-based puzzle game that originated in 1979. It was well-suited for print media like newspapers, and even in the digital age, many Sudoku game programs are available for computers and smartphones. Despite the variety of entertainment options today, Sudoku enthusiasts continue to form active communities (online forum such as: [enjoysudoku](http://forum.enjoysudoku.com/)). This article will demonstrate how to write a suitable program to solve Sudoku using MoonBit.
![sudoku example](/imgs/sudoku.jpg)

## Squares, Units, and Peers

The most common form of Sudoku is played on a 9x9 grid. We label the rows from top to bottom as A-I, and the columns from left to right as 1-9. This gives each square in the grid a coordinate, for example, the square containing the number 0 in the grid below has the coordinate C3.

```
  1 2 3 4 5 6 7 8 9
A . . . . . . . . .
B . . . . . . . . .
C . . 0 . . . . . .
D . . . . . . . . .
E . . . . . . . . .
F . . . . . . . . .
G . . . . . . . . .
H . . . . . . . . .
I . . . . . . . . .
```

This 9x9 grid has a total of 9 units, and each unit contains squares that must have unique digits from 1 to 9. However, in the initial state of the game, most squares do not contain any digits.

```
 4  1  7 | 3  6  9 | 8  2  5
 6  3  2 | 1  5  8 | 9  4  7
 9  5  8 | 7  2  4 | 3  1  6
---------+---------+---------
 8  2  5 | 4  3  7 | 1  6  9
 7  9  1 | 5  8  6 | 4  3  2
 3  4  6 | 9  1  2 | 7  5  8
---------+---------+---------
 2  8  9 | 6  4  3 | 5  7  1
 5  7  3 | 2  9  1 | 6  8  4
 1  6  4 | 8  7  5 | 2  9  3
```

Beyond the units, another important concept is peers. A square's peers include other squares in the same row, column, and unit. For example, the peers of C2 include these squares:

```

    A2   |         |
    B2   |         |
    C2   |         |
---------+---------+---------
    D2   |         |
    E2   |         |
    F2   |         |
---------+---------+---------
    G2   |         |
    H2   |         |
    I2   |         |

         |         |
         |         |
 C1 C2 C3| C4 C5 C6| C7 C8 C9
---------+---------+---------
         |         |
         |         |
         |         |
---------+---------+---------
         |         |
         |         |
         |         |

 A1 A2 A3|         |
 B1 B2 B3|         |
 C1 C2 C3|         |
---------+---------+---------
         |         |
         |         |
         |         |
---------+---------+---------
         |         |
         |         |
         |         |
```

No two squares that are peers can contain the same digit.

We need a data type, SquareMap[T], to store the 81 squares and the information associated with each square. This can be implemented using a hashtable, but using an array would be more compact and simple. First, we write a function to convert coordinates A1-I9 to indices 0-80:

```rust
// A1 => 0, A2 => 1
fn square_to_int(s : String) -> Int {
  if in(s[0], 'A', 'I') && in(s[1], '1', '9') {
    let row = s[0].to_int() - 65 // 'A' <=> 0
    let col = s[1].to_int() - 49 // '1' <=> 0
    return row * 9 + col
  } else {
    abort("square_to_int(): \{s} is not a square")
  }
}

// Helper function `in` checks if a character is between `lw` and `up`
fn in(this : Char, lw : Char, up : Char) -> Bool {
  this >= lw && this <= up
}
```

Then we wrap the array and provide operations for creating, accessing, assigning values to specific coordinates, and copying SquareMap[T]. By overloading the op_get and op_set methods, we can write convenient code like table["A2"] and table["C3"] = Nil.

```rust
struct SquareMap[T] {
  contents : Array[T]
}

fn SquareMap::new[T](val : T) -> SquareMap[T] {
  { contents : Array::make(81, val) }
}

fn copy[T](self : SquareMap[T]) -> SquareMap[T] {
  let arr = Array::make(81, self.contents[0])
  let mut i = 0
  while i < 81 {
    arr[i] = self.contents[i]
    i = i + 1
  }
  return { contents : arr }
}

fn op_get[T](self : SquareMap[T], square : String) -> T {
  self.contents[square_to_int(square)]
}

fn op_set[T](self : SquareMap[T], square : String, x : T) -> Unit {
  self.contents[square_to_int(square)] = x
}
```

Next, we prepare some constants:

```rust
let rows = "ABCDEFGHI"
let cols = "123456789"

// squares contains the coordinates of each square
let squares : List[String] = ......

// units[coord] contains the other squares in the unit of the square at coord
// for example：units["A3"] => [C3, C2, C1, B3, B2, B1, A2, A1]
let units : SquareMap[List[String]] = ......

// peers[coord] contains all the peers of the square at coord
// for example：peers["A3"] => [A1, A2, A4, A5, A6, A7, A8, A9, B1, B2, B3, C1, C2, C3, D3, E3, F3, G3, H3, I3]
let peers : SquareMap[List[String]] = ......
```

The process of constructing the units and peers tables is tedious, so it will not be detailed here.

## Preprocessing the Grid

We use a string to represent the initial Sudoku grid. Various formats are acceptable; both `.` and `0` represent empty squares, and other characters like spaces and newlines are ignored.

```
"4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......"

"
400000805
030000000
000700000
020000060
000080400
000010000
000603070
500200000
104000000"
```

For now, let's not consider game rules too much. If we only consider the digits that can be filled in each square, then 1-9 are all possible. Therefore, we initially set the content of all squares to `['1', '2', '3', '4', '5', '6', '7', '8', '9']` (a List).

```rust
fn parseGrid(s : String) -> SquareMap[List[Char]] {
  let digits = cols.to_list()
  let values : SquareMap[List[Char]] = SquareMap::new(digits)
  ......
}
```

Next, we need to assign values to the squares with known digits from the input. This process can be implemented with the function `assign(values, key, val)`, where `key` is a string like `A6` and `val` is a character. It is easy to write such code.

```rust
fn assign(values : SquareMap[List[Char]], key : String, val : Char) {
  values[key] = Cons(val, Nil)
}
```

Let's run it and see

```
"4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......"

// Using parseGrid and printGrid functions, skipping implementation details for simplicity

 4          123456789  123456789 | 123456789  123456789  123456789 | 8          123456789  5
 123456789  3          123456789 | 123456789  123456789  123456789 | 123456789  123456789  123456789
 123456789  123456789  123456789 | 7          123456789  123456789 | 123456789  123456789  123456789
---------------------------------+---------------------------------+---------------------------------
 123456789  2          123456789 | 123456789  123456789  123456789 | 123456789  6          123456789
 123456789  123456789  123456789 | 123456789  8          123456789 | 4          123456789  123456789
 123456789  123456789  123456789 | 123456789  1          123456789 | 123456789  123456789  123456789
---------------------------------+---------------------------------+---------------------------------
 123456789  123456789  123456789 | 6          123456789  3         | 123456789  7          123456789
 5          123456789  123456789 | 2          123456789  123456789 | 123456789  123456789  123456789
 1          123456789  4         | 123456789  123456789  123456789 | 123456789  123456789  123456789
```

This implementation is simple and precise, but we can do more.

Now, we can reintroduce the rules that we set aside earlier. However, the rules themselves do not tell us what to do. We need heuristic strategies to gain insights from the rules, similar to solving Sudoku with pen and paper. Let's start with the elimination method:

- **Strategy 1**: If a square `key` is assigned a value `val`, then its peers (peers[key]) should not contain `val` in their lists of possible values, as this would violate the rule that no two squares in the same unit, row, or column can have the same digit.

- **Strategy 2**: If there is only one square in a unit that can hold a specific digit (possibly happen after applying the above rule several times), then that digit should be assigned to that square.

We adjust the code by defining an `eliminate` function, which removes a digit from the possible values of a square. After performing the elimination task, it applies the above strategies to `key` and `val` to attempt further eliminations. Note that it includes a boolean return value to handle possible contradictions. If the list of possible values for a square becomes empty, something went wrong, and we return `false`.

```rust
fn eliminate(values : SquareMap[List[Char]], key : String, val : Char) -> Bool {
  if not(exist(values[key], fn (v) { v == val })) {
    return true
  }
  values[key] = values[key].remove(val)
  // If `key` has only one possible value left, remove this value from its peers
  match single(values[key]) {
    Err(b) => {
      if not(b) {
        return false
      }
    }
    Ok(val) => {
      let mut result = true
      peers[key].iter(fn (key) {
        result = result && eliminate(values, key, val)
      })
      if not(result) {
        return false
      }
    }
  }
  //  If there is only one square in the unit of `key` that can hold `val`, assign `val` to that square
  let unit = units[key]
  let places = unit.filter(fn (sq) {
    exist(values[sq], fn (v) { v == val })
  })
  match single(places) {
    Err(b) => {
      return b
    }
    Ok(key) => {
      return assign(values, key, val)
    }
  }
}


// Return `Err(false)` if the list is empty
// Return `Ok(x)` if the list contains only `[x]`
// Return `Err(true)` if the list contains `[x1, x2, ......]`
fn single[T](this : List[T]) -> Result[T, Bool] {
  match this {
    Nil => Err(false)
    Cons(x, Nil) => Ok(x)
    _ => Err(true)
  }
}
```

Next, we define `assign(values, key, val)` to remove all values except `val` from the possible values of `key`.

```rust
fn assign(values : SquareMap[List[Char]], key : String, val : Char) -> Bool {
  let other_values = values[key].remove(val)
  let mut result = true
  other_values.iter(fn (val) {
    result = result && eliminate(values, key, val)
  })
  return result
}
```

These two functions apply heuristic strategies to each square they access. A successful heuristic application introduces new squares to consider, allowing these strategies to propagate widely across the grid. This is key to quickly eliminating invalid options.

Let's try the example again

```
"4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......"

 4        1679     12679   | 139      2369     269     | 8        1239     5
 26789    3        1256789 | 14589    24569    245689  | 12679    1249     124679
 2689     15689    125689  | 7        234569   245689  | 12369    12349    123469
---------------------------+---------------------------+---------------------------
 3789     2        15789   | 3459     34579    4579    | 13579    6        13789
 3679     15679    15679   | 359      8        25679   | 4        12359    12379
 36789    4        56789   | 359      1        25679   | 23579    23589    23789
---------------------------+---------------------------+---------------------------
 289      89       289     | 6        459      3       | 1259     7        12489
 5        6789     3       | 2        479      1       | 69       489      4689
 1        6789     4       | 589      579      5789    | 23569    23589    23689
```

A significant improvement! In fact, this preprocessing can already solve some simple Sudoku puzzles.

```
"003020600900305001001806400008102900700000008006708200002609500800203009005010300"

 4  8  3 | 9  2  1 | 6  5  7
 9  6  7 | 3  4  5 | 8  2  1
 2  5  1 | 8  7  6 | 4  9  3
---------+---------+---------
 5  4  8 | 1  3  2 | 9  7  6
 7  2  9 | 5  6  4 | 1  3  8
 1  3  6 | 7  9  8 | 2  4  5
---------+---------+---------
 3  7  2 | 6  8  9 | 5  1  4
 8  1  4 | 2  5  3 | 7  6  9
 6  9  5 | 4  1  7 | 3  8  2
```

If you are interested in artificial intelligence, you might recognize this as a Constraint Satisfaction Problem (CSP), and `assign` and `eliminate` are specialized arc consistency algorithms. For more on this topic, refer to Chapter 6 of _Artificial Intelligence: A Modern Approach_.

## Search

After preprocessing, we can boldly use brute-force enumeration to search for all feasible combinations. However, we can still use the heuristic strategies during the search process. When trying to assign a value to a square, we still use `assign`, which allows us to apply previous optimizations to eliminate many invalid branches during the search.

Another point to note is that conflicts may arise during the search (when a square's possible values are exhausted). Since mutable structures make backtracking troublesome, we directly copy values each time we assign a value.

```rust
fn search(values : SquareMap[List[Char]]) -> Option[SquareMap[List[Char]]] {
  if values.contains(fn (digits){ not(isSingleton(digits)) }) {
    // // Find the square with the smallest number of possible values greater than 1, and start the search from this square
    // This is just a heuristic strategy; you can try finding a smarter and more effective one
    let mut minsq = ""
    let mut n = 10
    squares.iter(fn (sq) {
      let len = values[sq].length()
      if len > 1 {
        if len < n {
          n = len
          minsq = sq
        }
      }
    })
    // Iterate through assignments and stop if a successful search is found
    loop values[minsq] {
      Nil => None
      Cons(digit, rest) => {
        let another = values.copy()
        if assign(another, minsq, digit){
          match search(another) {
            None => continue rest
            Some(_) as result => result
          }
        } else {
          continue rest
        }
      }
    }
  } else {
    return Some(values)
  }
}
```

Let's run the same example again (the example is actually taken from [magictour](http://magictour.free.fr/top95), a list of difficult Sudoku puzzles, which is not easy for humans)

```
> solve("4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......")

 4  1  7 | 3  6  9 | 8  2  5
 6  3  2 | 1  5  8 | 9  4  7
 9  5  8 | 7  2  4 | 3  1  6
---------+---------+---------
 8  2  5 | 4  3  7 | 1  6  9
 7  9  1 | 5  8  6 | 4  3  2
 3  4  6 | 9  1  2 | 7  5  8
---------+---------+---------
 2  8  9 | 6  4  3 | 5  7  1
 5  7  3 | 2  9  1 | 6  8  4
 1  6  4 | 8  7  5 | 2  9  3
```

Running on [MoonBit online IDE](https://try.moonbitlang.com/), It takes only about 0.11 seconds to solve this Sudoku!

Complete code here: [try.moonbitlang.com/#6806c2fe](https://try.moonbitlang.com/#6806c2fe)

## Conclusion

The purpose of games is to relieve boredom and bring joy. If playing a game becomes more anxiety-inducing than exciting, it might go against the game designer's original intent. The article demonstrated that simple elimination methods and brute-force search can quickly solve some Sudoku puzzles. This does not mean that Sudoku is not worth playing; rather, it reveals that one should not be overly concerned with an unsolvable Sudoku puzzle.

Let's play with MoonBit with ease!

Visit MoonBit [Gallery](https://www.moonbitlang.com/gallery/sudoku/) to play with the Sudoku solver written in MoonBit. Click [this link](https://github.com/myfreess/sudoku) to view the full source code.

This tutorial references Norvig's blog: [http://norvig.com/sudoku.html](http://norvig.com/sudoku.html)


================================================
File 259: /data/input/moonbit-docs/next/index.md
================================================
# MoonBit Documentation

MoonBit is an end-to-end programming language toolchain for cloud and edge computing using WebAssembly.

The IDE environment is available at [https://try.moonbitlang.com](https://try.moonbitlang.com) without any installation; it does not rely on any server either.

**Get started**

- [Tutorials](/tutorial/index.md): Follow tutorials to start your journey

- [Language](/language/index.md): Introduction to detailed language specifications

- [Toolchains](/toolchain/index.md): Introduction to all the toolchains making developing MoonBit a unique experience.

**Useful Sources**

- [Homepage](https://www.moonbitlang.com): The official site of MoonBit, including:
  - [Download](https://www.moonbitlang.com/download/): How to install MoonBit toolchain
  - [Blogs](https://www.moonbitlang.com/blog/): Big news and updates from the team
  - [Updates](https://www.moonbitlang.com/weekly-updates/): Changelogs to language features

- [Document (this site)](https://docs.moonbitlang.com/en/): The complete and up to date document for MoonBit, including the sections mentioned before

- [Tour](https://tour.moonbitlang.com): Interactive language playground

- [MoonCakes](https://mooncakes.io): Package registry along with API documents, including:
  - [Standard library API](https://mooncakes.io/docs/#/moonbitlang/core/)
  - [Experimental library API](https://mooncakes.io/docs/#/moonbitlang/x/)

```{toctree}
:hidden:
tutorial/index
language/index
toolchain/index
example/index

================================================
File 260: /data/input/moonbit-docs/next/language/async-experimental.md
================================================
# Experimental async programming support

MoonBit is providing experimental support for async programming.
But the design and API is still highly unstable, and may receive big breaking change in the future.
This page documents the current design, and we highly appreciate any feedback or experiment with current design.

## Async function
Async functions can be declared with the `async` keyword:

```{literalinclude} /sources/async/src/async.mbt
:language: moonbit
:start-after: start async function declaration
:end-before: end async function declaration
```

Async functions must be called with the `!!` operator:

```{literalinclude} /sources/async/src/async.mbt
:language: moonbit
:start-after: start async function call syntax
:end-before: end async function call syntax
```

If the async function may throw error, `!!` will also rethrow the error.

Async functions can only be called in async functions. Currently, async functions cannot be called in the body of `for .. in` loops.

## Async primitives for suspension
MoonBit provides two core primitives for `%async.suspend` and `%async.run`:

```{literalinclude} /sources/async/src/async.mbt
:language: moonbit
:start-after: start async primitive
:end-before: end async primitive
```

There two primitives are not intended for direct use by end users.
However, since MoonBit's standard library for async programming is still under development,
currently users need to bind these two primitives manually to do async programming.

There are two ways of reading these primitives:

- the coroutine reading: `%async.run` spawn a new coroutine,
  and `%async.suspend` suspend current coroutine.
  The main difference with other languages here is:
  instead of yielding all the way to the caller of `%async.run`,
  resumption of the coroutine is handled by the callback passed to `%async.suspend`
- the delimited continuation reading: `%async.run` is the `reset` operator in delimited continuation,
  and `%async.suspend` is the `shift` operator in delimited continuation

Here's an example of how these two primitives work:

```{literalinclude} /sources/async/src/async.mbt
:language: moonbit
:start-after: start async example
:end-before: end async example
```

In `async_worker`, `suspend` will capture the rest of the current coroutine as two "continuation" functions, and pass them to a callback.
In the callback, calling `resume_ok` will resume execution at the point of `suspend!!(...)`,
all the way until the `run_async` call that start this coroutine.
calling `resume_err` will also resume execution of current coroutine,
but it will make `suspend!!(...)` throw an error instead of returning normally.

Notice that `suspend` type may throw error, even if `suspend` itself never throw an error directly.
This design makes coroutines cancellable at every `suspend` call: just call the corresponding `resume_err` callback.

## Integrating with JS Promise/callback based API
Since MoonBit's standard async library is still under development,
so there is no ready-to-use implementation for event loop and IO operations yet.
So the easiest way to write some async program is to use MoonBit's Javascript backend,
and reuse the event loop and IO operations of Javascript.
Here's an example of integrating MoonBit's async programming support with JS's callback based API:

```{literalinclude} /sources/async/src/async.mbt
:language: moonbit
:start-after: start async timer example
:end-before: end async timer example
```

Integrating with JS Promise is easy too:
just pass `resume_ok` as the `resolve` callback and `resume_err` as the `reject` callback to a JS promise.


================================================
File 261: /data/input/moonbit-docs/next/language/derive.md
================================================
# Deriving traits

MoonBit supports deriving a number of builtin traits automatically from the type definition.

To derive a trait `T`, it is required that all fields used in the type implements `T`.
For example, deriving `Show` for a struct `struct A { x: T1; y: T2 }` requires both `T1: Show` and `T2: Show`

## Show

`derive(Show)` will generate a pretty-printing method for the type.
The derived format is similar to how the type can be constructed in code.

```{literalinclude} /sources/language/src/derive/show.mbt
:language: moonbit
:start-after: start derive show struct
:end-before: end derive show struct
```

```{literalinclude} /sources/language/src/derive/show.mbt
:language: moonbit
:start-after: start derive show enum
:end-before: end derive show enum
```

## Eq and Compare

`derive(Eq)` and `derive(Compare)` will generate the corresponding method for testing equality and comparison.
Fields are compared in the same order as their definitions.
For enums, the order between cases ascends in the order of definition.

```{literalinclude} /sources/language/src/derive/eq_compare.mbt
:language: moonbit
:start-after: start derive eq_compare struct
:end-before: end derive eq_compare struct
```

```{literalinclude} /sources/language/src/derive/eq_compare.mbt
:language: moonbit
:start-after: start derive eq_compare enum
:end-before: end derive eq_compare enum
```

## Default

`derive(Default)` will generate a method that returns the default value of the type.

For structs, the default value is the struct with all fields set as their default value.

```{literalinclude} /sources/language/src/derive/default.mbt
:language: moonbit
:start-after: start derive default struct
:end-before: end derive default struct
```

For enums, the default value is the only case that has no parameters.

```{literalinclude} /sources/language/src/derive/default.mbt
:language: moonbit
:start-after: start derive default enum
:end-before: end derive default enum
```

Enums that has no cases or more than one cases without parameters cannot derive `Default`.

<!-- MANUAL CHECK  should not compile -->

```moonbit
enum CannotDerive1 {
    Case1(String)
    Case2(Int)
} derive(Default) // cannot find a constant constructor as default

enum CannotDerive2 {
    Case1
    Case2
} derive(Default) // Case1 and Case2 are both candidates as default constructor
```

## Hash

`derive(Hash)` will generate a hash implementation for the type.
This will allow the type to be used in places that expects a `Hash` implementation,
for example `HashMap`s and `HashSet`s.

```{literalinclude} /sources/language/src/derive/hash.mbt
:language: moonbit
:start-after: start derive hash struct
:end-before: end derive hash struct
```

## Arbitrary

`derive(Arbitrary)` will generate random values of the given type.

## FromJson and ToJson

`derive(FromJson)` and `derive(ToJson)` will generate methods that deserializes/serializes the given type from/to
JSON files correspondingly.

```{literalinclude} /sources/language/src/derive/json.mbt
:language: moonbit
:start-after: start json basic
:end-before: end json basic
```

Both derive directives accept a number of arguments to configure the exact behavior of serialization and deserialization.

```{warning}
The actual behavior of JSON serialization arguments is unstable.
```

```{literalinclude} /sources/language/src/derive/json.mbt
:language: moonbit
:start-after: start json args
:end-before: end json args
```

### Enum representations

Enums can be represented in JSON in a number of styles.
There are two aspects of the representation:

- **Tag position** determines where the name of the enum tag (i.e. case or constructor name) is stored.
- **Case representation** determines how to represent the payload of the enum.

Let's consider the following enum definition:

```moonbit
enum E {
    Uniform(Int)
    Axes(x~: Int, y~: Int)
}
```

For tag position, there are 4 variants:

- **Internally tagged** puts the tag alongside the payload values:

  `{ "$tag": "Uniform", "0": 1 }`, `{ "$tag": "Axes", "x": 2, "y": 3 }`

- **Externally tagged** puts the tag as the JSON object key outside the payload values:

  `{ "Uniform": { "0": 1 } }`, `{ "Axes": { "x": 2, "y": 3 } }`

- **Adjacently tagged** puts the tag payload in two adjacent keys in a JSON object:

  `{ "t": "Uniform", "c": { "0": 1 } }`, `{ "t": "Axes", "c": { "x": 2, "y": 3 } }`

- **Untagged** has no explicit tag identifying which case the data is:

  `{ "0": 1 }`, `{ "x": 2, "y": 3 }`.

  The JSON deserializer will try to deserialize each case in order and return the first one succeeding.

For case representation, there are 2 variants:

- **Object-like** representation serializes enum payloads into a JSON object,
  whose key is either the tag name or the string of the positional index within the struct.

  `{ "0": 1 }`, `{ "x": 2, "y": 3 }`

- **Tuple-like** representation serializes enum payloads into a tuple (jSON array),
  in the same order as the type declaration.
  Labels are omitted in tuple-like representations.

  `[1]`, `[2, 3]`

The two aspects can be combined freely, except one case:
_internally tagged_ enums cannot use _tuple-like_ representation.

### Container arguments

- `repr(...)` configures the representation of the container.
  This controls the tag position of enums.
  For structs, the tag is assumed to be the type of the type.

  There are 4 representations available for selection:

  - `repr(tag = "tag")` –
    Use internally tagged representation,
    with the tag's object key name as specified.
  - `repr(untagged)` –
    Use untagged representation.
  - `repr(ext_tagged)` –
    Use externally tagged representation.
  - `repr(tag = "tag", contents = "contents")` –
    Use adjacently tagged representation,
    with the tag and contents key names as specified.

  The default representation for struct is `repr(untagged)`.

  The default representation for enums is `repr(tag = "$tag")`

- `case_repr(...)` (enum only) configures the case representation of the container.
  This option is only available on enums.

  - `case_repr(struct)` –
    Use struct-like representation of enums.

  - `case_repr(tuple)` –
    Use tuple-like representation of enums.

- `rename_fields`, `rename_cases` (enum only), `rename_struct` (struct only), `rename_all`
  renames fields, case names, struct name and all names correspondingly,
  into a specific style.

  Available parameters are:

  - `lowercase`
  - `UPPERCASE`
  - `camelCase`
  - `PascalCase`
  - `snake_case`
  - `SCREAMING_SNAKE_CASE`
  - `kebab-case`
  - `SCREAMING-KEBAB-CASE`

  Example: `rename_fields = "PascalCase"`
  for a field named `my_long_field_name`
  results in `MyLongFieldName`.

  Renaming assumes the name of fields in `snake_case`
  and the name of structs/enum cases in `PascalCase`.

- `cases(...)` (enum only) controls the layout of enum cases.

  For example, for an enum

  ```moonbit
  enum E {
    A(...)
    B(...)
  }
  ```

  you are able to control each case using `cases(A(...), B(...))`.

  See [Case arguments](#case-arguments) below for details.

- `fields(...)` (struct only) controls the layout of struct fields.

  For example, for a struct

  ```moonbit
  struct S {
    x: Int
    y: Int
  }
  ```

  you are able to control each field using `fields(x(...), y(...))`

  See [Field arguments](#field-arguments) below for details.

### Case arguments

- `rename = "..."` renames this specific case,
  overriding existing container-wide rename directive if any.

- `fields(...)` controls the layout of the payload of this case.
  Note that renaming positional fields are not possible currently.

  See [Field arguments](#field-arguments) below for details.

### Field arguments

- `rename = "..."` renames this specific field,
  overriding existing container-wide rename directives if any.


================================================
File 262: /data/input/moonbit-docs/next/language/docs.md
================================================
# Documentation

## Doc Comments

Doc comments are comments prefix with `///` in each line in the leading of toplevel structure like `fn`,`let`,`enum`,`struct`,`type`. The doc comments contains a markdown text and several pragmas.

```{literalinclude} /sources/language/src/misc/top.mbt
:language: moonbit
:start-after: start doc string 1
:end-before: end doc string 1
```

### Pragmas

Pragmas are annotations inside doc comments. They all take the form `/// @word ...`. The _word_ indicates the type of pragma and is followed optionally by several _word_ or string literals. Pragmas do not normally affect the meaning of programs. Unrecognized pragmas will be reported as warnings.

- Alert Pragmas

  Alert pragmas in doc comments of functions will be reported when those functions are referenced. This mechanism is a generalized way to mark functions as `deprecated` or `unsafe`.

  It takes the form `@alert category "alert message..."`.

  The category can be an arbitrary identifier. It allows configuration to decide which alerts are enabled or turned into errors.

  <!-- MANUAL CHECK -->
  ```moonbit
  /// @alert deprecated "Use foo2 instead"
  pub fn foo() -> Unit {
    ...
  }

  /// @alert unsafe "Div will cause an error when y is zero"
  pub fn div(x : Int, y : Int) -> Int {
    ...
  }

  test {
    // Warning (Alert deprecated): Use foo2 instead
    foo()
    // Warning (Alert unsafe): Div will cause an error when y is zero
    div(1, 2) |> ignore
  }
  ```

================================================
File 263: /data/input/moonbit-docs/next/language/error-handling.md
================================================
# Error handling

Error handling has always been at core of our language design. In the following
we'll be explaining how error handling is done in MoonBit. We assume
you have some prior knowledge of MoonBit, if not, please checkout [A tour of MoonBit](../tutorial/tour.md).

## Error types

The error values used in MoonBit must have an error type. An error type can be
defined in the following forms:

```{literalinclude} /sources/language/src/error/top.mbt
:language: moonbit
:dedent:
:start-after: start error 1
:end-before: end error 1
```

The return type of a function can include an error type to indicate that the
function might return an error. For example, the following function `div` might
return an error of type `DivError`:

```{literalinclude} /sources/language/src/error/top.mbt
:language: moonbit
:dedent:
:start-after: start error 2
:end-before: end error 2
```

Here, the keyword `raise` is used to interrupt the function execution and return
an error.

## The Default Error Type

MoonBit provides a default error type `Error` that can be used when the concrete
error type is not important. For convenience, you can annotate the function name
or the return type with the suffix `!` to indicate that the `Error` type is
used. For example, the following function signatures are equivalent:

```{literalinclude} /sources/language/src/error/top.mbt
:language: moonbit
:dedent:
:start-after: start error 3
:end-before: end error 3
```

For anonymous function and matrix function, you can annotate the keyword `fn`
with the `!` suffix to achieve that. For example,

```{literalinclude} /sources/language/src/error/top.mbt
:language: moonbit
:start-after: start error 4
:end-before: end error 4
```

As shown in the above example, the error types defined by `type!` can be used as
value of the type `Error` when the error is raised.

Note that only error types or the type `Error` can be used as errors. For
functions that are generic in the error type, you can use the `Error` bound to
do that. For example,

```{literalinclude} /sources/language/src/error/top.mbt
:language: moonbit
:start-after: start error 5
:end-before: end error 5
```

Since the type `Error` can include multiple error types, pattern matching on the
`Error` type must use the wildcard `_` to match all error types. For example,

```{literalinclude} /sources/language/src/error/top.mbt
:language: moonbit
:start-after: start error 6
:end-before: end error 6
```

## Handling Errors

There are three ways to handle errors:

- Append `!` after the function name in a function application to rethrow the
  error directly in case of an error, for example:

```{literalinclude} /sources/language/src/error/top.mbt
:language: moonbit
:start-after: start error 7
:end-before: end error 7
```

- Append `?` after the function name to convert the result into a first-class
  value of the `Result` type, for example:

```{literalinclude} /sources/language/src/error/top.mbt
:language: moonbit
:start-after: start error 8
:end-before: end error 8
```

- Use `try` and `catch` to catch and handle errors, for example:

```{literalinclude} /sources/language/src/error/top.mbt
:language: moonbit
:dedent:
:start-after: start error 9
:end-before: end error 9
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/error/__snapshot__/error_9
:caption: Output
```

Here, `try` is used to call a function that might throw an error, and `catch` is
used to match and handle the caught error. If no error is caught, the catch
block will not be executed and the `else` block will be executed instead.

The `else` block can be omitted if no action is needed when no error is caught.
For example:

```{literalinclude} /sources/language/src/error/top.mbt
:language: moonbit
:dedent:
:start-after: start error 10
:end-before: end error 10
```

The `catch` keyword is optional, and when the body of `try` is a simple
expression, the curly braces can be omitted. For example:

```{literalinclude} /sources/language/src/error/top.mbt
:language: moonbit
:dedent:
:start-after: start error 11
:end-before: end error 11
```

The `!` and `?` attributes can also be used on method invocation and pipe
operator. For example:

```{literalinclude} /sources/language/src/error/top.mbt
:language: moonbit
:start-after: start error 12
:end-before: end error 12
```

However for infix operators such as `+` `*` that may raise an error,
the original form has to be used, e.g. `x.op_add!(y)`, `x.op_mul!(y)`.

Additionally, if the return type of a function includes an error type, the
function call must use `!` or `?` for error handling, otherwise the compiler
will report an error.

## Error Inference

Within a `try` block, several different kinds of errors can be raised. When that
happens, the compiler will use the type `Error` as the common error type.
Accordingly, the handler must use the wildcard `_` to make sure all errors are
caught. For example,

```{literalinclude} /sources/language/src/error/top.mbt
:language: moonbit
:dedent:
:start-after: start error 13
:end-before: end error 13
```

You can also use `catch!` to rethrow the uncaught errors for convenience. This
is useful when you only want to handle a specific error and rethrow others. For
example,

```{literalinclude} /sources/language/src/error/top.mbt
:language: moonbit
:dedent:
:start-after: start error 14
:end-before: end error 14
```

## Example: Division by Zero

We'll write a small example to demonstrate the basics of MoonBit's error
handling system. Consider the following `div` function which'll raise an error
on division by zero:

```moonbit
type! DivisionByZeroError String
fn div(x : Int, y : Int) -> Int!DivisionByZeroError {
  if y == 0 {
    raise DivisionByZeroError("division by zero")
  }
  x / y
}
```

In before, we would typically use `type` to define a wrapper type which wraps
around some existing foreign type. Here however, we append `type` with `!` to
define a error type `DivisionByZeroError` which wraps around `String`.

> `type! E S` construct a error type `E` from `S`

Just like `type`, `type!` may have a payload like the above `DivisionByZeroError`, or may not, or may even have multiple constructors like a normal `enum`:

```moonbit
type! ConnectionError {
  BrokenPipe(Int,String)
  ConnectionReset
  ConnectionAbort
  ConnectionRefused
}
```

To utilize `DivisionByZeroError` type, we would usually define a function which may raise
error by denoting its return type like `T ! E` in the signature, with `T` being
the actual return type and `E` being the error type. In this case, it's
`Int!DivisionByZeroError`. The error can be thrown using
`raise e` where `e` is an instance of `E` which can be constructed using the
default constructor of `S`.

Any instance of an error is a second class object. Meaning it may only appear in
the return value. And if it does appear, the function signature has to be
adjusted to match with the return type.

The `test` block in MoonBit may also be seen as a function, with a return type
of `Unit!Error`.

## Calling an error-able function

an error-able function is usually called in 2 manners: `f!(...)` and `f?(...)`.

### As-is calling

`f!(...)` calls the function directly. The possible error must be dealt in the
function that calls `f`. We can either re-raising it without actually dealing
with the error:

```moonbit -e1001 -e1002
// We have to match the error type of `div2` with `div`
fn div2(x : Int, y : Int) -> Int!DivisionByZeroError {
  div!(x,y)
}
```

or use `try...catch` block like in many other languages:

```moonbit
fn div3(x : Int, y : Int) -> Unit {
  try {
    div!(x, y)
  } catch { // `catch` and `except` works the same.
    DivisionByZeroError(e) => println("inf: \{e}")
  } else {
    v => println(v)
  }
}
```

The `catch...` clause has similar semantics like pattern matching. We can unwrap
the error to retrieve the underlying `String` and print it. Additionally,
there's an `else` clause to handle the value of `try...` block.

```moonbit
fn test_try() -> Result[Int, Error] {
  // compiler can figure out the type of a local error-able function.
  fn f() -> _!_ {
    raise Failure("err")
  }

  try Ok(f!()) { err => Err(err) }
}
```

Curly braces may be omitted if the body of try is a one-liner (expression). The
`catch` keyword can also be omitted as well. In the case where a `try` body would raise different errors,
the special `catch!` can be used to catch some of the errors, while re-raising other uncaught errors:

```moonbit
type! E1
type! E2
fn f1() -> Unit!E1 { raise E1 }
fn f2() -> Unit!E2 { raise E2 }
fn f() -> Unit! {
  try {
    f1!()
    f2!()
  } catch! {
    E1 => println("E1")
    // E2 gets re-raised.
  }
}
```

### Convert to Result

#### Extracting values

A object of type `Result` is a first class value in MoonBit. `Result` has 2 constructors: `Ok(...)` and `Err(...)` where the former accept a first class object and the latter accept a error object.

With `f?(...)`, the return type `T!E` is turned into `Result[T,E]`. We may use pattern matching to extract value from it:

```moonbit enclose
let res = div?(10, 0)
match res {
  Ok(x) => println(x)
  Err(DivisionByZeroError(e)) => println(e)
}
```

the `f?()` is basically a syntactic sugar for

```moonbit enclose
let res = try {
  Ok(div!(10, 0))
} catch {
  s => Err(s)
}
```

> Note the difference between `T?` and `f?(...)`: `T` is a type and `T?` is
> equivalent to `Option[T]` whereas `f?(...)` is a call to an error-able function
> `f`.

Besides pattern matching, `Result` provides some useful methods to deal with possible error:

```moonbit no-check
let res1: Result[Int, String] = Err("error")
let value = res1.or(0) // 0

let res2: Result[Int, String] = Ok(42)
let value = res2.unwrap() // 42
```

- `or` returns the value if the result is `Ok` or a default value if it is `Err`
- `unwrap` panics if the result is `Err` and return the value if it is `Ok`

#### Mapping values

```moonbit no-check
let res1: Result[Int, String] = Ok(42)
let new_result = res1.map(fn(x) { x + 1 }) // Ok(43)

let res2: Result[Int, String] = Err("error")
let new_result = res2.map_err(fn(x) { x + "!" }) // Err("error!")
```

- `map` applies a function to the value within, except it doesn't nothing if result is `Err`.
- `map_err` does the opposite.

Unlike some languages, MoonBit treats error-able and nullable value differently. Although one might treat them analogously, as an `Err` result contains no value, only the error, which is like `null`. MoonBit knows that.

- `to_option` converts a `Result` to `Option`.

```moonbit no-check
let res1: Result[Int, String] = Ok(42)
let option = res1.to_option() // Some(42)

let res2: Result[Int, String] = Err("error")
let option1 = res2.to_option() // None
```

## Built-in error type and functions

In MoonBit, `Error` is a generalized error type:

```moonbit no-check
// These signatures are equivalent. They all raise Error.
fn f() -> Unit! { .. }
fn f!() -> Unit { .. }
fn f() -> Unit!Error { .. }

fn test_error() -> Result[Int, Error] {
  fn f() -> _!_ {
    raise DivisionByZeroError("err")
  }

  try {
    Ok(f!())
  } catch {
    err => Err(err)
  }
}
```

Although the constructor `Err` expects a type of `Error`, we may
still pass an error of type `DivisionByZeroError` to it.

But `Error` can't be constructed directly. It's meant to be passed around, not used directly:

```moonbit
type! ArithmeticError

fn what_error_is_this(e : Error) -> Unit {
  match e {
    DivisionByZeroError(_) => println("DivisionByZeroError")
    ArithmeticError => println("ArithmeticError")
    ... => println("...")
    _ => println("Error")
  }
}
```

`Error` is typically used where concrete error type is not needed,
or simply act as a catch-all for all kinds of sub-errors.

As `Error` includes multiple error types, partial matching is not allowed here. We have to do exhaustive matching by providing a catch-all/wildcard case `_`.

We usually use the builtin `Failure` error type for a generalized error, and by
generalized we mean using it for trivial errors that doesn't need a new error type.

```moonbit
fn div_trivial(x : Int, y : Int) -> Int!Failure {
  if y == 0 {
    raise Failure("division by zero")
  }
  x / y
}
```

Besides using the constructor directly, the function `fail!` provides a
shorthand to construct a `Failure`. And if we take a look at the source code:

```moonbit
pub fn fail[T](msg : String, ~loc : SourceLoc = _) -> T!Failure {
  raise Failure("FAILED: \{loc} \{msg}")
}
```

We can see that `fail` is merely a constructor with a pre-defined output
template for showing both the error and the source location. In practice, `fail!`
is always preferred over `Failure`.

Other functions used to break control flow are `abort` and `panic`. They are equivalent. An `panic` at any place will manually crash the program at that place, and prints out stack trace.


================================================
File 264: /data/input/moonbit-docs/next/language/error_codes/E0001.md
================================================
# E0001

There is an internal error occurred to the compiler. Usually this means you have
discovered a bug in the compiler.

A bug report containing the error description and relevant code would be
greatly appreciated. You can submit the bug report here:

<https://github.com/moonbitlang/moonbit-docs/issues/new?labels=bug,ICE>


================================================
File 265: /data/input/moonbit-docs/next/language/error_codes/E1001.md
================================================
# E1001

Unused function.

This function is not used by any other part of your code, nor marked with `pub`
visibility.

Note that this warning might uncover other bugs in your code. For example, if
there are two functions in your codebase that has similar name, you might just
call the other function by mistake.

## Erroneous example

```moonbit
fn greeting() -> String {
  "Hello!"
}

fn main {
  fn local_greeting() -> String {
    "Hello, world!"
  }
}
```

## Suggestion

There are multiple ways to fix this warning:

- If the function is indeed useless, you can remove the definition of the
  function.
- If this function is at the toplevel (i.e., not local), and is part of the
  public API of your module, you can add the `pub` keyword to the function.

  ```moonbit
  pub fn greeting() -> String {
    "Hello!"
  }
  ```

- If you made a typo in the function name, you can rename the function to the
  correct name at the call site.

There are some cases where you might want to keep the function private and
unused at the same time. In this case, you can call `ignore()` on the function
to force the use of it.

```moonbit
fn greeting() -> String {
  "Hello, world!"
}

fn init {
  ignore(greeting)
}
```

```moonbit
fn main {
  fn local_greeting() -> String {
    "Hello, world!"
  }
  ignore(local_greeting)
}
```


================================================
File 266: /data/input/moonbit-docs/next/language/error_codes/E1002.md
================================================
# E1002

Unused variable.

This variable is unused by any other part of your code, nor marked with `pub`
visibility.

Note that this warning might uncover other bugs in your code. For example, if
there are two variables in your codebase that has similar name, you might just
use the other variable by mistake.

Specifically, if the variable is at the toplevel, and the body of the module
contains side effects, the side effects will not happen.

## Erroneous example

```moonbit
let p : Int = {
//  ^ Warning: Unused toplevel variable 'p'.
//             Note if the body contains side effect, it will not happen.
//             Use `fn init { .. }` to wrap the effect.
  println("Side effect")
  42
}

fn main {
  let x = 42 // Warning: Unused variable 'x'
}
```

## Suggestion

There are multiple ways to fix this warning:

- If the variable is indeed useless, you can remove the definition of the
  variable.
- If this variable is at the toplevel (i.e., not local), and is part of the
  public API of your module, you can add the `pub` keyword to the variable.

  ```moonbit
  pub let p = 42
  ```

- If you made a typo in the variable name, you can rename the variable to the
  correct name at the use site.
- If your code depends on the side-effect of the variable, you can wrap the
  side-effect in a `fn init` block.

  ```moonbit
  fn init {
    println("Side effect")
  }
  ```

There are some cases where you might want to keep the variable private and
unused at the same time. In this case, you can call `ignore()` on the variable
to force the use of it.

```moonbit
let p : Int = {
  println("Side effect")
  42
}

fn init {
  ignore(p)
}

fn main {
  let x = 42
  ignore(x)
}
```


================================================
File 267: /data/input/moonbit-docs/next/language/error_codes/E1003.md
================================================
# E1003

Unused type declaration.

This type is not used by any other part of your code, and it is private. Type
declaration is by default abstract, which means it is publicly visible to users
of this package, but they cannot see the implementation of the type, nor can
create instances of it directly. Therefore, this warning is only shown if the
type is marked with `priv` visibility, and is not used by any other part of this
package.

Note that this warning might uncover other bugs in your code. For example, if
there are two types in the package that has similar name, you might just use
the other type by mistake.

## Erroneous example

```moonbit
priv struct Foo { // Warning: Unused type 'Foo'.
  bar : Int
}

fn main {
  struct Bar { // Warning: Unused type 'Bar'.
    foot : Int
  }
}
```

## Suggestion

There are multiple ways to fix this warning:

- If the type is indeed useless, you can remove the definition of the type.
- If this type is not local, and is part of the public API of your module, you
  can remove the `priv` visibility keyword from the type.

  ```moonbit
  struct Foo {
    bar : Int
  }
  ```

- Check if you are referencing the type with a correct name.

It is rather rare to have a type that is private and unused at
the same time; therefore, we suggest you remove the type if it is not used.


================================================
File 268: /data/input/moonbit-docs/next/language/error_codes/E1004.md
================================================
# E1004

Unused abstract type.

Currently, MoonBit won't emit this warning.


================================================
File 269: /data/input/moonbit-docs/next/language/error_codes/E1005.md
================================================
# E1005

Unused generic type variable.

In some cases, using types with unused generic type variables will make it
impossible for the type checker to infer the type of the unused variable. This
might lead to cryptic error messages, even unexpected runtime behavior.

## Erroneous example

```moonbit
struct Foo[T] { // Warning: Unused type variable 'T'.
  bar : Int
}

fn main {
  let foo : Foo[Int] = { bar : 42 }
  let baz = { bar : 42 } // Warning: The type of this expression is Foo[_/0]
  println(foo.bar)
  println(baz.bar)
}
```

## Suggestion

- If the type variable is indeed useless, remove the unused type variable.

  ```moonbit
  struct Foo { // Remove the unused type variable.
    bar : Int
  }
  ```

- If you wish to keep the type variable, you can use `_` to indicate that the
  type variable is intentionally unused.

  ```moonbit
  struct Foo[_] {
    bar : Int
  }
  ```


================================================
File 270: /data/input/moonbit-docs/next/language/error_codes/E1006.md
================================================
# E1006

Variant is never read, never constructed, or both.

- If a variant is never read, it means it is defined but never destructed in a
  pattern matching expression (`match`, `let`, `guard let`, loop function,
  etc.).
- If a variant `A` is never constructed, it means there is no `A(...)`.
- If a variant is unused, it means it is never constructed and never read.

## Erroneous example

```moonbit
priv enum T {
  A // Warning: Variant 'A' is never read
  B // Warning: Variant 'B' is never constructed
  C // Warning: Variant 'C' is unused
}

fn main {
  match T::A {
    B => ()
    _ => ()
  }
}
```

## Suggestion

- If some variants are never read, while others are read, this means that you
  have use wildcard pattern (`_`) in your code. You can expand the wildcard
  pattern to include the unused variants.

  ```moonbit
  fn main {
    match T::A {
      B => ()
      C => ()
      A => ()
    }
  }
  ```

- If all variants are never read, and you need to read these variants outside of
  current package, you can add `pub` keyword to the enum definition. Notice this
  will make the implementation of the variant visible to the users of the
  package.

  ```moonbit
  pub enum T {
    A
    B
    C
  }
  ```

- If you need to construct the "never constructed" variant outside of the
  current package, you can add `pub(all)` keyword to the variant.

  ```moonbit
  pub(all) enum T {
    A
    B
    C
  }
  ```

- If some variants are indeed useless, you can remove the unused variants.

  ```moonbit
  enum T {
    A
    B
  }
  ```


================================================
File 271: /data/input/moonbit-docs/next/language/error_codes/E1007.md
================================================
# E1007

Field is never read. This include fields in structs and fields in enum
constructors.

## Erroneous example

For enum constructor fields:

```moonbit
enum E {
  A(Int) // Warning: The 1st positional argument of constructor 'A' is unused.
  B(value~ : Int) // Warning: Field 'value' of constructor 'B' is unused.
}

fn main {
  ignore(B(value=1))
  match A(1) {
    A(_) => println("A")
    B(_) => println("B")
  }
}
```

For struct fields:

```moonbit
struct S {
  value : Int // Warning: Field 'value' is never read
}

fn main {
  ignore(S::{ value : 1 })
}
```

## Suggestion

If the fields in enum constructors are unused, you can expand them in the
pattern to use them:

```moonbit
fn main {
  // ...
  match A(1) {
    A(x) => println("A(\{x})")
    B(value~) => println("B(\{value})")
  }
}
```

If the fields in structs are unused, you can list them in record pattern, or use
the dot-syntax to access them:

```moonbit
fn main {
  let s = S::{ value : 1 }
  match s {
    { value } => println("S(\{value})")
  }
  println("S(\{s.value})")
}
```

Or, if the fields are indeed useless, you can remove the field from the
constructor:

```moonbit
enum E {
  A
  B
}
```

```moonbit
struct S {
}
```


================================================
File 272: /data/input/moonbit-docs/next/language/error_codes/E1008.md
================================================
# E1008

The modifier (`pub`/`priv`) is redundant here, since this field has such
visibility by default.

## Erroneous example

```moonbit
struct A {
  priv value : Int
  // Warning: The private modifier is redundant here
  //          since field value is private by default
}

pub struct B {
  pub value : Int
  // Warning: The public modifier is redundant here
  //          since field value is public by default
}
```

## Suggestion

Remove the visibility modifier on the field.

```moonbit
struct A {
  value : Int
}

pub struct B {
  value : Int
}
```


================================================
File 273: /data/input/moonbit-docs/next/language/error_codes/E1009.md
================================================
# E1009

The struct is never constructed.

## Erroneous example

```moonbit
pub struct A { // Warning: The struct A is never constructed
  value : Int
}
```

```moonbit
priv struct A { // Warning: The struct A is never constructed
  value : Int
}

fn f(a : A) -> Int {
  a.value
}
```

## Suggestion

The `pub` visibility modifier only allows other packages to access the struct,
by dot-syntax (`a.value`), or by pattern matching. Therefore, if you expect
other packages to be able to construct the struct, you should use the `pub(all)`
visibility modifier.

```moonbit
pub(all) struct A {
  value : Int
}
```

However, if you do not want other packages to construct the struct, this might
be due to incompleteness or bugs in your code. There are some common cases:

- You planned to use smart constructors or factory functions to construct the
  struct, but you forgot or have not implemented them.
- You intend to keep the struct private to control its instantiation but may
  have forgotten to provide a way to do so within its own package.

In these cases, you should consider providing a way to construct the struct
within its own package.

```moonbit
priv struct A {
  value : Int
}

fn A::new(value : Int) -> A {
  A::{ value }
}

fn A::value(self : A) -> Int {
  self.value
}
```


================================================
File 274: /data/input/moonbit-docs/next/language/error_codes/E1010.md
================================================
# E1010

This pattern is unused. This usually happens in pattern matching, and this
pattern is completely covered by a prior pattern.

Pattern matching in MoonBit is executed sequentially, from the first branch to
the last. If a pattern is covered by a prior pattern, it will never be reached,
since all control flow will be directed to the first matching branch.

## Erroneous example

```moonbit
fn main {
  match Some(1) {
    _ => println("_")
    Some(a) => println("Some(\{a})") // Warning: Unused pattern
  }
}
```

## Suggestion

This warning can be usually fixed by swapping the order of the branches in the
pattern matching. If the order of the branches is important, then you may want
to refine the first pattern so that it excludes what the second pattern covers.

```moonbit
fn main {
  match Some(1) {
    Some(a) => println("Some(\{a})")
    _ => println("_")
  }
}
```

Or,

```moonbit
fn main {
  match Some(1) {
    None => println("_")
    Some(a) => println("Some(\{a})")
  }
}
```


================================================
File 275: /data/input/moonbit-docs/next/language/error_codes/E1011.md
================================================
# E1011

Partial match. The match/guard/loop expression does not cover all possible
cases.

## Erroneous example

```moonbit
///|
fn main {
  match Some(1) { // Partial match, some hints: None
    Some(x) => println(x)
  }
}
```

## Suggestion

The warning message usually contains hints about the missing patterns. Add the missing cases to avoid incomplete matches.

```moonbit
fn main {
  match Some(1) {
    Some(x) => println(x)
  }
}
```

Or, you can use `is` syntax to use this pattern matching as a condition:

```moonbit
fn main {
  if Some(1) is Some(x) {
    println(x)
  }
}
```

Or, you can add a wildcard pattern to catch all remaining cases:

```moonbit
fn main {
  match Some(1) {
    Some(x) => println(x)
    _ => println("Other")
  }
}
```


================================================
File 276: /data/input/moonbit-docs/next/language/error_codes/E1012.md
================================================
# E1012

Unreachable code. This usually happens when a `return` statement is followed by
more code. The `return` statement will exit the function immediately, so any
code after it will not be executed.

## Erroneous example

```moonbit
fn main {
  return
  println("Hello, World!")
}
```

## Suggestion

Remove the unreachable code, or move it before the `return` statement if you
want the code to be executed.

```moonbit
fn main {
  println("Hello, World!")
  return
}
```


================================================
File 277: /data/input/moonbit-docs/next/language/error_codes/E1013.md
================================================
# E1013

The type of this expression contains unresolved type variables.

This error occurs when the compiler encounters a type that contains type
variables which cannot be determined from the context. Type variables are
placeholders for types that should be inferred by the compiler.

Common cases where this happens:

1. Writing local functions without explicit type annotations
2. Creating empty collections (Arrays, Options) without specifying their element
   type

When the compiler cannot resolve these type variables, it defaults them to
`Unit` type, which may not be what you intended.

## Erroneous example

```moonbit
pub fn f1() -> Unit {
  fn f(x) {
//     ^ Warning: The type of this expression is Option[_/0], which contains
//                unresolved type variables. The type variable is default to
//                Unit.
    match x {
      None => ()
      Some(a) => println(a)
    }
  }

  f(None)
}

pub fn f2() -> Unit {
  fn f(x : Array[_]) -> Int {
//     ^ Warning: The type of this expression is Array[_/0], which contains
//                unresolved type variables. The type variable is default to
//                Unit.
    x.length()
  }

  println(f([]))
}

fn main {
  let a = []
//        ^^ Warning: The type of this expression is Array[_/0], which contains
//           unresolved type variables. The type variable is default to Unit.
  println(a.length())
  let b = None
//        ^^ Warning: The type of this expression is Option[_/0], which contains
//           unresolved type variables. The type variable is default to Unit.
  println(b.is_empty())
}

```

## Suggestion

To fix this warning, you can:

- Add type annotations to local function parameters. For example,

```moonbit
pub fn f1() -> Unit {
  fn f(x: Option[Int]) {
    match x {
      None => ()
      Some(a) => println(a)
    }
  }
  f(None)
}

pub fn f2() -> Unit {
  fn f(x : Array[Int]) -> Int {
    x.length()
  }
  println(f([]))
}
```

- Explicitly specify the type of the variable or the collection element type.

```moonbit
fn main {
  let a : Array[Int] = []
  println(a.length())
  let b : Option[Int] = None
  println(b.is_empty())
}
```

Or equivalently, add annotations on the collection creation.

```moonbit
fn main {
  let a = ([] : Array[Int])
  println(a.length())
  let b = (None : Option[Int])
  println(b.is_empty())
}
```

- Provide enough context through usage.

```moonbit
pub fn f1() -> Unit {
  fn f(x) {
    match x {
      None => ()
      Some(a) => println(a + 1)
//                       ^^^^^ through this usage, the compiler can infer the
//                             type of `x` is `Option[Int]`.
    }
  }
  f(None)
}
```


================================================
File 278: /data/input/moonbit-docs/next/language/error_codes/E1014.md
================================================
# E1014

Type name should be capitalized. In MoonBit, we recommend using a capitalized type name for all types, including built-in types and user-defined types. This is a convention that is followed by the standard library and most of the community code.

## Erroneous example

```moonbit
struct point {
  x: Int
  y: Int
}
```

## Suggestion

Capitalize the type name.

```moonbit
struct Point {
  x: Int
  y: Int
}
```


================================================
File 279: /data/input/moonbit-docs/next/language/error_codes/E1015.md
================================================
# E1015

The mutability is never used. It is a common mistake to declare an array to be
mutable when it is not necessary. Setting the value of an element in an array
does not require the array to be mutable. For example, `a[0] = 0` does not
require `a` to be mutable, but `a = [0, 1, 2]` does.

## Erroneous example

```moonbit
fn main {
  let mut x = [1, 2, 3] // Warning: The mutability of 'x' is never used.
  x[0] = 0
  println(x)
}
```

## Suggestion

Remove the `mut` keyword from the variable declaration.

```moonbit
fn main {
  let x = [1, 2, 3]
  x[0] = 0
  println(x)
}
```


================================================
File 280: /data/input/moonbit-docs/next/language/error_codes/E1016.md
================================================
# E1016

Parser consistency check failed.

Currently, MoonBit won't emit this warning.


================================================
File 281: /data/input/moonbit-docs/next/language/error_codes/E1018.md
================================================
# E1018

There is no `continue` in this loop expression, so `loop` is useless here.

This error occurs when using a `loop` expression that contains no `continue`
statement. In MoonBit, a `loop` without any `continue` statements is equivalent
to an block expression that will be executed only once, making the `loop`
keyword redundant in such cases. You should either add a `continue` statement if
you need to restart the loop from the beginning, or use a simpler control flow
construct like `match` or `if`.

## Erroneous example

```moonbit
fn countdown(n : Int) -> Int {
  let mut count = n
  loop count {
    _..<0 => break
    _ => count = count - 1
  }
  return count
}
```

## Suggestion

Either add a `continue` statement if you need to restart the loop:

```moonbit
fn countdown(n : Int) -> Int {
  let mut count = n
  loop count {
    _..<0 => break
    _ => {
      continue count - 1
    }
  }
  return count
}
```

Or use `if`/`match` you don't need to use `continue`:

```moonbit
fn countdown(n : Int) -> Int {
  let mut count = n
  match count {
    _..<0 => ()
    _ => count = count - 1
  }
  return count
}
```


================================================
File 282: /data/input/moonbit-docs/next/language/error_codes/E1019.md
================================================
# E1019

Toplevel declaration is not left aligned. Every toplevel structure in MoonBit
should be left-aligned, i.e. there is no space between the beginning of the line
and the declaration.

Sometimes, earlier parsing errors might causing this error to be raised in the
following lines. Therefore, when your are writing local declarations while
seeing this error, you should check the previous lines for any parsing errors.

## Erroneous example

```moonbit
  let x = 1
```

## Suggestion

Remove the leading spaces:

```moonbit
let x = 1
```


================================================
File 283: /data/input/moonbit-docs/next/language/error_codes/E1020.md
================================================
# E1020

Invalid pragma. The pragma either has invalid id, or has invalid properties.

MoonBit compiler support the following pragmas:

- `@alert`. This pragma is used to emit a warning message. It has the following
  format: `@alert <category> "message"`. For example:

  ```moonbit
  ///|
  /// @alert deprecated "This function is deprecated"
  fn deprecated_function() {
    // ...
  }
  ```

- `@coverage.skip`. This pragma indicates that the following declaration should
  be skipped when calculating code coverage. It has the following format:
  `@coverage.skip`. For example:

  ```moonbit
  ///|
  /// @coverage.skip
  fn function_to_skip() {
    // ...
  }
  ```

## Erroneous example

```moonbit
///|
/// @deprecated "This function is deprecated"
fn f() {
  // ...
}
```

## Suggestion

Depending on the pragma you want to use, you should either remove the invalid
pragma, or replace it with a valid one.

```moonbit
///|
/// @alert deprecated "This function is deprecated"
fn f() {
  // ...
}
```


================================================
File 284: /data/input/moonbit-docs/next/language/error_codes/E1021.md
================================================
# E1021

Some arguments of constructor are omitted in pattern.

## Erroneous example

```moonbit
enum E {
  A(Int, w~ : Int, h~ : Int)
}

fn main {
  match A(0, w=1, h=2) {
    A(v, w~) => { // Warning: The argument(s) h of constructor A are omitted.
      println(v)
      println(w)
    }
  }
}
```

## Suggestion

If you want to omit some arguments, add the `..` to the end of the pattern:

```moonbit
fn main {
  match A(0, w=1, h=2) {
    A(v, w~, ..) => {
      println(v)
      println(w)
    }
  }
}
```

Or, you can match all arguments:

```moonbit
fn main {
  match A(0, w=1, h=2) {
    A(v, w~, h~) => {
      println(v)
      println(w)
      println(h)
    }
  }
}
```


================================================
File 285: /data/input/moonbit-docs/next/language/error_codes/E1022.md
================================================
# E1022

Ambiguous block expression. In MoonBit, the expression `{ value }` is ambiguous
because it could be interpreted as a block expression or a struct literal. For
now, we treat it as a struct literal, but writing such expressions is
discouraged.

## Erroneous example

```moonbit
struct S {
  value : Int
}

fn main {
  let value = 3
  let s = { value }
  ignore(s)
}
```

## Suggestion

If you want to construct a struct using the struct literal, you can add a comma
to the end of the struct literal. Or you can call formatter on this buffer to
have the comma added automatically.

```moonbit
fn main {
  let value = 3
  let s = { value, }
  ignore(s)
}
```

If you are using it as a block expression, please remove the braces as it has
only one expression and is equivalent to the expression `value`:

```moonbit
fn main {
  let value = 3
  let s = value
  ignore(s)
}
```


================================================
File 286: /data/input/moonbit-docs/next/language/error_codes/E1023.md
================================================
# E1023

The body of this try expression never raises any error.

## Erroneous example

```moonbit
fn main {
  try {
    println("Hello, world!")
  } catch {
    _ => println("Error")
  }
}
```

## Suggestion

Remove the `try` expression:

```moonbit
fn main {
  println("Hello, world!")
}
```


================================================
File 287: /data/input/moonbit-docs/next/language/error_codes/E1024.md
================================================
# E1024

The error type of this function is never used.

## Erroneous example

```moonbit
fn greet() -> Unit! {
  println("Hello, world!")
}
```

## Suggestion

Remove the error type:

```moonbit
fn greet() -> Unit {
  println("Hello, world!")
}
```


================================================
File 288: /data/input/moonbit-docs/next/language/error_codes/E1026.md
================================================
# E1026

The patterns are complete so the usage of `catch!` is useless. In MoonBit, when
there is only one error type that will be raised in a try block, compiler will
know that the error type is the only one that will be caught. So, there is no
need to use `catch!` in this case.

## Erroneous example

```moonbit
type! E

fn f() -> Unit!E {
  raise E
}

fn g() -> Unit! {
  try {
    f!()
  } catch! {
    E => raise E
  }
}

fn main {
  try {
    g!()
  } catch {
    _ => println("Error")
  }
}
```

## Suggestion

Remove the `!` in the `catch!`:

```moonbit
type! E

fn f() -> Unit!E {
  raise E
}

fn g() -> Unit! {
  try {
    f!()
  } catch {
    E => raise E
  }
}

fn main {
  try {
    g!()
  } catch {
    _ => println("Error")
  }
}
```


================================================
File 289: /data/input/moonbit-docs/next/language/error_codes/E1027.md
================================================
# E1027

The syntax is deprecated. Please refer to the warning message on the reason and potential fix.


================================================
File 290: /data/input/moonbit-docs/next/language/error_codes/E1028.md
================================================
# E1028

Unfinished code. In MoonBit, you can use `...` to mark a piece of code that is incomplete. You can still compile and run the code, but it will cause a runtime error when it is executed.

## Erroneous example

```moonbit
fn f() -> Unit {
  ...
}
```

## Suggestion

Complete the code:

```moonbit
fn f() -> Unit {
  println("Hello, world!")
}
```


================================================
File 291: /data/input/moonbit-docs/next/language/error_codes/E1029.md
================================================
# E1029

Unused package.

## Erroneous example

`moon.mod.json`:

```json
{
  "name": "username/hello",
  "version": "0.1.0",
  "readme": "README.md",
  "source": "src"
}
```

`lib/moon.pkg.json`:

```json
{}
```

`lib/hello.mbt`:

```moonbit
pub fn greeting() -> String {
  "Hello, world!"
}
```

`main/moon.pkg.json`:

```json
{
  "is-main": true,
  "import": [
    "username/hello/lib" // Unused package 'username/hello/lib'
  ]
}
```

`main/main.mbt`:

```moonbit
fn main {
}
```

## Suggestion

Remove the unused package:

`main/moon.pkg.json`:

```moonbit
{
  "is-main": true
}
```


================================================
File 292: /data/input/moonbit-docs/next/language/error_codes/E1030.md
================================================
# E1030

The package alias is empty. The default package alias will be used instead.

## Erroneous example

```json
{
  "is-main": true,
  "import": [
    {
      "path": "username/hello/lib",
      "alias": "" // Warning: The package alias is empty. The default package alias will be used instead.
    }
  ]
}
```

## Suggestion

Use a non-empty alias for the package:

```json
{
  "is-main": true,
  "import": [
    {
      "path": "username/hello/lib",
      "alias": "hello"
    }
  ]
}
```


================================================
File 293: /data/input/moonbit-docs/next/language/error_codes/E1031.md
================================================
# E1031

The optional argument is never supplied. If the optional argument is never
supplied, then it can be safely removed from the parameter list and be used
purely internally as a normal variable.

## Erroneous example

Note, this warning is turned off by default. To enable this warning, you have
to modify the `"warn-list"` of `moon.pkg.json`:

```json
{
  // ...
  "warn-list": "+31"
}
```

`main.mbt`:

```moonbit
fn f(opt~ : Int = 4) -> Int {
  ignore(opt)
  0
}

fn main {
  println(f())
  println(f())
}
```

## Suggestion

You can remove the optional argument, and use a local variable definition
instead:

```moonbit
fn f() -> Int {
  let opt = 4
  ignore(opt)
  0
}

fn main {
  println(f())
  println(f())
}
```


================================================
File 294: /data/input/moonbit-docs/next/language/error_codes/E1032.md
================================================
# E1032

Default value of optional argument is unused. This implies at every call site of this function, the optional argument is always explicitly supplied with a value. This means the optional argument can be refactored into a labelled argument.

## Erroneous example

Note, this warning is turned off by default. To enable this warning, you need to modify the `"warn-list"` of `moon.pkg.json`:

```json
{
  // ...
  "warn-list": "+32"
}
```

`main.mbt`:

```moonbit
fn f(opt~ : Int = 4) -> Int {
  ignore(opt)
  0
}

fn main {
  println(f(opt=3))
  println(f(opt=3))
}
```

## Suggestion

Turn the optional argument into a labelled argument:

```moonbit
fn f(opt~ : Int) -> Int {
  ignore(opt)
  0
}

fn main {
  println(f(opt=3))
  println(f(opt=3))
}
```


================================================
File 295: /data/input/moonbit-docs/next/language/error_codes/E1033.md
================================================
# E1033

The import value is never used directly.

In MoonBit, you can import a value (say `f`) from another package into current
package, so that you don't have to use `@pkg.f` to qualify the value, and you
can just use `f` as if it were defined in this package. However, if `f` is not
used in current package, this warning will be emitted.

## Erroneous example

`lib/moon.pkg.json`:

```json
{}
```

`lib/main.mbt`:

```moonbit
pub fn greeting() -> String {
  "Hello, world!"
}
```

`main/moon.pkg.json`:

```json
{
  "is-main": true,
  "import": [
    {
      "path": "username/hello/lib",
      "alias": "hello",
      "value": [
        "greeting" // Warning: The import value greeting is never used directly.
      ]
    }
  ]
}
```

`main/main.mbt`:

```moonbit
fn main {
  println(@hello.greeting())
}
```

## Suggestion

It is possible that you still use qualified name to access the imported value.
In this case, either remove the imported value from `moon.pkg.json`.

`main/moon.pkg.json`:

```json
{
  // ...
  "import": [
    {
      "path": "username/hello/lib",
      "alias": "hello"
    }
  ]
}
```

Or remove the qualified package name from your code:

`main/main.mbt`:

```moonbit
fn main {
  println(greeting())
}
```


================================================
File 296: /data/input/moonbit-docs/next/language/error_codes/E1034.md
================================================
# E1034

The syntax `~label` is deprecated. We have removed this syntax and this warning
is no longer emitted by the compiler.


================================================
File 297: /data/input/moonbit-docs/next/language/error_codes/E1035.md
================================================
# E1035

The word is reserved for possible future use. Please use another name for it.

Here is a list of reserved name:

- `module`
- `move`
- `ref`
- `static`
- `super`
- `unsafe`
- `use`
- `where`
- `await`
- `dyn`
- `abstract`
- `do`
- `final`
- `macro`
- `override`
- `typeof`
- `virtual`
- `yield`
- `local`
- `method`
- `alias`

## Erroneous example

```moonbit
fn module() -> Int { // Warning: The word `module` is reserved for possible future use. Please consider using another name.
  3
}
```

## Suggestion

```moonbit
fn module_() -> Int {
  3
}
```


================================================
File 298: /data/input/moonbit-docs/next/language/error_codes/E1036.md
================================================
# E1036

The loop label name shadows a label that is already in scope.

Loop labels must be unique within their scope. When a label name is reused
within a nested scope, it shadows the outer label, which can lead to confusion
about which loop is being referenced by `break` or `continue` statements.

This warning helps prevent bugs that could occur when breaking or continuing to
the wrong loop level due to label shadowing. It's recommended to use distinct,
descriptive label names for different loops to make the code's intent clear.

## Erroneous example

```moonbit
fn f(xss : Array[Array[Int]]) -> Unit {
  l~: for xs in xss {
    l~: for x in xs {
//  ^^  Warning: The label name `l` shadows a label name that is already in
//               scope.
      if x > 0 {
        break l~
      }
    }
  }
}
```

## Suggestion

Use distinct, descriptive label names for different loops to make the code's
intent clear.


================================================
File 299: /data/input/moonbit-docs/next/language/error_codes/E1037.md
================================================
# E1037

The loop label name is never used.

## Erroneous example

```moonbit
fn read() -> BytesView {
  ...
}

fn main {
  let mut bytes = []
  read~: loop read() {
    [] => break
    bs => {
      bytes = [..bytes, ..bs]
      continue read()
    }
  }
}
```

## Suggestion

Remove the unused loop label.

```moonbit
fn main {
  let mut bytes = []
  loop {
    let bs = read()
    if bs == [] {
      break
    }
    bytes = [..bytes, ..bs]
  }
}
```


================================================
File 300: /data/input/moonbit-docs/next/language/error_codes/E1038.md
================================================
# E1038

Useless guard because the pattern is irrefutable. A pattern is irrefutable means
it accepts all possible input. If a pattern in guard let accepts all possible
input, then it will always continue on, making the guard useless.

One common mistake is, say if you want to return early on some condition, and
continues otherwise. However, since the pattern matching is evaluated from first
to last, the pattern after `guard let` will be first evaluated and will always
be success. Therefore, such code will not work since all control will continue
on and never returns early.

## Erroneous example

```moonbit
fn f(input : Int?) -> Int {
  guard let _ = input else {
    Some(_..<0) => abort("Invalid input")
  }
  3
}

fn main {
  ignore(f(None))
}
```

## Suggestion

If you want all possible control flows goes through, then you can remove the
guard and just use let expression.

```moonbit
fn f(input : Int?) -> Int {
  let _ = input
  3
}
```

If you fail into the early return mistake, you can switch to `match` expression:

```moonbit
fn f(input : Int?) -> Int {
  match input {
    Some(_..<0) => abort("Invalid input")
    _ => ()
  }
  3
}
```


================================================
File 301: /data/input/moonbit-docs/next/language/error_codes/E1039.md
================================================
# E1039

Method name conflicts with another definition.

```{note}
Methods declared with the syntax `fn f(self : T, ..)` will be promoted to
regular function in the future, declare the method using `fn T::f(..)` to avoid
name clash.
```

## Erroneous example

```moonbit
type A Int

fn f() -> Int {
  3
}

fn f(self : A) -> Int {
  self._
}

fn main {
  println(f())
  println(A(3).f())
}
```

## Suggestion

You can defined the method as `A::f`:

```moonbit
fn T::f(self : A) -> Int {
  self._
}
```

However, defining a method with `T::` prefix makes it impossible to be invoked
as regular function. If you wish to call the method as regular function, then
you have to rename either the method name, or the regular function name to
resolve the name clash.

```moonbit
fn f_(self : A) -> Int {
  self._
}

fn main {
  println(f_(A(3)))
}
```


================================================
File 302: /data/input/moonbit-docs/next/language/error_codes/E1040.md
================================================
# E1040

This method is declared as `T::f`, Calling this kind of method directly via
name(..) is deprecated, use qualified syntax `T::f(..)`, or declare the method
as `fn f(self : A, ..)` instead.

## Erroneous example

```moonbit
type A Int

fn A::f(self : A) -> Int {
  self._
}

fn main {
  let _ = f(A(1))
  // Warning:
  // This method is declared as A::f, calling this kind of method directly via
  // f(..) is deprecated, use qualified syntax A::f(..), or declare the method
  // as `fn f(self : A, ..)` instead.
}
```

## Suggestion

You can either modify the calling of this function at call sites:

```moonbit
fn main {
  let _ = A::f(A(1))
}
```

Or you can define the method as:

```moonbit
fn f(self : A) -> Int {
  self._
}

fn main {
  let _ = f(A(1))
}
```


================================================
File 303: /data/input/moonbit-docs/next/language/error_codes/E2000.md
================================================
# E2000

The usage of function (type, trait, etc.) is flagged with alert. Usually, alert
message comes with a alert kind and a detailed description of the alert. If you
are using the function from a library, these alerts are set by the library
author to provide some more information on the usage of the function

There are some common alerts that you may encounter:

* `deprecated`: indicates the function (or type, trait, etc.) is deprecated and
  should not be used. You should migrate to new APIs.
* `unsafe`: indicates this API may panic, have internal invariants, or have undefined
  behavior under some circumstances. The concrete semantics of this kind of
  alerts may be different across packages, and please consult the documentation
  or the author of these packages for further details.

## Erroneous example

```moonbit
/// @alert deprecated "Use `greet` instead"
fn greeting() -> String {
  "Hello!"
}

fn greet(name~ : String = "") -> String {
  if name != "" {
    "Hello!"
  } else {
    "Hello, \{name}!"
  }
}

fn main {
  println(greeting())
  //      ^~~~~~~~ Warning (Alert deprecated): Use `greet` instead(2000)
}
```

## Suggestion

One way to fix the alert, is to change your code as suggested by the message (like `deprecated`):

```moonbit
// ... code in the example above ...
fn main {
  println(greet(name="world"))
}
```

If you clearly know what you are doing and would like to suppress the alert, you can change the `moon.pkg.json` file for packages where you would like to disable **this kind of alert**. For example:

```moonbit
{
  // ... other fields in the file
  "alert-list": "-deprecated"
}
```

```{note}
There is no way to disable alerts for a line/file.
```


================================================
File 304: /data/input/moonbit-docs/next/language/error_codes/E3001.md
================================================
# E3001

This source files contains invalid or incomplete tokens.

## Erroneous example

```moonbit
fn main {
  println('3)
}
```

This example gives the following error on line 2:

```
Lexing error: unrecognized character u32:0x27
```

... which indicates that the compiler don't know how to interpret
the dangling character `'` (ASCII 0x27) on that line as a part of
a MoonBit token.

## Suggestion

Change your code to strictly follow the MoonBit syntax rules,
so that it only contains valid MoonBit tokens.

In the above example, the missing closing apostrophe should be added:

```moonbit
fn main {
  println('3')
}
```


================================================
File 305: /data/input/moonbit-docs/next/language/error_codes/E3002.md
================================================
# E3002

This source files contains errors in the syntax of the code.

## Erroneous example

```moonbit
fn main() -> Unit {
  println("Hello, world!"
}
```

This example gives the following error on line 3:

```
Parse error, unexpected token `}`, you may expect `,` or `)`.
```

... which indicates a missing closing parenthesis (`)`) in the `println` function call.

## Suggestion

Change your code to strictly follow the MoonBit syntax rules.

In the above example, the missing closing parenthesis should be added:

```moonbit
fn main {
  println("Hello, world!")
}
```


================================================
File 306: /data/input/moonbit-docs/next/language/error_codes/E3003.md
================================================
# E3003

`init` and `main` function must have no arguments and no return value.

## Erroneous example

```moonbit
fn main() -> Unit { // Error: Main function must have no arguments and no return value.
  println("Hello, world!")
}
```

## Suggestion

Remove the argument list and return type annotation, as:

```moonbit
fn main {
  println("Hello, world!")
}
```


================================================
File 307: /data/input/moonbit-docs/next/language/error_codes/E3004.md
================================================
# E3004

Missing parameters list. Add `()` after the name of the function if it takes 0
parameter.

## Erroneous example

```moonbit
fn greet { // Error: Missing parameters list. Add `()` if function `greet` has 0 parameter.
  println("Hello, world!")
}
```

## Suggestion

Add `()` after the function name.

```moonbit
fn greet() {
  println("Hello, world!")
}
```


================================================
File 308: /data/input/moonbit-docs/next/language/error_codes/E3005.md
================================================
# E3005

There is no such visibility for the entity (function/type/trait/...).

Usually, this means that you put an `priv` visibility modifier on a entity is
by-default private.

See the [Access Control](/language/packages.md#access-control) section of for a
detailed explanation on the visibility in MoonBit.

## Erroneous example

```moonbit
priv let value = 3 // Error: No 'priv' visibility for value.
```

## Suggestion

Remove the visibility modifier from the definition of the entity:

```moonbit
let value = 3 // This is already `priv` by default.
```


================================================
File 309: /data/input/moonbit-docs/next/language/error_codes/E3006.md
================================================
# E3006

There is no individual visibility control for enum constructors.

Usually, this means that you put an `priv` or `pub` visibility modifier on a enum constructor.

## Erroneous example

```moonbit
enum A {
  priv A1 // Error: No individual visibility for enum constructor.
  pub A2 // Error: No individual visibility for enum constructor.
}
```

## Suggestion

Remove the visibility modifier from the definition of the enum constructor:

```moonbit
enum A {
  A1
  A2
}
```


================================================
File 310: /data/input/moonbit-docs/next/language/error_codes/E3007.md
================================================
# E3007

Wrong location of `..` in pattern match. Put `..` at the end of the pattern.

## Erroneous example

```moonbit
struct S {
  a : Int
  b : Int
  c : Int
}

fn main {
  let s : S = { a : 1, b : 2, c : 3 }
  let { a, .., c } = s
  //       ^^
  // Error: Unexpected `..` here, add `, ..` behind the last field to ignore the rest of record.
}
```

## Suggestion

```moonbit
// ...
fn main {
  // ...
  let { a, c, .. } = s
}
```


================================================
File 311: /data/input/moonbit-docs/next/language/error_codes/E3008.md
================================================
# E3008

There are multiple `..` patterns in array pattern. Remove until there is only one `..` pattern in array pattern.

## Erroneous example

```moonbit
fn main {
  let array = [1, 2, 3, 4, 5]
  let [fst, .., .., snd] = array
  //            ^^
  // Error: At most one `..` is allowed in array pattern.
}
```

## Suggestion

Remove the extra `..` pattern.

```moonbit
fn main {
  // ...
  let [fst, .., snd] = array
}
```


================================================
File 312: /data/input/moonbit-docs/next/language/error_codes/E3009.md
================================================
# E3009

Record pattern cannot contain only `..`, use wildcard pattern `_` instead.

## Erroneous example

```moonbit
struct Point {
  x: Int
  y: Int
}

fn process_point(p: Point) -> Unit {
  match p {
    { .. } => println("Got a point")
  //^~~~~~
  // Error: Record pattern cannot contain only `..`, use wildcard pattern `_` instead.
  }
}
```

## Suggestion

Use the wildcard pattern `_` instead of `{ .. }`:

```moonbit
struct Point {
  x: Int
  y: Int
}

fn process_point(p: Point) -> Unit {
  match p {
    _ => println("Got a point")
  }
}
```

You can also use `{ .. }` along with other fields if you want to match specific fields:

```moonbit
fn process_point(p: Point) -> Unit {
  match p {
    { x: 0, .. } => println("Point on y-axis")
    _ => println("Other point")
  }
}
```


================================================
File 313: /data/input/moonbit-docs/next/language/error_codes/E3010.md
================================================
# E3010

Only labelled arguments can have default value.

## Erroneous example

```moonbit
fn greet(name : String = "World") -> Unit {
  //                   ^ Error: Only labelled arguments can have default value.
  println("Hello, " + name + "!")
}
```

## Suggestion

Use a labelled argument with `~` if you want to provide a default value:

```moonbit
fn greet(name~ : String = "World") -> Unit {
  println("Hello, " + name + "!")
}

fn main {
  // Can be called as:
  greet() // Uses default value "World"
  greet(name="Alice") // Uses provided value "Alice"
}
```

Or remove the default value if you want to keep it as a positional argument:

```moonbit
fn greet(name: String) -> Unit {
  println("Hello, " + name + "!")
}
```


================================================
File 314: /data/input/moonbit-docs/next/language/error_codes/E3011.md
================================================
# E3011

The assignment contains an invalid left-hand-side (LHS) expression,
such as a constant or a constructor.

## Erroneous example

```moonbit
const N = 4

fn main {
  N = 5 // Error: Invalid left value for assignment.
}
```

## Suggestion

Change the LHS to a valid mutable memory location,
such as a mutable variable or a mutable field:

```moonbit
fn main {
  let mut n = 4
  n = 5
}
```


================================================
File 315: /data/input/moonbit-docs/next/language/error_codes/E3012.md
================================================
# E3012

Record pattern and map pattern cannot be mixed. The key in map pattern must be a
literal, while the key in record pattern must be the field name.

## Erroneous example

```moonbit
struct S {
  value : Int
}

pub fn S::op_get(self : S, index : String) -> Int? {
  if index == "value" {
    return Some(self.value)
  }
  return None
}

fn main {
  let s : S = { value: 42 }
  match s {
    { "value": value, value } => println("Value is: \{value}") // Error: Record pattern and map pattern cannot be mixed.
    _ => println("No value")
  }
}
```

## Suggestion

Remove either the map pattern part or the record pattern part from the pattern.

```moonbit
fn main {
  let s : S = { value: 42 }
  match s {
    { "value": value } => println("Value is: \{value}")
    _ => println("No value")
  }
}
```

Or,

```moonbit
fn main {
  let s : S = { value: 42 }
  match s {
    { value } => println("Value is: \{value}")
  }
}
```


================================================
File 316: /data/input/moonbit-docs/next/language/error_codes/E3014.md
================================================
# E3014

Inline wasm syntax error. MoonBit will check if the inline wasm syntax is correct, including:

- If the parenthesis are correctly matched.
- If the wasm instructions are correctly formatted.

## Erroneous example

```moonbit
extern "wasm" fn i32_load(addr : Int) -> Int = // Error: Inline wasm syntax error: unmatched parenthesis at 1:1-1:57
  #|(func (param i32) (result i32)
  #| (i32.load (local.get 0))
```

## Suggestion

Fix the inline wasm syntax as suggested by the warning message.

```moonbit
extern "wasm" fn i32_load(addr : Int) -> Int =
  #|(func (param i32) (result i32)
  #| (i32.load (local.get 0)))
```


================================================
File 317: /data/input/moonbit-docs/next/language/error_codes/E3015.md
================================================
# E3015

The parameter already has default value `None`.

In MoonBit, the optional parameter has one of the two following forms:

- Optional parameter with default value:

  ```moonbit
  fn f(a~ : Int = 0) -> Unit {
    // ...
  }
  ```

- Optional parameter with no default value. In this case, when the parameter is not provided, it is `None` by default.

  ```moonbit
  fn f(a? : Int) -> Unit { // a has type Int?
    // ...
  }
  ```

Therefore, if the optional parameter has a default value of `None`, it is redundant and should be removed.

## Erroneous example

```moonbit
fn f(a? : Int = None) -> Unit { // Error: The parameter a? already has default value `None`.
  println(a)
}
```

## Suggestion

Remove the `= None` part from the optional parameter.

```moonbit
fn f(a? : Int) -> Unit {
  println(a)
}
```


================================================
File 318: /data/input/moonbit-docs/next/language/error_codes/E3016.md
================================================
# E3016

Unexpected `~` in argument. Did you mean `label=pattern` or `label~`?

## Erroneous example

```moonbit
enum A {
  A(b~ : Int)
}

fn main {
  match A(b=1) {
    A(b~=c) => {
      println("Hello, world! \{c}") // Error: unexpected `~` in argument. Did you mean `label=pattern` or `label~`?
    }
  }
}
```

## Suggestion

Replace `b~` with `b=` or `b~` as appropriate.

```moonbit
enum A {
  A(b~ : Int)
}

fn main {
  match A(b=1) {
    A(b~) => {
      println("Hello, world! \{b}")
    }
  }
}
```

Or,

```moonbit
enum A {
  A(b~ : Int)
}

fn main {
  match A(b=1) {
    A(b=c) => {
      println("Hello, world! \{c}")
    }
  }
}
```


================================================
File 319: /data/input/moonbit-docs/next/language/error_codes/E3017.md
================================================
# E3017

JSON parse error. This will only appear in `moon.pkg.json` files only.

It is very like that the editor you are using will have support for JSON
installed (for example, Visual Studio Code has a built-in JSON parser). This
error is likely to be caused by a missing comma or a missing closing brace.

## Erroneous example

```json
{
  "is-main": true
  "import": [] // Error: Expect_comma_or_rbrace
}
```

## Suggestion

```json
{
  "is-main": true,
  "import": []
}
```


================================================
File 320: /data/input/moonbit-docs/next/language/error_codes/E3018.md
================================================
# E3018

Bounds of range pattern must be constant, named constant or wildcard.

## Erroneous example

```moonbit
fn main {
  let a = 3
  match 0 {
    0..<a => println("Between 0 and 3") // Error: Bounds of range pattern must be constant, named constant or wildcard.
    _ => println("Not between 0 and 3")
  }
}
```

## Suggestion

You can either lift the variable `a` to a named constant:

```moonbit
const A = 3
fn main {
  match 0 {
    0..<A => println("Between 0 and 3")
    _ => println("Not between 0 and 3")
  }
}
```

Or, you can use the constant value directly:

```moonbit
fn main {
  match 0 {
    0..<3 => println("Between 0 and 3")
    _ => println("Not between 0 and 3")
  }
}
```

Or, you can use a wildcard:

```moonbit
fn main {
  let a = 3
  match 0 {
    0..<_ => println("Big than or equal to 0")
    _ => println("Less than 0")
  }
}
```

Notice, using wildcard alters the meaning of this range pattern.


================================================
File 321: /data/input/moonbit-docs/next/language/error_codes/E3019.md
================================================
# E3019

Inclusive range pattern `a..=b` cannot have `_` as upper bound.

Writing `a..=_` does not make sense, because `_` is a wildcard that matches any
value. It is unclear what does "equals to any value" mean. If you want to
express the meaning of "greater than or equal to `a`", you can use `a..<_`
instead.

## Erroneous example

```moonbit
fn main {
  match 0 {
    0..=_ => println("Big than or equal to 0")
    //  ^
    // Error: Inclusive range pattern `a..=b` cannot have `_` as upper bound
    _ => println("Less than 0")
  }
}
```

## Suggestion

Replace `=` with `<`:

```moonbit
fn main {
  match 0 {
    0..<_ => println("Big than or equal to 0")
    _ => println("Less than 0")
  }
}
```


================================================
File 322: /data/input/moonbit-docs/next/language/error_codes/E3020.md
================================================
# E3020

Unexpected `=` in struct expression. The correct syntax for struct expression is
`{ field: expression }`.

## Erroneous example

```moonbit
struct S {
  a : Int
  b : Int
}

fn main {
  let s : S = { a : 1, b : 2 }
  let ss = { ..s, a = 1 } // Error: Unexpected `=` in struct expression.
  ignore(ss)
}
```

## Suggestion

Change the struct expression to use the correct syntax:

```moonbit
struct S {
  a : Int
  b : Int
}

fn main {
  let s : S = { a : 1, b : 2 }
  let ss = { ..s, a : 1 }
  ignore(ss)
}
```


================================================
File 323: /data/input/moonbit-docs/next/language/error_codes/E3800.md
================================================
# E3800

Expecting a newline or `;` here, but encountered another delimiter.

Constructors in `enum` definition, fields in `struct` definition, and
constructors in error type `type!` definition, should be separated by a newline
or a `;`. It is so common for AI to generate code with a wrong delimiter `,`
that we specifically catch this error to help you and AI fix it.

## Erroneous example

```moonbit
enum V {
  A, // Error: Expecting a newline or `;` here, but encountered another delimiter `,`.
}

struct S {
  a : Int, // Error: Expecting a newline or `;` here, but encountered another delimiter `,`.
}

type! E {
  A, // Error: Expecting a newline or `;` here, but encountered another delimiter `,`.
}
```

## Suggestion

Replace `,` with a newline or `;` as appropriate. We suggest using a newline
since it conforms to the MoonBit style suggested by the MoonBit formatter.

```moonbit
enum V {
  A
}

struct S {
  a : Int
}

type! E {
  A
}
```


================================================
File 324: /data/input/moonbit-docs/next/language/error_codes/E4000.md
================================================
# E4000

Generic type variable name is already used.

## Erroneous example

```moonbit
struct Container[T, T] {
  value : T
}

fn transform[A, A](x : A) -> A {
  x
}
```

## Suggestion

Use different names for type variables:

```moonbit
struct Container[T1, T2] {
  value : T1
}

fn transform[A, B](x : A) -> B {
  // ... implementation
}
```

Or remove the duplicate type parameter if you meant to use the same type:

```moonbit
struct Container[T] {
  value : T
}

fn transform[A](x : A) -> A {
  x
}
```


================================================
File 325: /data/input/moonbit-docs/next/language/error_codes/E4001.md
================================================
# E4001

A field with incompatible visibility cannot be declared within a struct.

The following visibility combinations are allowed:

- A public field within a public struct, although it will emit a warning
  [E1008](./E1008.md).
- A private field within a public struct.
- A private field within a private struct, emitting [E1008](./E1008.md) as well.

## Erroneous Example

```moonbit
priv struct S {
  pub field: Int
}
```

This example declares a field with public visibility within
a struct with private visibility, which is not allowed and will give
the following error on line 2:

```
A public field cannot be declared within a private struct.
```

## Suggestion

Change the visibility of the field to match the visibility of the struct:

```moonbit
priv struct S {
  field: Int
}
```

We could have written `priv field: Int` instead of `field: Int` as well,
but it is not necessary, as all fields in a private struct are private
by default.


================================================
File 326: /data/input/moonbit-docs/next/language/error_codes/E4002.md
================================================
# E4002

The modifier is not supported here.

## Erroneous Example

```moonbit
pub struct S {
  pub(open) field: Int
}
```

This example declares a field with the `pub(open)` visibility modifier,
which is not allowed and will give the following error on line 2:

```
The public open modifier is not supported here
```

## Suggestion

Change the visibility of the field to match the visibility of the struct:

```moonbit
pub struct S {
  field: Int
}
```

We could have written `pub field: Int` instead of `field: Int` as well,
but it is not necessary, as all fields in a public struct are public
by default.


================================================
File 327: /data/input/moonbit-docs/next/language/error_codes/E4003.md
================================================
# E4003

This is a reserved type name. Cannot declare it as a type variable, type, or trait.

## Erroneous Example

```moonbit
struct Error {}
```

`Error` is the reserved name for the built-in error type, so it cannot be used for a
custom type. This will give the following error on line 1:

```
"Error" is a reserved type name. Cannot declare it as type
```

## Suggestion

Consider using another name for your type, such as `MyError` or `Error_`.

```moonbit
struct MyError {}
```


================================================
File 328: /data/input/moonbit-docs/next/language/error_codes/E4004.md
================================================
# E4004

Trait methods cannot have type parameters (be polymorphic).
MoonBit currently does not support generic/polymorphic methods within trait definitions.

## Erroneous Example

```moonbit
trait Stringer {
  stringify[T: Show](Self, T) -> String
}
```

## Suggestion

Consider using dynamic dispatch instead of generics:

```moonbit
trait Stringer {
  stringify(Self, &Show) -> String
}
```


================================================
File 329: /data/input/moonbit-docs/next/language/error_codes/E4005.md
================================================
# E4005

This error occurs when a trait has multiple declarations of the same method name. Each method in a trait must have a unique name to avoid ambiguity.

## Erroneous example

```moonbit
trait Animal {
  make_sound(Self) -> String
  make_sound(Self) -> String  // Error: method make_sound is declared twice
}
```

## Suggestion

Remove the duplicate method declaration and keep only one definition for each method name:

```moonbit
trait Animal {
  make_sound(Self) -> String  // Only declare the method once
}
```

If you need different method behaviors, use distinct method names:

```moonbit
trait Animal {
  make_sound(Self) -> String
  make_loud_sound(Self) -> String  // Use a different name for different behavior
}
```


================================================
File 330: /data/input/moonbit-docs/next/language/error_codes/E4006.md
================================================
# E4006

This error occurs when the same local function name is declared multiple times within the same scope. Each local function name must be unique within its scope.

## Erroneous Example

```moonbit
fn main {
  fn helper() {
    1 + 1
  }

  fn helper() { // E4006: local function 'helper' is already defined
    2 + 2
  }

  helper()
}
```

## Suggestion

To fix this error, give each local function a unique name:

```moonbit
fn main {
  fn helper1() {
    1 + 1
  }

  fn helper2() {
    2 + 2
  }

  helper1()
  helper2()
}
```

You can also move one of the functions to a different scope or merge the functionality into a single function if they serve similar purposes.


================================================
File 331: /data/input/moonbit-docs/next/language/error_codes/E4007.md
================================================
# E4007

Enum variants without payloads are considered as singleton values. MoonBit does
not allow such constructors to be called as functions.

## Erroneous example

```moonbit
enum Status {
  Done
  Pending
}

fn main {
  let status = Done() // Error: constructor without payload cannot be called with ()
}
```

## Suggestion

Remove the function calling syntax from the constructor:

```moonbit
// ...
fn main {
  let status = Done
}
```

If you really need the constructor to construct values, explicitly use `Unit` as
its argument

```moonbit
enum Status {
  Done(Unit)
  Pending
}

fn main {
  let status = Done(())
}
```


================================================
File 332: /data/input/moonbit-docs/next/language/error_codes/E4008.md
================================================
# E4008

FFI function cannot have type parameters.

## Erroneous Example

```moonbit
extern "js" fn id[T](x: T) -> T = "(x) => x"
```

The example declares an FFI function (marked `extern`) with a type parameter,
which is not allowed.

## Suggestion

Consider using a concrete type that suits your needs:

```moonbit
extern "js" fn int_id(x: Int) -> Int = "(x) => x"
```

For more complicated scenarios, consider adding an extra trait:

```moonbit
///|
trait Ider {
  id(Self) -> Self
}

///|
impl Ider for Int with id(self) { int_id(self) }
```


================================================
File 333: /data/input/moonbit-docs/next/language/error_codes/E4009.md
================================================
# E4009

Match function expects a different number of arguments than provided.

## Erroneous Example

```moonbit
let f = fn {
  0 => 0
  a, b => a + b
}
```

The example defines a match function that has incoherent number of arguments in
different branches. This will result in the following error on line 3:

```
Match function expects 1 arguments, but 2 arguments are provided.
```

## Suggestion

Change the branches so that the number of arguments are exactly the same in all
of them:

```moonbit
let f = fn {
  0 => 0
  a => a
}
```


================================================
File 334: /data/input/moonbit-docs/next/language/error_codes/E4010.md
================================================
# E4010

`pub` is not allowed on default implementation for traits. The default
implementation has the same visibility as the trait itself.

## Erroneous Example

```moonbit
pub(open) trait Stringer {
  stringify(Self) -> String
}

pub impl Stringer with stringify(_self) { "hey" }
```

In the example above, the `pub` keyword is used on the default implementation of
the `Stringer` trait, which is not allowed.

## Suggestion

Remove the `pub` keyword so that the default implementation has the same
visibility as the trait itself:

```moonbit
pub(open) trait Stringer {
  stringify(Self) -> String
}

impl Stringer with stringify(_self) { "hey" }
```


================================================
File 335: /data/input/moonbit-docs/next/language/error_codes/E4011.md
================================================
# E4011

Type parameters are not allowed on default implementation for traits.

## Erroneous Example

```moonbit
pub(open) trait Stringer {
  stringify(Self) -> String
}

impl[T] Stringer with stringify(_self) { "hey" }
```

The example above uses a type parameter `T` on the default implementation
of the `Stringer` trait, which is not allowed.

## Suggestion

Remove the type parameter from the default implementation:

```moonbit
pub(open) trait Stringer {
  stringify(Self) -> String
}

impl Stringer with stringify(_self) { "hey" }
```


================================================
File 336: /data/input/moonbit-docs/next/language/error_codes/E4012.md
================================================
# E4012

Mutable constructor fields are only allowed on labelled arguments.

## Erroneous Example

```moonbit
enum E {
  F(mut x : Int)
}
```

The example above declares an unlabeled mutable field `x` in the
constructor of the `F` variant of the `E` enum, which is not allowed.

## Suggestions

Add a label to the mutable field:

```moonbit
enum E {
  F(mut x~ : Int)
}
```


================================================
File 337: /data/input/moonbit-docs/next/language/error_codes/E4013.md
================================================
# E4013

This function has a type which expects a different number of arguments than provided.

## Erroneous Example

```moonbit
fn f() -> (() -> Int) {
  fn (x: Int) { x }
}
```

The example above declares a function `f` returns a function which expects no
arguments, but returns a function that expects one argument. This will give the
following error on line 2:

```
This function has type () -> Int, which expects 0 argument(s), but is given 1 argument(s).
```

## Suggestion

Adjust the code so that the number of arguments in the function type matches the number
of arguments in the function definition:

```moonbit
fn f() -> ((Int) -> Int) {
  fn (x: Int) { x }
}
```

... or:

```moonbit
fn f(x: Int) -> (() -> Int) {
  fn() { x }
}
```


================================================
File 338: /data/input/moonbit-docs/next/language/error_codes/E4014.md
================================================
# E4014

Type Mismatch.

## Erroneous Example

```moonbit
fn fst[X, Y] (a: X, b: Y) -> X {
  b
}
```

The above example returns a value `b` of type `Y` on line 2,
which is not the same as the return type `X` of the function.

## Suggestion

Please make sure to return a value of the same type as the return type
of the function.

For instance, in the example above, you may write:

```moonbit
fn fst[X, Y] (a: X, b: Y) -> X {
  a
}
```


================================================
File 339: /data/input/moonbit-docs/next/language/error_codes/E4015.md
================================================
# E4015

Type has no method with the specified name.

## Erroneous Example

```moonbit
let hey = "hey".upper()
```

The above example tries to call an inexistent method `upper()`
on a string literal, giving the following error on line 1:

```
Type String has no method upper.
```

## Suggestion

This is usually a typo or a misunderstanding of the methods available.
Please make sure to use the correct method name:

```moonbit
let hey = "hey".to_upper()
```


================================================
File 340: /data/input/moonbit-docs/next/language/error_codes/E4016.md
================================================
# E4016

Please implement the required method for the type to use the infix operator.

## Erroneous Example

```moonbit
struct S { v : Int }

let s : S = { v: 3 }
let t = s + s
```

The example above tries to use the infix operator `+` on a type `S`
that does not implement the required method `op_add`,
giving the following error on line 4:

```
Please implement the method op_add for the type S to use the infix operator "+".
```

## Suggestion

Implement the required method for the type `S`:

```moonbit
struct S { v : Int }

let s : S = { v: 3 }
let t = s + s

fn S::op_add(self : S, other : S) -> S {
  { v: self.v + other.v }
}
```


================================================
File 341: /data/input/moonbit-docs/next/language/error_codes/E4017.md
================================================
# E4017

Method of type is ambiguous, it may come from multiple traits.

## Erroneous Example

```moonbit
struct S { v : Int } derive(Show)

trait Tee { to_string(Self) -> String }

impl Tee for S with to_string(_self) { "Tee" }

let s : S = { v: 3 }
let t = s.to_string()
```

The example above tries to call the method `to_string` on a type `S`,
but the method name comes from both `Show` and `Tee` traits,
giving the following error on line 8:

```
Method to_string of type S is ambiguous, it may come from trait Tee or Show
```

## Suggestion

Disambiguate the method by specifying the trait it comes from:

```moonbit
struct S { v : Int } derive(Show)

trait Tee { to_string(Self) -> String }

impl Tee for S with to_string(_self) { "Tee" }

let s : S = { v: 3 }
let t = Tee::to_string(s)
```


================================================
File 342: /data/input/moonbit-docs/next/language/error_codes/E4018.md
================================================
# E4018

Cannot resolve trait for the given type.

## Erroneous Example

```moonbit
struct S { v : Int }

let s : S = { v: 3 }
let t = Show::to_string(s)
```

The example above tries to call the method `to_string` from
the `Show` trait on a type `S`, but since `S` does not implement
that trait, it gives the following error on line 4:

```
Type S does not implement trait Show: method output is missing
```

## Suggestion

Implement the `Show` trait for the type `S`:

```moonbit
struct S { v : Int }

let s : S = { v: 3 }
let t = Show::to_string(s)

impl Show for S with output(self, logger) {
  logger.write_object(self.v)
}
```


================================================
File 343: /data/input/moonbit-docs/next/language/error_codes/E4019.md
================================================
# E4019

The label is declared twice in this function.

## Erroneous Example

```moonbit
fn f(g~ : Int, g~ : String) -> Int {
  g
}
```

The above example declares the label `g` twice in the function `f`,
which is not allowed and gives the following error on line 1:

```
The label g~ is declared twice in this function, first in <FILE>.mbt:1:6
```

## Suggestion

Rename one of the labels to avoid the conflict:

```moonbit
fn f(g~ : Int, h~ : String) -> Int {
  g
}
```


================================================
File 344: /data/input/moonbit-docs/next/language/error_codes/E4020.md
================================================
# E4020

Package not found in the loaded packages.

## Erroneous Example

```moonbit
let a = @boolean.to_int(true)
```

The example above tries to call the method `to_int` in a package `boolean`,
but this package is not present in the list of loaded packages,
giving the following error on line 1:

```
Package "boolean" not found in the loaded packages.
```

## Suggestion

Make sure the package name is valid.

If it is not a package in module `moonbitlang/core`, make sure that it is
mentioned as one of the imported packages in `moon.pkg.json` as well.

In the above example, the package name should be `@bool` instead of `@boolean`:

```moonbit
let a = @bool.to_int(true)
```


================================================
File 345: /data/input/moonbit-docs/next/language/error_codes/E4021.md
================================================
# E4021

The value identifier is unbound.

## Erroneous Example

```moonbit
let a = @bool.to_integer(true)
```

The example above tries to call the function `to_integer` in a package `@bool`,
but this function is not present in the package `@bool`,
giving the following error on line 1:

```
Value to_integer not found in package `bool`.
```

## Suggestion

Make sure the identifier is correct.

In the above example, the function name should be `to_int` instead of `to_integer`:

```moonbit
let a = @bool.to_int(true)
```


================================================
File 346: /data/input/moonbit-docs/next/language/error_codes/E4023.md
================================================
# E4023

The trait is not found.

## Erroneous Example

```moonbit
let a = true as &Sh0w
```

The example above tries to cast a boolean value to an object
of the `Sh0w` trait, but this trait is not found in the current scope,
giving the following error on line 1:

```
The trait Sh0w is not found.
```

## Suggestion

Make sure the trait name is correct:

```moonbit
let a = true as &Show
```


================================================
File 347: /data/input/moonbit-docs/next/language/error_codes/E4024.md
================================================
# E4024

The type/trait is not found.

## Erroneous Example

```moonbit
let a = Sh0w::to_string(true)
```

The example above tries to call the method `to_string` from the `Sh0w` type
(or trait), but this type (or trait) is not found in the current scope,
given the following error on line 1:

```
The type/trait Sh0w is not found.
```

## Suggestion

Make sure the type (or trait) name is correct.

In the above example, you can choose to use a proper trait name `Show`:

```moonbit
let a = Show::to_string(true)
```

... or a proper type name `Bool`:

```moonbit
let a = Bool::to_string(true)
```


================================================
File 348: /data/input/moonbit-docs/next/language/error_codes/E4025.md
================================================
# E4025

Method has been defined for multiple types.

## Erroneous Example

```moonbit
let a = to_string(true)
```

The example above tries to call the method `to_string` on a boolean value,
but this method has already been defined for multiple types so that
the compiler cannot properly deduce which method to call,
giving the following error on line 1:

```
Method to_string has been defined for the following types:
<FILE>.mbt:<LINE>:<COLUMN> String
<FILE>.mbt:<LINE>:<COLUMN> Int64
<SNIP>
```

## Suggestion

Disambiguate the method by specifying the type it comes from:

```moonbit
let a = Bool::to_string(true)
```


================================================
File 349: /data/input/moonbit-docs/next/language/error_codes/E4026.md
================================================
# E4026

The field is not found.

## Erroneous Example

```moonbit
struct T { a : Int }
fn main {
  let t = { b: 42 }
}
```

The example above tries to create a record with a field `b`,
but no record with such a field is found in the current scope,
giving the above error on line 3.

## Suggestion

Make sure a record is available in the current scope,
defined with the correct field name:

```moonbit
struct T { a : Int }
fn main {
  let t = { a: 42 }
}
```

... in the fix above, `t` is inferred to be of type `T`.


================================================
File 350: /data/input/moonbit-docs/next/language/error_codes/E4027.md
================================================
# E4027

Unused type parameter.

## Erroneous Example

```moonbit
fn id[T](a: Int) -> Int { a }
```

The example above declares a type parameter `T` in the identity function `id`,
however `T` is not used anywhere in the function signature,
giving the following error on line 1:

```
Unused type parameter 'T'
```

## Suggestion

Make sure the type parameter is used in the function signature:

```moonbit
fn id[T](a: T) -> T { a }
```


================================================
File 351: /data/input/moonbit-docs/next/language/error_codes/E4028.md
================================================
# E4028

This expression has a type which is not a record.

## Erroneous Example

```moonbit
struct T { a : Int }
let a : Int = { a: 42 }
```

The example above tries to assign a record to a variable `a` of type `Int`,
which is not possible and gives the following error on line 2:

```
This expression has type Int, which is a Int type and not a record.
```

## Suggestion

Make sure to use the correct type instead:

```moonbit
struct T { a : Int }
let a : T = { a: 42 }
```


================================================
File 352: /data/input/moonbit-docs/next/language/error_codes/E4029.md
================================================
# E4029

This expression has a type which is not a variant.

## Erroneous Example

```moonbit
fn main {
  fn f {
    (a, b) => a + b
  }
  let a = f(None)
}
```

The example above tries to call a function `f` with a value `None`,
which is a variant of the `Option[_]` type, but `f` only accepts a tuple,
giving the following error on line 5:

```
This expression has type (Int, Int), which is a tuple type and not a variant.
```

## Suggestions

Make sure to use a value of the correct type instead:

```moonbit
fn main {
  fn f {
    (a, b) => a + b
  }
  let a = f((3, 4))
}
```


================================================
File 353: /data/input/moonbit-docs/next/language/error_codes/E4030.md
================================================
# E4030

The record type does not have the specified field.

## Erroneous Example

```moonbit
struct T { a : Int }
let t : T = { a: 42 }
let u : T = { ..t, b: 43 }
```

The example above tries to assign an updated record with a field `b`
to a variable `u` of type `T`, but this field doesn't exist,
giving the following error on line 3:

```
The record type T does not have the field b.
```

## Suggestion

Make sure to use the correct field instead:

```moonbit
struct T { a : Int }
let t : T = { a: 42 }
let u : T = { ..t, a: 43 }
```


================================================
File 354: /data/input/moonbit-docs/next/language/error_codes/E4031.md
================================================
# E4031

The constructor is not found.

## Erroneous Example

```moonbit
enum U { V }
let v : U = W
```

The example above tries to assign a variant `W` to a variable `v` of type `U`,
but this variant doesn't exist, giving the following error on line 2:

```
The variant type U does not have the constructor W.
```

## Suggestion

Make sure to use the correct constructor instead:

```moonbit
enum U { V }
let v : U = V
```


================================================
File 355: /data/input/moonbit-docs/next/language/error_codes/E4032.md
================================================
# E4032

The type is undefined.

Currently, MoonBit won't emit this error.


================================================
File 356: /data/input/moonbit-docs/next/language/error_codes/E4033.md
================================================
# E4033

There is no record definition with the specified fields.

## Erroneous Example

```moonbit
fn main {
  struct S { x : Int; y : Int }
  let c = { x: 2, w: 1 }
}
```

The example above tries to assign a record with fields `x` and `w` to a variable `c`,
but this field doesn't exist in any known record type, giving the following error on line 3:

```
There is no record definition with the fields: x, w.
```

## Suggestion

Make sure to use the correct field identifiers instead:

```moonbit
fn main {
  struct S { x : Int; y : Int }
  let c = { x: 2, y: 1 }
}
```


================================================
File 357: /data/input/moonbit-docs/next/language/error_codes/E4034.md
================================================
# E4034

Multiple possible record types detected, please add more annotation.

## Erroneous Example

```moonbit
fn main {
  struct S { x : Int; y : Int }
  struct T { x : Int; y : Int }
  let c = { x: 2, y: 1 }
}
```

The example above tries to assign a record with fields `x` and `y` to a variable `c`,
but this field combination matches both `S` and `T` types, giving the following error on line 4:

```
Multiple possible record types detected: T, S, please add more annotation.
```

## Suggestion

Disambiguate the record type by adding a type annotation:

```moonbit
fn main {
  struct S { x : Int; y : Int }
  struct T { x : Int; y : Int }
  let c : S = { x: 2, y: 1 }
  let c2 = S::{ x : 2, y : 1 }
}
```


================================================
File 358: /data/input/moonbit-docs/next/language/error_codes/E4036.md
================================================
# E4036

Cannot create values of the read-only type.

## Erroneous Example

In `lib/lib.mbt`, we declare a struct `R` with a private field `__private`:

```moonbit
pub(all) struct R {
  x : Int
  priv __private : Int
}

pub fn R::new(x: Int) -> R {
  {x, __private: 42}
}
```

In `main/main.mbt`, we try to create a value of type `R`:

```moonbit
let r : @lib.R = { x: 1, __private: 42 }
```

This gives the following error on line 1:

```
Cannot create values of struct type @lib.R because it contains private field(s).
```

## Suggestion

Construct the value using the public constructor:

```moonbit
let r : @lib.R = @lib.R::new(1)
```


================================================
File 359: /data/input/moonbit-docs/next/language/error_codes/E4037.md
================================================
# E4037

Cannot perform action: package is not imported.

## Erroneous Example

In `main/main.mbt`, we try to call a function from `@middle`:

```moonbit
fn main {
  let a = @middle.return_Obj().m()
}
```

In `middle/middle.mbt`, we define a function that returns an
object of a trait `Obj` defined in `@ty`:

```moonbit
pub fn return_Obj() -> &@ty.Obj {
  @ty.T(42)
}
```

In `ty/ty.mbt`, we define a trait `Obj` and a type `T` that
implements it:

```moonbit
pub(all) type T Int

pub fn f(self: T) -> Unit {
  println(self._)
}

pub(open) trait Obj {
  f(Self) -> Unit
}
```

... but in `main/moon.pkg.json` there is no mention of `@ty`:

```json
{
  "import": ["<PACKAGE>/middle"]
}
```

This gives the following error on line 2 of `main/main.mbt`:

```
Cannot call method of type &@<PACKAGE>/ty.Obj: package @<PACKAGE>/ty is not imported.
```

## Suggestion

Make sure that all relevant packages are imported.

In the above example, this means importing both `@middle` and `@ty` in `main/moon.pkg.json`:

```json
{
  "import": ["<PACKAGE>/middle", "<PACKAGE>/ty"]
}
```


================================================
File 360: /data/input/moonbit-docs/next/language/error_codes/E4038.md
================================================
# E4038

Trait object for the type is not allowed.

## Erroneous Example

```moonbit
fn main {
  let a = 3 as &Eq
}
```

The example above tries to create an object of the `Eq` trait.
This is not allowed, as the trait is not object safe.

The `Eq` trait is defined as follows:

```moonbit
pub(open) trait Eq {
  op_equal(Self, Self) -> Bool
}
```

... which is why the following error is given on line 2:

```
Trait object for Eq is not allowed: `Self` occur multiple times in the type of method op_equal
```

## Suggestion

Use an object-safe trait to create a trait object.

For a trait to be object-safe, its dispatchable functions must use and only use the `Self`
type as the first parameter. For example, `Show` is such a trait:

```moonbit
pub(open) trait Show {
  output(Self, &Logger) -> Unit
  to_string(Self) -> String
}
```


================================================
File 361: /data/input/moonbit-docs/next/language/error_codes/E4039.md
================================================
# E4039

There is no method with the specified name in this trait.

## Erroneous Example

```moonbit
let a : String = Show::to_str(42)
```

The example above tries to call the method `to_str` on the `Show` trait,
but the method is not defined in the trait, giving the following error on line 1:

```
There is no method to_str in trait Show
```

## Suggestion

Make sure that the method name is spelled correctly
and that it is defined in the trait:

```moonbit
let a : String = Show::to_string(42)
```


================================================
File 362: /data/input/moonbit-docs/next/language/error_codes/E4040.md
================================================
# E4040

The type constructor expects a different number of arguments than provided.

## Erroneous Example

```moonbit
let a : Option = Some(3)
```

The example above tries to create an instance of the `Option` type.
The `Option` type is a generic type that expects a single type argument,
but the example does not provide any type arguments,
giving the following error on line 1:

```
The type constructor Option expects 1 argument(s), but is here given 0 argument(s).
```

## Suggestion

Make sure to provide the correct number of type arguments:

```moonbit
let a : Option[Int] = Some(3)
```


================================================
File 363: /data/input/moonbit-docs/next/language/error_codes/E4041.md
================================================
# E4041

Partial type is not allowed in toplevel declarations.

## Erroneous Example

```moonbit
let a : Option[_] = Some(3)
```

The example above tries to create a top-level instance of the `Option[_]` type.
However, partial type annotations are not allowed in toplevel declarations,
giving the aforementioned error on line 1.

## Suggestion

Make sure to provide a complete type annotation:

```moonbit
let a : Option[Int] = Some(3)
```


================================================
File 364: /data/input/moonbit-docs/next/language/error_codes/E4042.md
================================================
# E4042

Invalid stub type.

When defineing a FFI, the stub type must be a valid type, namely they can be
represented natively at corresponding backends.

For example, you cannot use `FixedArray[T]` and `String` in FFI definition on
WASM linear backend.

## Erroneous Example

On WASM linear backend:

```moonbit
fn ffi(array : FixedArray[Int]) -> Unit = "mod" "ffi"
//             ^~~~~~~~~~~~~~~ Error: Invalid stub type.
```

## Suggestion

The way to pass non-native types through the FFI interface depends on both the
backend of the MoonBit compiler and the runtime you are using. For example, if
you wish to pass an array of int to the JS host with the WASM linear backend,
you can pass the int one by one to the host function and store the array on the
JS side.

```moonbit
type JsArray
fn make_js_array() -> JsArray = "mod" "make_js_array"
fn push_js_array(array : JsArray, value : Int) -> Unit = "mod" "push_js_array"
```


================================================
File 365: /data/input/moonbit-docs/next/language/error_codes/E4043.md
================================================
# E4043

The record field is defined or matched multiple times.

## Erroneous Example

```moonbit
struct S { a : Int }
let a : Int = match S::{ a: 2, a: 3 } {
  { a: 2, a: 3 } => 4
  _ => 5
}
```

The example above tries to:

1. Create a record with the field `a` defined multiple times.
1. Destructure a record with the field `a` matched multiple times.

... giving the following error on line 2:

```
The record field a is defined several times.
```

... and the following error on line 3:

```
The record field a is matched several times in this pattern.
```

## Suggestion

Make sure that the record field is defined or matched only once:

```moonbit
struct S { a : Int }
let a : Int = match S::{ a: 2 } {
  { a: 2 } => 4
  _ => 5
}
```


================================================
File 366: /data/input/moonbit-docs/next/language/error_codes/E4044.md
================================================
# E4044

Record fields are missing. Use `..` to ignore them in patterns.

## Erroneous Example

```moonbit
struct S { a : Int; b: Int }
let a : Int = match S::{ a: 2, b: 3 } {
  { a: 2 } => 4
  _ => 6
}
```

The example above tries to match a record with a missing field `b`,
giving the following error on line 3:

```
Record fields b are unmatched, use `..` to ignore them.
```

## Suggestion

Make sure to provide all fields in the pattern,
or simply ignore the missing fields using `..`:

```moonbit
struct S { a : Int; b: Int }
let a : Int = match S::{ a: 2, b: 3 } {
  { a: 2, b: 3 } => 4
  { a: 2, .. } => 5
  _ => 6
}
```


================================================
File 367: /data/input/moonbit-docs/next/language/error_codes/E4045.md
================================================
# E4045

The field is not defined in the record type.

## Erroneous Example

```moonbit
struct S { a : Int, b : Int }
let a : Int = match S::{ a: 2, b: 3 } {
  { c: 2, .. } => 5
  _ => 6
}
```

The example above tries to match a record with a nonexistent field `c`,
giving the following error on line 3:

```
The fields c is not defined in the record type S.
```

## Suggestion

Make sure to provide all fields with the correct names in the pattern.

```moonbit
struct S { a : Int, b : Int }
let a : Int = match S::{ a: 2, b: 3 } {
  { a: 2, .. } => 5
  _ => 6
}
```


================================================
File 368: /data/input/moonbit-docs/next/language/error_codes/E4046.md
================================================
# E4046

A public definition cannot depend on private entities.

## Erroneous Example

```moonbit
priv trait I { m(Self) }
pub impl I for Int with m(self) {}
```

The above example tries to implement a private trait `I` for the type `Int`,
but the implementation itself is public, which is not allowed.
This gives the following error on line 2:

```
A public definition cannot depend on private trait
```

## Suggestion

Adjust the visibility of the trait or the implementation to match:

```moonbit
trait I { m(Self) -> Unit }
pub impl I for Int with m(self) {}
```

... or:

```moonbit
priv trait I { m(Self) -> Unit }
impl I for Int with m(self) {}
```


================================================
File 369: /data/input/moonbit-docs/next/language/error_codes/E4047.md
================================================
# E4047

Package not found when loading packages.

Normally, this error should never be emitted. If you see this error, please
report it as a bug at:

<https://github.com/moonbitlang/moonbit-docs/issues/new?labels=bug>


================================================
File 370: /data/input/moonbit-docs/next/language/error_codes/E4048.md
================================================
# E4048

The package file is in wrong format.

This means your local build files are corrupted. Try to run `moon clean` or remove
the `target` directory manually and build again. If the error persists, please
submit a bug report here:

<https://github.com/moonbitlang/moonbit-docs/issues/new?labels=bug,ICE>


================================================
File 371: /data/input/moonbit-docs/next/language/error_codes/E4049.md
================================================
# E4049

Magic number mismatch for the package file.

This means your local build files are corrupted or outdated. First try
update/reinstall your MoonBit installation as in our [Download
Page](https://www.moonbitlang.com/download/). Then try to run `moon clean`
or remove the `target` directory manually and build again. If the error
persists, please submit a bug report here:

<https://github.com/moonbitlang/moonbit-docs/issues/new?labels=bug,ICE>


================================================
File 372: /data/input/moonbit-docs/next/language/error_codes/E4050.md
================================================
# E4050

Definition cycle detected in dependencies.

The toplevel definitions in a MoonBit package are mutually recursive. This means
that the definitions can refer to each other in any order. However, no cycles
are allowed in the dependencies between the toplevel variable definitions.

## Erroneous example

```moonbit
pub let a : Int = f() // Error: Definition cycle detected : a -> f -> a

fn f() -> Int { // Error: Definition cycle detected : a -> f -> a
  a
}
```

## Suggestion

The fix to this error varies depending on the logic of the program. One possible
fix is to make the variable definition to use `Ref[_?]`, and initialize the
variable later in `init` block of the program.

```moonbit
pub let a : Ref[Int?] = Ref::new(None)

fn init {
  a.val = Some(f())
}

fn f() -> Int {
  a.val.unwrap()
}
```


================================================
File 373: /data/input/moonbit-docs/next/language/error_codes/E4051.md
================================================
# E4051

The identifier is declared twice.

Mutually recursive definitions in MoonBit shall not have the same identifier.
This include:

- All toplevel definitions, including variables, functions, types, traits, etc.
- Locally named functions. (Reported as [E4006](E4006))
- Local types.

Note, locally defined variables are not mutually recursive, so they can have the
same identifier, and the later definition shadows the previous one.

## Erroneous example

- Toplevel variable definition:

  ```moonbit
  pub let a = 0
  pub let a = 1 // Error: The toplevel identifier a is declared twice: it was previously defined at ...
  ```

- Toplevel function definition:

  ```moonbit
  pub fn f() -> Unit {}
  pub fn f() -> Unit {} // Error: The toplevel identifier f is declared twice: it was previously defined at ...
  ```

- Toplevel type definition:

  ```moonbit
  pub enum A {}
  pub struct A {} // Error: The type A is declared twice: it was previously defined at ...
  ```

- Local type definition:

  ```moonbit
  pub fn g() -> Unit {
    struct A {}
    struct A {} // Error: The local type A is declared twice: it was previously defined at ...
  }
  ```

## Suggestion

Rename the identifier to a different name.

```moonbit
pub let a = 0
pub let b = 1
```

If you want to shadow the previous definition, you can use a block and put the
definition in the block.

```moonbit
pub let a = {
  let a = 0
  1
}
```


================================================
File 374: /data/input/moonbit-docs/next/language/error_codes/E4052.md
================================================
# E4052

The type/trait name duplicates with a previously defined identifier.

This can happen when you define a type and a trait with the same name.

## Erroneous example

```moonbit
pub type A
pub trait A {} // Error: The trait A duplicates with type A previously defined at ...
```

## Suggestion

Rename either the type or the trait to a different name.

```moonbit
pub type A
pub trait B {}
```


================================================
File 375: /data/input/moonbit-docs/next/language/error_codes/E4053.md
================================================
# E4053

Invalid type for "self": must be a type constructor.

This error happens when you want to define a method for implement a trait for a
type that is not a type constructor.

Types that **are** type constructors:

- Tuple: `(Int, Bool)`
- `enum`s, `struct`s, `trait`s, new types (`type`), and error types (`type!`).

Types that **are not** type constructors:

- Function: `(Int) -> Bool`
- Type parameter: `T` in `fn f[T](x : T) -> T`

## Erroneous example

- Defining a method for a type that is not type constructor.

  ```moonbit
  fn f[T](self : T) -> Int { // Error: Invalid type for "self": must be a type constructor.
    ignore(self)
    0
  }

  fn g(self : (Int) -> Unit) -> Unit { // Error: Invalid type for "self": must be a type constructor.
    self(0)
  }
  ```

- Implementing a method for a type that is not a type constructor.

  ```moonbit
  pub trait A {
    f(Self) -> Int
  }

  // Without constraints
  impl[X] A for X with f(self : X) -> Int { // Error: Invalid type for "self": must be a type constructor.
    ignore(self)
    0
  }

  // With constraints
  impl[X: Default] A for X with f(self : X) -> Int { // Error: Invalid type for "self": must be a type constructor.
    ignore(self)
    0
  }
  ```

## Suggestion

When you want to define a method for a type that is not a type constructor, you
may use new type to wrap the type.

```moonbit
pub(all) type Wrap[T] T

fn f[T](self : Wrap[T]) -> Int {
  ignore(self)
  0
}

fn g(self : Wrap[(Int) -> Unit]) -> Unit {
  (self._)(0)
}

impl[X] A for Wrap[X] with f(self : Wrap[X]) -> Int {
  ignore(self)
  0
}
```

However, this means you may have to wrap the value with `Wrap` every time you
want to call the method.

If you find yourself implementing a trait for a type parameter, you may also
want to consider using default implementation for the trait.

```moonbit
impl A with f(self : Self) -> Int {
  ignore(self)
  0
}
```

If you want to provide the implementation for types with specific constraints,
you can add these constraints to the trait definition.

```moonbit
trait A: Default {
  f(Self) -> Int
}

impl A with f(self : Self) -> Int {
  ignore(self)
  0
}
```


================================================
File 376: /data/input/moonbit-docs/next/language/error_codes/E4054.md
================================================
# E4054

Cannot determine self type of extension method. [Self] does not occur in the
signature of the method

Currently, MoonBit won't emit this error.


================================================
File 377: /data/input/moonbit-docs/next/language/error_codes/E4055.md
================================================
# E4055

Field is already declared.

## Erroneous example

```moonbit
struct A {
  a : Int
  a : Double
}
```

## Suggestion

Rename the field to a different name.

```moonbit
struct A {
  a : Int
  b : Double
}
```


================================================
File 378: /data/input/moonbit-docs/next/language/error_codes/E4056.md
================================================
# E4056

Method has already been defined.

## Erroneous example

```moonbit
struct Point {
  x: Int
  y: Int
}

fn Point::to_string(self : Point) -> String {
  "(" + self.x.to_string() + "," + self.y.to_string() + ")"
}

fn Point::to_string(self : Point) -> String {
  "<" + self.x.to_string() + "," + self.y.to_string() + ">"
}
```

## Suggestion

Remove the duplicate method and keep only one method:

```moonbit
struct Point {
  x: Int
  y: Int
}

fn Point::to_string(self : Point) -> String {
  "(" + self.x.to_string() + "," + self.y.to_string() + ")"
}

// Remove the second Point::to_string method
```


================================================
File 379: /data/input/moonbit-docs/next/language/error_codes/E4057.md
================================================
# E4057

The constructor is duplicate.

## Erroneous example

```moonbit
enum E {
  A
  A(Int)
}
```

## Suggestion

Rename the constructor to a different name.

```moonbit
enum E {
  A
  B(Int)
}
```


================================================
File 380: /data/input/moonbit-docs/next/language/error_codes/E4059.md
================================================
# E4059

Cannot define method for builtin types or types that come from other packages.

MoonBit only allows defining methods or implementing traits for types that are
defined in the current package.

## Erroneous example

In package `a`:

```moonbit
pub type A Int
```

In package `b`:

```moonbit
fn f(self : @a.A) -> Int { // Error: Cannot define method f for type @a.A from package a
  0
}
```

Defining methods for builtin types, or types in standard library, is another
frequent case of this error:

```moonbit
fn f(self : Int) -> Int { // Error: Cannot define method f for builtin type Int
  0
}
```

## Suggestion

You can either move the type definition to the current package:

```moonbit
pub type A Int

fn f(self : A) -> Int {
  0
}
```

Or use new type to wrap the builtin type or type from other package:

```moonbit
pub type WrapA @a.A

fn f(self : WrapA) -> Int {
  ignore(self._) // Use `._` to access the wrapped value if @a.A is public
  0
}
```


================================================
File 381: /data/input/moonbit-docs/next/language/error_codes/E4060.md
================================================
# E4060

Method type mismatch.

We require the type of implementation to have the exactly the same type as the
one defined in the trait. Notably, the following types are **not** considered
the same.

- Labelled arguments with different order: `(a~ : Int, b~ : Int) -> Unit` and
  `(b~ : Int, a~ : Int) -> Unit`.
- Optional arguments: `(a : Int, b? : Int) -> Unit` and `(a : Int) -> Unit`.

## Erroneous example

```moonbit
trait A {
  f(Self) -> Int
}

type T Int

impl A for T with f(self : T) -> Int {
  //              ^
  // Error: Method f of trait A is expected to have type (T) -> Int,
  //        it cannot be implemented with type (T) -> Unit
  ignore(self)
}
```

## Suggestion

Make sure the method type matches the trait method type.

```moonbit
impl A for T with f(self : T) -> Int {
  ignore(self)
}
```


================================================
File 382: /data/input/moonbit-docs/next/language/error_codes/E4061.md
================================================
# E4061

Cannot implement a trait for a type when both are defined in other packages.

MoonBit follows the orphan rule, which means that you can only:

| Traits  | Types   | Allowed? |
|---------|---------|----------|
| Current Package | Current Package | Yes      |
| Other Package | Current Package | Yes      |
| Current Package | Other Package | Yes      |
| Other Package | Other Package | No       |

See the [Access control of methods and trait implementations](../packages.md#access-control-of-methods-and-trait-implementations)
section of the MoonBit documentation for more information.

## Erroneous example

Suppose you have type `A` and trait `B` defined in package `a` in module
`username/hello`:

`a/a.mbt`:

```moonbit
pub(all) type A Int
pub(open) trait B {
  to_int(Self) -> Int
}
```

`a/moon.pkg.json`:

```json
{}
```

Now, if you want to implement trait `@a.B` for type `@a.A`:

`b/moon.pkg.json`:

```json
{
  "import": [
    "username/hello/a"
  ]
}
```

`b/b.mbt`:

```moonbit
impl @a.B for @a.A with to_int(self : @a.A) -> Int {
  //                    ^~~~~~
  // Error: Cannot define method to_int of trait @a.B from package a for type @a.A from package a
  self._
}
```

MoonBit will report an error.

## Suggestion

You can move either the trait or type into the current package where the
implementation is in. If that is not possible, you can create a new type over
the type you wish to implement the trait for, and then implement the trait for
the new type:

`b/b.mbt`:

```moonbit
type WrapA @a.A

impl @a.B for WrapA with to_int(self : WrapA) -> Int {
  ...
}
```


================================================
File 383: /data/input/moonbit-docs/next/language/error_codes/E4062.md
================================================
# E4062

This `impl` shadows method previously defined. This will result in different
implementations for trait inside and outside current package.

In MoonBit, you can implicitly implement a trait for a type by defining all the
methods in that trait. For example, if you have trait like this:

```moonbit
trait Coordinated { // use pub(open) when you want to implement it outside current package.
  x(Self) -> Int
  y(Self) -> Int
}
```

Then, for a type `Point`, you can implement the trait like this:

```moonbit
struct Point {
  x : Int
  y : Int
}

fn x(self : Point) -> Int {
  self.x
}

fn y(self : Point) -> Int {
  self.y
}
```

However, as you can implement a trait for a type explicitly with `impl`, this
may leads to inconsistent behavior when these two implementation have different
visibility.

## Erroneous example

For example, in package `a`:

```moonbit
pub(open) trait T {
  f(Self) -> Int
}

pub type A Int

pub fn A::f(self : A) -> Int {
  println("A::f")
  self._
}

impl T for A with f(self : A) -> Int {
  //              ^
  // Error: This `impl` shadows method f of A previously defined at ...
  //        This will result in different implementations for T inside and outside current package.
  println("impl T for A with f")
  self._
}
```

If these code were able to pass compilation, then for the function defined in
another package:

```moonbit
fn probe[T : @a.T](t : T) -> Unit {
  ignore(t.f())
}
```

The output will be `A::f`. However, if the `probe` function is defined in the package `a`:

```moonbit
fn probe[T : T](t : T) -> Unit {
  ignore(t.f())
}
```

The output will be `impl T for A with f`.

## Suggestion

To fix this error, you need to make sure both the implicitly (`A::f`) and
explicitly implementation (`impl`) of the trait have the same visibility.

```moonbit
// ...
pub impl T for A with f(self : A) -> Int {
  println("impl T for A with f")
  self._
}
```


================================================
File 384: /data/input/moonbit-docs/next/language/error_codes/E4063.md
================================================
# E4063

Type does not implement trait, although an `impl` is defined.

This error can be further divided into 5 cases:

- Method is missing
- Implementation is private
- Method type mismatch
- Constraints are not satisfied
- Method contains unresolved type parameters

## Erroneous example

### Method is missing

```moonbit
trait Number {
  to_int(Self) -> Int
  to_float(Self) -> Float
}

type A Int

impl Number for A with to_int(self : A) -> Int {
//^~~~~~~~~~~~~~~
// Error: Type A does not implement trait Number, although an `impl` is defined.
// hint:
//   method to_float is missing.
  self._
}
```

## Suggestion

Modify the code according to the hint provided along with the error message. For
the example above, you can add the missing method `to_float` to type `A`.

```moonbit
impl Number for A with to_float(self : A) -> Float {
  self._.to_float()
}
```


================================================
File 385: /data/input/moonbit-docs/next/language/error_codes/E4065.md
================================================
# E4065

Overloaded operator should accept the correct number of arguments.

You can refer to the [Operator Overloading](../methods.md#operator-overloading)
section for a list of operators that can be overloaded, and here is a list of
number of arguments that each operator should accept:

| Operator | Method Name | Number of Arguments |
|----------|--------------|---------------------|
| `+` | `op_add` | 2 |
| `-` | `op_sub` | 2 |
| `*` | `op_mul` | 2 |
| `/` | `op_div` | 2 |
| `%` | `op_mod` | 2 |
| `==` | `op_equal` | 2 |
| `<<` | `op_shl` | 2 |
| `>>` | `op_shr` | 2 |
| `-` (unary) | `op_neg` | 1 |
| `_[_]` | `op_get` | 2 |
| `_[_] = _` | `op_set` | 3 |
| `_[_:_]` | `op_as_view` | 3 |
| `&` | `land` | 2 |
| `\|` | `lor` | 2 |
| `^` | `lxor` | 2 |

## Erroneous example

```moonbit
type A Int

fn A::op_add(self : A, other : A, opt? : A) -> A {
  //  ^~~~~~
  // Error: overloaded operator "op_add" should accept 2 arguments, but it accepts 3 arguments
  let opt = match opt {
    None => 0
    Some(opt) => opt._
  }
  return self._ + other._ + opt
}
```

## Suggestion

Modify the method to match the expected number of arguments of the operator.

```moonbit
fn A::op_add(self : A, other : A) -> A {
  self._ + other._
}
```


================================================
File 386: /data/input/moonbit-docs/next/language/error_codes/E4066.md
================================================
# E4066

Overloaded operator has inconsistent parameter type.

You can refer to the [Operator Overloading](../methods.md#operator-overloading)
section for a list of operators that can be overloaded, and respectively their
expected signature.

## Erroneous example

```moonbit
type A Int
fn A::op_add(self : A, other : Int) -> A {
  return self._ + other
}
```

## Suggestion

Modify the method to match the expected parameter type of the operator. If you
use the name for overloaded operators by accident, you can rename the method to
a different name.

```moonbit
fn A::op_add(self : A, other : A) -> A {
  self._ + other._
}
```


================================================
File 387: /data/input/moonbit-docs/next/language/error_codes/E4067.md
================================================
# E4067

Missing main function in the main package.

In MoonBit, packages are divided into two types: main packages and non-main
packages. Non-main packages are often used as libraries to provide functionality
to other packages. Main packages, on the other hand, are the entry points of the
program. Therefore, main package should contains a `main` function serving as
the entry point of the program.

## Erroneous example

Suppose in package `main`:

`main/moon.pkg.json`:

```json
{ // Error: Missing main function in the main package.
  "is-main": true
}
```

`main/main.mbt`:

```moonbit
type A Int

pub fn A::to_int(self : A) -> Int {
  self._
}
```

## Suggestion

You can add a `main` function to the main package:

`main/main.mbt`:

```moonbit
// ...
fn main {
  let a : A = 42
  println(a.to_int())
}
```

Alternatively, you can set the package to be a non-main package by setting
`"is-main"` to `false` in the package configuration file.

`main/moon.pkg.json`:

```json
{
  "is-main": false
}
```


================================================
File 388: /data/input/moonbit-docs/next/language/error_codes/E4068.md
================================================
# E4068

Main function is already defined.

In MoonBit, a `main` package contains a single `main` function that serves as
the entry point of the program. Therefore, you cannot define more than one
`main` function in the main package. If you want to have multiple programs to be
built as separate binaries, you can use multiple `main` packages within the same
module.

## Erroneous example

Suppose in package `main`:

`main/moon.pkg.json`:

```json
{
  "is-main": true
}
```

`main/main.mbt`:

```moonbit
fn main {
  println("Hello, World!")
}

fn main { // Error: Main function is already defined at ...
  println("Hello, World! Again!")
}
```

## Suggestion

You can either remove the extra `main` function:

```moonbit
fn main {
  println("Hello, World!")
}
// Remove the extra main function
//- fn main {
//-   println("Hello, World! Again!")
//- }
```

Or you can move the extra `main` function to a different package, say `main2`:

`main2/moon.pkg.json`:

```json
{
  "is-main": true
}
```

`main2/main.mbt`:

```moonbit
fn main {
  println("Hello, World! Again!")
}
```

while keeping the `main/main.mbt` contains only one main function:

```moonbit
fn main {
  println("Hello, World!")
}
```


================================================
File 389: /data/input/moonbit-docs/next/language/error_codes/E4069.md
================================================
# E4069

Unexpected main function in the non-main package.

In MoonBit, packages are divided into two types: main packages and non-main
packages. Non-main packages are often used as libraries to provide functionality
to other packages. Main packages, on the other hand, are the entry points of the
program. Therefore, non-main packages should not contain a `main` function.

Sometimes, people use the main function for testing. In such cases, we recommend
using the `test` block to write tests, instead of using the `main` function. See
the [test](../introduction.md#test) section of the MoonBit documentation for
more information.

## Erroneous example

Suppose in package `lib`:

`lib/moon.pkg.json`:

```json
{} // "is-main" is by default false
```

`lib/lib.mbt`:

```moonbit
fn main { // Error: Unexpected main function in the non-main package.
  println("Hello, world!")
}
```

## Suggestion

You can remove the `main` function from the non-main package:

```moonbit
// Remove the main function
//- fn main {
//-   println("Hello, world!")
//- }
```

Alternatively, you can set the package to be a main package by setting
`"is-main"` to `true` in the package configuration file.

`lib/moon.pkg.json`:

```json
{
  "is-main": true
}
```

You can also move the `main` function to a different package, say `main`:

`main/moon.pkg.json`:

```json
{
  "is-main": true
}
```

`main/main.mbt`:

```moonbit
fn main {
  println("Hello, world!")
}
```


================================================
File 390: /data/input/moonbit-docs/next/language/error_codes/E4070.md
================================================
# E4070

Unknown intrinsic. This intrinsic is not known to the MoonBit compiler.

Note all intrinsic is not intended for usage outside of `moonbitlang/core` and
is subject to change without notice, and we highly recommend **against** using
them.

## Erroneous example

```moonbit
pub fn my_abort(message : String) -> Unit = "%abort"
// Error: Unknown intrinsic: %abort

fn main {
  my_abort("Abort!")
}
```

## Suggestion

You may probably want to use the `abort` function from the `moonbitlang/core`:

```moonbit
fn main {
  abort("Abort!")
}
```

If you really need to use the intrinsic, you can check the source code of
`moonbitlang/core` for further usage of the corresponding intrinsic.


================================================
File 391: /data/input/moonbit-docs/next/language/error_codes/E4071.md
================================================
# E4071

Multiple intrinsic is not supported. You have defined a function to use multiple
intrinsics.

Note all intrinsic is not intended for usage outside of `moonbitlang/core` and
is subject to change without notice, and we highly recommend **against** using
them.

## Erroneous example

```moonbit
type MyArray[T] Array[T]

/// @intrinsic %array.get
/// @intrinsic %fixedarray.get
fn MyArray::get[T](self : MyArray[T], index : Int) -> T { // Error: Multiple intrinsic is not unsupported.
  return self._[index]
}
```

## Suggestion

Remove the extra intrinsic and use only one intrinsic:

```moonbit
/// @intrinsic %array.get
fn MyArray::get[T](self : MyArray[T], index : Int) -> T {
  return self._[index]
}
```

Avoid directly using intrinsics as much as possible, as we may change or remove
them in the future. If you really need to use the intrinsic, you can check the
source code of `moonbitlang/core` for further usage of the corresponding
intrinsic.


================================================
File 392: /data/input/moonbit-docs/next/language/error_codes/E4072.md
================================================
# E4072

Method of trait already has a default implementation.

## Erroneous example

```moonbit
trait T {
  to_int(Self) -> Int
}

type A Int

impl T with to_int(self : Self) -> Int {
  0
}

impl T with to_int(self : Self) -> Int { // Error: Method to_int of trait T already has a default implementation at
  0
}
```

## Suggestion

Remove the duplicated default implementation of the trait.

```moonbit
impl T with to_int(self : Self) -> Int {
  0
}

// Remove this implementation
// impl T with to_int(self : Self) -> Int {
//   0
// }
```


================================================
File 393: /data/input/moonbit-docs/next/language/error_codes/E4073.md
================================================
# E4073

Cannot provide default implementation for traits from other packages.

This is a corollary of the [orphan rules of traits and types in
MoonBit](../packages.md#access-control-of-methods-and-trait-implementations).
Default implementation can be seen as implementing the trait for all possible
types, including types defined within or outside of current package. Therefore,
it is only possible for default implementation to be defined in the package of
the trait, otherwise it would violate the orphan rules.

## Erroneous example

Suppose you have a trait `T` defined in package `a` in module `username/hello`:

`a/a.mbt`:

```moonbit
// We need the trait to be pub(open) so that it can be implemented from outside.
pub(open) trait T {
  f(Self) -> Int
}
```

And when you want to define a default implementation for the trait in another
package, say `b`:

`b/moon.pkg.json`:

```json
{
  "import": [
    "username/hello/a"
  ]
}
```

`b/b.mbt`:

```moonbit
impl @a.T with f(self : Self) -> Int {
  //           ^
  // Error: Cannot provide default implementation for trait @a.T from package a
  ignore(self)
  0
}
```

## Suggestion

To fix this error, you can move the definition of the trait and the default
implementation of this trait into the same package. Say you can move the trait
definition into package `b`:

`b/b.mbt`:

```moonbit
pub(open) trait T {
  f(Self) -> Int
}

impl T with f(self : Self) -> Int {
  ignore(self)
  0
}
```


================================================
File 394: /data/input/moonbit-docs/next/language/error_codes/E4074.md
================================================
# E4074

This error code is shared by the following two error messages:

- Cannot infer the type of variable, please add more type annotation.
- Public definition a must be annotated with its type.

When defining a toplevel variable using `let`, MoonBit will try to infer its
type when the value is literal:

```moonbit
pub let forty_two = 42
pub let float = 1.0
pub let string = "Hello, world!"
pub let array = [1, 2, 3]
```

## Erroneous example

For "Cannot infer the type of variable a, please add more type annotation":

```moonbit
let a = 1 + 1 // Error: Cannot infer the type of variable a, please add more type annotation.
```

The other error message is more subtle. Say if you have module `username/hello`
and package `a`:

`a/a.mbt`:

```moonbit
pub let value = 1.0
```

And package `b`:

`b/moon.pkg.json`:

```json
{
  "import": [
    "username/hello/a"
  ]
}
```

`b/b.mbt`:

```moonbit
pub let value = @a.value // Error: Public definition a must be annotated with its type.
```

## Suggestion

These two error can be fixed by explicitly annotating the type of the variable:

```moonbit
let a : Int = 1 + 1
```

```moonbit
pub let value : Double = @a.value
```


================================================
File 395: /data/input/moonbit-docs/next/language/error_codes/E4075.md
================================================
# E4075

Missing type annotation for the parameter.

MoonBit requires all toplevel function to have full type annotation.

## Erroneous example

```moonbit
fn f(param) -> Unit { // Error: Missing type annotation for the parameter param.
}
```

## Suggestion

Add type annotation for the parameter:

```moonbit
fn f(param: Int) -> Unit {
}
```

Or if the parameter should be generic:

```moonbit
fn f[T](param: T) -> Unit {
}
```


================================================
File 396: /data/input/moonbit-docs/next/language/error_codes/E4076.md
================================================
# E4076

Missing type annotation for the return value.

MoonBit requires all toplevel function to have full type annotation. It is a
common mistake for people to forget to include the return type of a function,
especially when the function returns `Unit`.

## Erroneous example

```moonbit
fn f() { // Error: Missing type annotation for the return value.
}
```

## Suggestion

Add the return type of the function:

```moonbit
fn f() -> Unit {
}
```


================================================
File 397: /data/input/moonbit-docs/next/language/error_codes/E4077.md
================================================
# E4077

Don't know how to derive trait for type.

MoonBit allows you to derive implementation of some pre-defined traits for your
types. It means that you cannot have MoonBit automatically derive a trait that
you defined yourself.

## Erroneous example

```moonbit
trait T {
  f(Self) -> Int
}

type A Int derive(T) // Error: Don't know how to derive trait T for type A
```

## Suggestion

You can implement the trait manually:

```moonbit
trait T {
  f(Self) -> Int
}

// Remove derive(T)
type A Int

impl T for A with f(self : A) -> Int {
  0
}
```


================================================
File 398: /data/input/moonbit-docs/next/language/error_codes/E4078.md
================================================
# E4078

Cannot derive trait for type.

MoonBit allows you to derive implementation of some traits for your types.
However, not all types can be automatically derived. For example, you cannot
derive a trait for an abstract type.

## Erroneous example

```moonbit
type T derive(Hash) // Error: Cannot derive trait Hash for type T: target type is abstract
```

## Suggestion

You can implement the trait manually:

```moonbit
type T

impl Hash for T with hash_combine(self : T, hasher: Hasher) {
  // ...
}
```


================================================
File 399: /data/input/moonbit-docs/next/language/error_codes/E4079.md
================================================
# E4079

Cannot derive trait: method is already defined.

This error occurs when you try to derive a trait for a type that already has a
implementation for the trait.

## Erroneous example

```moonbit
impl Show for A with output(self : A, logger : &Logger) -> Unit {
  logger.write_object(self._)
}

type A Int derive(Hash, Show) // Error: Cannot derive trait Show for A: method output is already defined at ...
```

## Suggestion

You can pick either the manual implementation or the derived implementation for
the type by removing the other one.

To use the derived implementation:

```moonbit
// Remove the manual implementation
// impl Show for A with output(self : A, logger : &Logger) -> Unit {
//   logger.write_object(self._)
// }

type A Int derive(Hash, Show)
```

Or to use the manual implementation:

```moonbit
impl Show for A with output(self : A, logger : &Logger) -> Unit {
  logger.write_object(self._)
}

type A Int derive(Hash)
```


================================================
File 400: /data/input/moonbit-docs/next/language/error_codes/E4080.md
================================================
# E4080

Arity mismatch: incorrect number of arguments provided.

## Erroneous example

Function arity mismatch:

```moonbit
fn f(x : Int, y : Double) -> Unit {
  ignore((x, y))
}

fn main {
  f(0) // Error: This function has type (Int, Double) -> Unit, which requires 2 arguments, but is given 1 argument.
}
```

Constructor arity mismatch:

```moonbit
enum E {
  A(Int, Double, String)
}

fn main {
  match A(0, 1.0) { // Error: This function has type (Int, Double, String) -> E, which requires 3 arguments, but is given 2 arguments.
    A(_, _) => ... // Error: The constructor A requires 3 arguments, but is given 2 arguments.
  }
}
```

## Suggestion

Provide the correct number of arguments.

Function arity mismatch:

```moonbit
fn main {
  f(0, 1.0)
}
```

Constructor arity mismatch:

```moonbit
fn main {
  match A(0, 1.0, "foo") {
    A(_, _, _) => ...
  }
}
```


================================================
File 401: /data/input/moonbit-docs/next/language/error_codes/E4081.md
================================================
# E4081

The identifier is bound more than once in the same pattern.

It is not possible to bind to values into one identifier because they might have
different values. If you want to shadow the first identifier, you can use `_` to
discard it.

## Erroneous Example

```moonbit
fn f(a : Int?, b : Int?) -> Unit {
  match (a, b) {
    (Some(a), Some(a)) => println("Some(\{a})")
    //    ^ Error: The identifier a is bound more than once in the same pattern.
    _ => println("None")
  }
}
```

## Suggestion

Use a different name for the second identifier.

```moonbit
fn f(a : Int?, b : Int?) -> Unit {
  match (a, b) {
    (Some(a), Some(b)) => println("Some(\{a}), Some(\{b})")
    _ => println("None")
  }
}
```

If you want a shadow-like behavior here, you can explicitly discard the first
`a` using `_`:

```moonbit
fn f(a : Int?, b : Int?) -> Unit {
  match (a, b) {
    (Some(_), Some(a)) => println("Some(\{a})")
    _ => println("None")
  }
}
```


================================================
File 402: /data/input/moonbit-docs/next/language/error_codes/E4082.md
================================================
# E4082

Variable is not bound in all patterns.

When using the `|` operator in a pattern, all variables must be bound in all
patterns. If a variable were not bound in all patterns, it would be free
variable when the pattern is matched, which is not allowed.

## Erroneous Example

```moonbit
enum E {
  A(Int, Double)
  B(Int)
}

fn f(value : E) -> Unit {
  match value {
    A(a, _) | B(_) => println("Hello") // Error: Variable a is not bound in all patterns.
  }
}
```

## Suggestion

```moonbit
fn f(value : E) -> Unit {
  match value {
    A(a, _) | B(a) => println("Hello")
  }
}
```


================================================
File 403: /data/input/moonbit-docs/next/language/error_codes/E4083.md
================================================
# E4083

The type does not implement `op_as_view` method.

This error code shall not be emitted when you are not developing the core
library. If you see this error, please report it as a bug to the core library
here:

<https://github.com/moonbitlang/core/issues/new>


================================================
File 404: /data/input/moonbit-docs/next/language/error_codes/E4084.md
================================================
# E4084

The label is supplied twice when calling a function with labelled parameters.

## Erroneous Example

```moonbit
pub fn f(a~ : Int) -> Unit {
  println("Hello, \{a}")
}

fn main {
  f(a=0, a=1) // Error: The label a~ is supplied twice.
}
```

## Suggestion

As there is only one labelled parameter in the function call, you can simply
provide a single value.

```moonbit
fn main {
  f(a=0)
}
```

When there are multiple labelled parameters in the function call, and you made a
typo to make this error, then you can change the name of the label supplied to
the correct one.

```moonbit
fn main {
  f(a=0, b=1)
}
```


================================================
File 405: /data/input/moonbit-docs/next/language/error_codes/E4085.md
================================================
# E4085

This has no parameter with the given label.

This error happens when:

- You made a typo in the label name;
- You mistakenly treat a positional argument as a labelled argument.
- You provided extra labelled arguments to the function.

## Erroneous Example

```moonbit
pub fn f(name : String) -> Unit {
  println("Hello, \{name}")
}

fn main {
  f("John", age=20) // Error: This function has no parameter with label age~.
}
```

## Suggestion

Check the signature of the function and provide the correct label name or remove
the extra labelled argument.

```moonbit
pub fn f(name : String) -> Unit {
  println("Hello, \{name}")
}

fn main {
  f("John")
}
```


================================================
File 406: /data/input/moonbit-docs/next/language/error_codes/E4086.md
================================================
# E4086

The labels are required by this function, but not supplied.

Sometimes this error occurs when you mistakenly treat a labelled argument as a
positional argument. There are some common functions that require labelled
arguments, such as:

- `@test.snapshot`. Remember to supply `filename` as a labelled argument.
- `@test.inspect`. Remember to supply `content` as a labelled argument.

## Erroneous example

```moonbit
pub fn f(name~ : String) -> Unit {
  println("Hello, \{name}")
}

fn main {
  f("John") // Error: The labels name~ are required by this function, but not supplied.
}
```

## Suggestion

Check the signature of the function and provide the correct labelled argument.

```moonbit
pub fn f(name~ : String) -> Unit {
  println("Hello, \{name}")
}

fn main {
  f(name="John")
}
```


================================================
File 407: /data/input/moonbit-docs/next/language/error_codes/E4087.md
================================================
# E4087

The variable is not mutable.

MoonBit requires programmers to explicitly declare mutable variables. Notice
that mutability in MoonBit only refers to the variable itself, not the value it
holds. This means for `Array[T]`, `Ref[T]`, and mutable fields in `struct`, you
don't have to declare them as mutable.

## Erroneous Example

```moonbit
fn main {
  let a = 0
  a = 1 // Error: The variable a is not mutable.
  println(a)
}
```

## Suggestion

To fix this error, you need to declare the variable as mutable by adding the
`mut` keyword before the variable name.

```moonbit
fn main {
  let mut a = 0
  a = 1
  println(a)
}
```


================================================
File 408: /data/input/moonbit-docs/next/language/error_codes/E4088.md
================================================
# E4088

The record field is immutable.

MoonBit requires programmers to explicitly annotate which fields in a record
they wish to be mutable. By default, all fields in a record are immutable.
To make a field mutable, you need to add the `mut` keyword before the field.

## Erroneous example

```moonbit
struct S {
  value : Int
}

fn main {
  let s = { value: 42 }
  s.value = 43 // Error: The record field value is immutable.
  println(s.value)
}
```

## Suggestion

To fix this error, you need to declare the field as mutable by adding the `mut`
keyword before the field name.

```moonbit
struct S {
  mut value : Int
}

fn main {
  let s = { value: 42 }
  s.value = 43
  println(s.value)
}
```


================================================
File 409: /data/input/moonbit-docs/next/language/error_codes/E4089.md
================================================
# E4089

Tuple has no field with the given index.

In MoonBit, one can access the element in a tuple using index accessor, like
`tuple.0`, `tuple.1`, and so on. **The index starts with 0**, and the compiler
will emit this error if you try to access an element that does not exist in the
tuple, for example, accessing the third element (`tuple.2`) in a tuple with only
two elements.

## Erroneous example

```moonbit
fn main {
  let tuple = (1, 2)
  println(tuple.2)
}
```

## Suggestion

To fix this error, you need to access the element within the tuple that exists.

```moonbit
fn main {
  let tuple = (1, 2)
  println(tuple.1)
}
```


================================================
File 410: /data/input/moonbit-docs/next/language/error_codes/E4090.md
================================================
# E4090

Tuples are not mutable. You cannot change the value of a field in a tuple using
assignment.

## Erroneous example

```moonbit
fn main {
  let a = (1, 2, 3)
  a.2 = 4 // Error: tuples are not mutable
  println(a.2)
}
```

## Suggestion

If you need to change the value of a field in a tuple, you should use a struct
instead.

```moonbit
pub struct MyStruct {
  a: Int
  b: Int
  mut c: Int
}

fn main {
  let a : MyStruct = { a : 1, b : 2, c : 3 }
  a.c = 4
  println(a.c)
}
```


================================================
File 411: /data/input/moonbit-docs/next/language/error_codes/E4091.md
================================================
# E4091

The type has no field with the given name.

It is possible that you made a typo and use a wrong field name to access the
field of a struct.

## Erroneous example

```moonbit
struct Point {
  x : Double
  y : Double
}

fn main {
  let point = Point::{ x : 1.0, y : 2.0 }
  println(point.z) // Error: The type Point has no field z.
}
```

## Suggestion

You can either add the missing field to the struct, or use an existing field
to access the struct.

```moonbit
struct Point {
  x : Double
  y : Double
}

fn main {
  let point = Point::{ x : 1.0, y : 2.0 }
  println(point.x)
  println(point.y)
}
```


================================================
File 412: /data/input/moonbit-docs/next/language/error_codes/E4092.md
================================================
# E4092

Missing annotation for this empty record.

Currently, the MoonBit compiler does not emit this error, as it is impossible to
create an empty record without using `T::{ .. }` syntax.


================================================
File 413: /data/input/moonbit-docs/next/language/error_codes/E4093.md
================================================
# E4093

The type is not a record type.

This error occurs when you try to construct a type that is not a `struct` using
the `T::{ .. }` syntax.

## Erroneous example

```moonbit
enum Point {
  D2(Double, Double)
  D3(Double, Double, Double)
}

fn main {
  let a = Point::{ x : 1.0, y : 2.0 }
  //      ^~~~~
  // Error: The type Point is not a record type
}
```

## Suggestion

You should use the correct syntax to construct the type.

```moonbit
fn main {
  let a = Point::D2(1.0, 2.0)
}
```


================================================
File 414: /data/input/moonbit-docs/next/language/error_codes/E4094.md
================================================
# E4094

Cannot modify a read-only field.

For a read-only `struct`, you cannot modify the value of a field using
assignment outside of the package where the type is defined.

## Erroneous example

Suppose you have a package `a` in module `username/hello`:

`a/moon.pkg.json`:

```json
{}
```

`a/a.mbt`:

```moonbit
pub struct T {
  mut value : Int
}

pub fn T::new() -> T {
  T::{ value: 0 }
}

pub fn T::set(self : T, value : Int) -> Unit {
  self.value = value
}
```

And you have another package `b` in the same module:

`b/moon.pkg.json`:

```json
{
  "is-main": true,
  "import": [
    "username/hello/a"
  ]
}
```

`b/b.mbt`:

```moonbit
fn main {
  let a = @a.T::new()
  a.value = 3 // Error: Cannot modify a read-only field: value
}
```

## Suggestion

If you have control over the package where the type is defined, you can simply
make the struct has `pub(all)` visibility.

`a/a.mbt

```moonbit
pub(all) struct T {
  mut value : Int
}
```

However, this might not be the best solution if you want to hide the
implementation details of the struct or protect the invariant of the struct. We
recommend using getter/setter pattern to guard the access to the struct fields.

`b/b.mbt`:

```moonbit
fn main {
  let a = @a.T::new()
  a.set(3)
}
```


================================================
File 415: /data/input/moonbit-docs/next/language/error_codes/E4095.md
================================================
# E4095

Integer literal is out of range.

Integer literals can be used to initialize `Byte`, `Int16`, `Int`, `Int64` and
their unsigned variants. The range of these types are as follows:

| Type   | Minimum value | Maximum value |
|--------|---------------|---------------|
| Byte   | 0             | 255           |
| Int16  | -32768        | 32767         |
| UInt16 | 0             | 65536         |
| Int    | -2147483648   | 2147483647    |
| UInt   | 0             | 4294967295    |
| Int64  | -9223372036854775808 | 9223372036854775807 |
| UInt64 | 0             | 18446744073709551615 |

## Erroneous example

```moonbit
fn main {
  let byte : Byte = 256
}
```

## Suggestion

You should either use a value that falls into the range of corresponding type, or adjust the type to accommodate the value.

```moonbit
fn main {
  let int : Int = 256
}
```


================================================
File 416: /data/input/moonbit-docs/next/language/error_codes/E4100.md
================================================
# E4100

The type is not a trait.

This error occurs when you try to use the `typealias` syntax to define a alias
for a type and use it as a trait. As it is impossible to use a type as a trait,
this error might hint at a typo in your code.

## Erroneous example

```moonbit
type Original Int

typealias Alias = Original

trait Trait: Alias {
  //         ^~~~~
  // Error: The type Alias is not a trait
}
```

## Suggestion

If there is a typo, the use a correct trait or alias of trait at where the error
occurs.

```moonbit
trait Original {
  to_int(Self) -> Int
}

typealias Alias = Original

trait Trait: Alias {
  to_int(Self) -> Int
}
```

We recommend using `traitalias` for defining aliases for traits, as this will
detect errors like this earlier.


================================================
File 417: /data/input/moonbit-docs/next/language/error_codes/E4101.md
================================================
# E4101

Unsupported expression after the pipe operator.

This error occurs when the expression after the pipe operator (`|>`) is not in a
supported form. The pipe operator allows you to chain function calls in a more
readable way, but only supports specific forms on its right-hand side.

The following forms are allowed after the pipe operator:

1. A single identifier (function name)
2. A regular function application (but not method calls)
3. A constructor name
4. A constructor application

## Erroneous example

```moonbit
type T Int

fn m(self: T, x: Int) -> Unit {
  println(self._ + x)
}

pub fn f(t: T, x: Int) -> Unit {
  x |> fn(x: Int) { println(x)}
//     ^^^^^^^^^^^^^^^^^^^^^^^^ Error: Unsupported expression after the pipe operator.
  x |> t.m()
//     ^^^^ Error: Unsupported expression after the pipe operator.
}
```

## Suggestion

To fix this error, you can change the invalid pipe expression to normal function
or method application.

```moonbit
type T Int

fn m(self: T, x: Int) -> Unit {
  println(self._ + x)
}

pub fn f(t: T, x: Int) -> Unit {
  fn(x: Int) { println(x)}(x)
  t.m(x)
}
```


================================================
File 418: /data/input/moonbit-docs/next/language/error_codes/E4102.md
================================================
# E4102

Outside of a loop.

This error occurs when using `break` or `continue` statements outside of a loop
construct. These control flow statements can only be used within loops.

- `break` is used to exit a loop early
- `continue` is used to skip to the next iteration of a loop

Using these statements outside of a loop context is invalid since there is no
loop to break from or continue to the next iteration.

## Erroneous example

```moonbit
pub fn f(xs: Array[Int]) -> Int {
  for i in xs {
    ignore(i)
  } else {
    break 42
//  ^^^^^^^^ Error: 'break' outside of a loop
  }
}

pub fn g(x: Int) -> Int {
  continue x
// ^^^^^^^^ Error: 'continue' outside of a loop
}

fn main {
  let x = { break }
//          ^^^^^ Error: 'break' outside of a loop
  println(x)
}
```

## Suggestion

To fix this error, ensure that `break` and `continue` are used within a loop
construct.


================================================
File 419: /data/input/moonbit-docs/next/language/error_codes/E4103.md
================================================
# E4103

This loop has incorrect number of patterns supplied.

This error occurs when the number of patterns in a loop arm does not match the
number of loop arguments. In a loop construct, each arm must have the same
number of patterns as there are loop arguments.

For example, if a loop takes 2 arguments, each arm must have exactly 2 patterns
to match against those arguments. Having too few or too many patterns will
trigger this error.

## Erroneous example

```moonbit
pub fn f(x: Int, y: Int) -> Int {
  loop x, y {
    0, 0 => 0
    a => continue a - 1, 0
//  ^ Error: This loop has 2 arguments, but 1 patterns are supplied
  }
}
```

## Suggestion

To fix this error, ensure that each arm in the loop has the correct number of
patterns to match the loop arguments. For example,

```moonbit
pub fn f(x: Int, y: Int) -> Int {
  loop x, y {
    0, 0 => 0
    a, b => continue a - 1, b - 1
  }
}
```


================================================
File 420: /data/input/moonbit-docs/next/language/error_codes/E4104.md
================================================
# E4104

Current loop expects different number of arguments than supplied with `continue`.

This error occurs when the number of arguments provided to a `continue`
statement does not match the number of arguments expected by the loop. In a
`loop` construct, when using `continue`, you must provide the same number of
arguments as declared in the loop header.

For example, if a `loop` takes 2 arguments, any `continue` statement within that
`loop` must also provide exactly 2 arguments. Providing too few or too many
arguments will trigger this error.

Note that in a `for` loop, you can omit all arguments in a `continue` statement.
In this case, the loop will use the default update expressions specified in the
loop header. However, if you do provide arguments to `continue`, the number of
arguments must match the number of loop variables.

For example, in a `for` loop with two variables:

- `continue` (with no arguments) will use the default updates
- `continue x, y` (with two arguments) is valid
- `continue x` or `continue x, y, z` will trigger this error

## Erroneous example

```moonbit
pub fn f(x: Int, y: Int) -> Int {
  loop x, y {
    0, 0 => 0
    a, _ => continue a - 1
//          ^^^^^^^^^^^^^^ Error: Current loop expects 2 arguments, but
//                                `continue` is supplied with 1 arguments
  }
}

pub fn g(x : Int, y : Int) -> Int {
  for i = x, j = y; i + j < 10; i = i + 1, j = j + 1 {
    if i < j {
      continue i + 2, j + 1, i + j
//    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Error: Current loop expects 2 arguments, but
//                                       `continue` is supplied with 3 arguments
    }
  } else {
    42
  }
}
```

## Suggestion

To fix this error, ensure that the number of arguments provided to `continue`
matches the number of loop variables. For example,

```moonbit
pub fn f(x: Int, y: Int) -> Int {
  loop x, y {
    0, 0 => 0
    a, b => continue a - 1, b - 1
  }
}

pub fn g(x : Int, y : Int) -> Int {
  for i = x, j = y; i + j < 10; i = i + 1, j = j + 1 {
    if i < j {
      continue i + 2, j + 1
    } else {
      continue
    }
  } else {
    42
  }
}
```


================================================
File 421: /data/input/moonbit-docs/next/language/error_codes/E4105.md
================================================
# E4105

Current loop has result type mismatch with `break` argument.

This error occurs when the type of the argument provided to a `break` statement
does not match the expected result type of the loop. In MoonBit, loops can have
result types, and when using `break` with an argument, that argument's type must
match the loop's result type. When an argument is not provided, the loop's result
type must be `Unit`.

This mismatch can happen in two ways:

1. The loop expects a value of a certain type, but `break` is called with no
   argument
2. The loop expects a value of type A, but `break` is called with an argument of
   type B

For loops with result types, you must ensure that:

- All `break` statements provide an argument of the correct type
- The `else` branch (if present) returns a value of the correct type

## Erroneous example

```moonbit
pub fn g(x: Int) -> Int {
  for i in 0..=x {
    if i == 42 {
      break
//    ^^^^^ Error: Current loop has result type Int, but `break` is supplied
//                 with no arguments.
    }
  } else {
    0
  }
}
```

## Suggestion

To fix this error, you can:

- Add an argument to the `break` statement that matches the loop's result type.
  For example,

```moonbit
pub fn g(x: Int) -> Int {
  for i in 0..=x {
    if i == 42 {
      break i
    }
  } else {
    0
  }
}
```

- Remove the `else` branch if you don't need to return a value from the loop.

```moonbit
pub fn g(x: Int) -> Unit {
  for i in 0..=x {
    if i == 42 {
      break
    }
  }
}
```


================================================
File 422: /data/input/moonbit-docs/next/language/error_codes/E4106.md
================================================
# E4106

Unknown binder in the for-loop steps. Binders in the steps must be declared in
the initialization block of the for-loop.

This error occurs when a variable name used in the update expressions (steps) of
a for-loop is not declared in the initialization block of that loop. In a
for-loop, you can only use variables in the update expressions that were
previously declared when initializing the loop.

## Erroneous example

```moonbit
pub fn f(x: Int) -> Unit {
  let mut j = 0
  for i = 0; i < x; i = i + 1, j = j + 1 {
//                             ^ --- Error: Unknown binder j in the for-loop
//                                          steps. Binders in the steps must be
//                                          declared in the initialization
//                                          block of the for-loop.
    println(i)
    println(j)
  }
}
```

## Suggestion

To fix this error, you can

- declare the variable `j` in the initialization block of the for-loop. For
  example,

```moonbit
pub fn f(x: Int) -> Unit {
   for i = 0, j = 0; i < x; i = i + 1, j = j + 1 {
    println(i)
    println(j)
  }
}
```

- remove the variable `j` from the update expressions. For example,

```moonbit
pub fn f(x: Int) -> Unit {
  let mut j = 0
  for i = 0; i < x; i = i + 1 {
    println(i)
    println(j)
    j = j + 1
  }
}
```


================================================
File 423: /data/input/moonbit-docs/next/language/error_codes/E4107.md
================================================
# E4107

Name is declared multiple times in this for-loop.

This error occurs when the same variable name is declared multiple times in the
initialization block of a for-loop. In a for-loop's initialization, each
variable must have a unique name to avoid ambiguity about which value should be
used.

## Erroneous example

```moonbit
pub fn f(x: Int) -> Unit {
   for i = 0, i = 1; i < x; i = i + 1 {
//            ^ --- Error: i is declared multiple times in this for-loop
    println(i)
  }
}
```

## Suggestion

To fix this error, you can change the variable name in the initialization block:

```moonbit
pub fn f(x: Int) -> Unit {
  for i = 0, j = 1; i < x; i = i + 1 {
    println(i)
  }
}
```


================================================
File 424: /data/input/moonbit-docs/next/language/error_codes/E4108.md
================================================
# E4108

The loop is expected to yield a value, please add an `else` branch.

This error occurs when the compiler infers that a for-loop is expected to yield
a non-Unit value based on its context (such as the function's return type), but
the loop lacks an `else` branch to provide that value.

In MoonBit, when a for-loop is used in a context where a value is expected (for
example, when the function returns a non-Unit type), the loop must have an
`else` branch that specifies what value to return when the loop completes
normally. This is because:

1. The loop body itself cannot yield a value (unlike `loop` expressions)
2. Without an `else` branch, there's no way to determine what value should be
   returned when the loop finishes without breaking

This commonly occurs in two situations:

- When the for-loop is the last expression in a function that returns a non-Unit
  type
- When the for-loop's result is assigned to a variable or used in an expression
  that expects a non-Unit value

## Erroneous example

```moonbit
pub fn f(x: Int) -> Int {
  for i = 0, acc = 0; i < x; i = i + 1, acc = acc + i {
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Error: The for loop is
//                                                      not expected to yield a
//                                                      value, please add an
//                                                      `else` branch.
  }
}

pub fn g(x: Int) -> Int {
  for i in 0..=x {
  }
}
```

## Suggestion

To fix this error, you can:

- add an `else` branch to the for-loop:

```moonbit
pub fn f(x: Int) -> Int {
  for i = 0, acc = 0; i < x; i = i + 1, acc = acc + i {
  } else {
    acc
  }
}
```

- change the function's return type to `Unit` if you don't need to return a value
  from the loop:

```moonbit
pub fn g(x: Int) -> Unit {
  for i in 0..=x {
  }
}
```


================================================
File 425: /data/input/moonbit-docs/next/language/error_codes/E4109.md
================================================
# E4109

Return must be inside a function.

This error occurs when a `return` statement is used outside of a function. In
MoonBit, `return` statements must be inside a function body.

## Erroneous example

```moonbit
pub let x: Int = { return 42 }
//                 ^^^^^^^^^ Error: Return must be inside a function.
pub let y: Int = {
  if x == 42 {
    x + 1
  } else {
    return 0
//  ^^^^^^^^ Error: Return must be inside a function.
  }
}
```

## Suggestion

To fix this error, you can remove the return statement from the let binding:

```moonbit
pub let x: Int = 42
pub let y: Int = {
  if x == 42 {
    x + 1
  } else {
    0
  }
}
```


================================================
File 426: /data/input/moonbit-docs/next/language/error_codes/E4110.md
================================================
# E4110

The loop is not expected to yield a value, please remove the argument of the
`break` or add an `else` branch.

This error occurs when using a `break` statement with an argument in a loop that
is not expected to yield a value. This applies to:

- `while` loops
- `for` loops with update expressions
- `for .. in ..` iteration loops

These loop constructs do not have a mechanism to return a value from the loop
body. If you need to break with a value, you must either:

1. Remove the argument from the `break` statement if you don't need to return a
   value, or
2. Add an `else` branch to handle the case when the loop completes normally and
   provide a return value

## Erroneous example

```moonbit
pub fn f(x: Int) -> Unit {
  for i in 0..=x {
    break i
//  ^^^^^^^^ Error: The for loop is not expected to yield a value, please
//                  remove the argument of the `break` or add an `else` branch.
  }
}
```

## Suggestion

To fix this error, you can:

- Remove the argument from the `break` statement. For example,

```moonbit
pub fn f(x: Int) -> Unit {
  for i in 0..=x {
    break
  }
}
```

- Add an `else` branch to handle the case when the loop completes normally and
  provide a return value. For example,

```moonbit
pub fn f(x: Int) -> Int {
  for i in 0..=x {
    break i
  } else {
    42
  }
}
```


================================================
File 427: /data/input/moonbit-docs/next/language/error_codes/E4111.md
================================================
# E4111

The usage of break statement is invalid.

This error happens when you use a `break` statement in the initialization,
condition, or update statement of a loop.

## Erroneous example

```moonbit
pub fn f(x: Int, y: Int) -> Unit {
  for i = 0; i < x; i = i + 1 {
    for j = { break }; j < y; j = j + 1 {
//            ^^^^^ Error: The usage of break statement is invalid.
        println(i + j)
    }
  }
}
```

## Suggestion

Do not write `break` statement in the initialization, condition, or update
statement of a loop.


================================================
File 428: /data/input/moonbit-docs/next/language/error_codes/E4112.md
================================================
# E4112

The usage of continue statement is invalid.

This error happens when you use a `continue` statement in the initialization,
condition, or update statement of a loop.

## Erroneous example

```moonbit
pub fn f(x: Int, y: Int) -> Unit {
  for i = 0; i < x; i = i + 1 {
    for j = { continue }; j < y; j = j + 1 {
//            ^^^^^^^^ Error: The usage of continue statement is invalid.
        println(i + j)
    }
  }
}
```

## Suggestion

Do not write `continue` statement in the initialization, condition, or update
statement of a loop.


================================================
File 429: /data/input/moonbit-docs/next/language/error_codes/E4113.md
================================================
# E4113

Constructor has no field with the given name.

This error occurs when trying to access a field that doesn't exist in a
constructor pattern. In MoonBit, when pattern matching with constructors that
have named fields, you can only access fields that were defined in the
constructor's declaration.

This commonly happens when:

- Misspelling a field name
- Trying to access a field that exists in a different constructor
- Trying to access a field that was removed or renamed in the type definition

## Erroneous example

```moonbit
pub enum E {
  A(a~: Int)
}

pub fn f(x: E) -> Unit {
  match x {
    A(..) as a => {
      println(a.a)
      println(a.b)
//            ^^^ Error: Constructor A of type E has no field b.
    }
  }
}
```

## Suggestion

To fix this error, you can either:

- add the missing field to the constructor

```moonbit
pub enum E {
  A(a~: Int, b~: Bool)
}

pub fn f(x: E) -> Unit {
  match x {
    A(..) as a => {
      println(a.a)
      println(a.b)
    }
  }
}
```

- remove the incorrect field access


================================================
File 430: /data/input/moonbit-docs/next/language/error_codes/E4114.md
================================================
# E4114

Only toplevel functions can have labelled arguments.

This error occurs when trying to use labelled arguments in a local function or
anonymous function.

## Erroneous example

```moonbit
pub fn f() -> Unit {
  fn h(x~: Int) -> Unit {
//     ^^ Error: Only toplevel functions can have labelled arguments.
    println(x)
  }
  h(x=42)
}
```

## Suggestion

To fix this error, you can either:

- Move the function to the top level of the module

```moonbit
fn h(x~: Int) -> Unit {
  println(x)
}

pub fn f() -> Unit {
  h(x=42)
}
```

- Remove the labelled arguments

```moonbit
pub fn f() -> Unit {
  fn h(x: Int) -> Unit {
    println(x)
  }
  h(42)
}
```


================================================
File 431: /data/input/moonbit-docs/next/language/error_codes/E4115.md
================================================
# E4115

Cannot auto-fill parameter of this type.

MoonBit supports and auto-filling `SourceLoc` and `ArgsLoc` parameters in
functions. Leaving the default value of parameter of other types will result in
this error.

## Erroneous example

```moonbit
fn f(parameter~ : Int = _) -> Unit {
  // ^~~~~~~~~ Error: Cannot auto-fill parameter of type Int
}
```

## Suggestion

Use a default value for the parameter:

```moonbit
fn f(parameter~ : Int = 0) -> Unit {
}
```


================================================
File 432: /data/input/moonbit-docs/next/language/error_codes/E4116.md
================================================
# E4116

Found hole _.

If you want to represent unfinished code, we recommend using `...` instead.
Using `...` allows the program to be compiled and run, while `_` will cause a
compilation error.

## Erroneous example

```moonbit
fn main {
  _ // Error: Found hole _
}
```

## Suggestion

Use `...` instead:

```moonbit
fn main {
  ... // Warning: unfinished code
}
```


================================================
File 433: /data/input/moonbit-docs/next/language/error_codes/E4117.md
================================================
# E4117

Function with labelled arguments can only be applied directly.

This means you cannot pass a function with labelled arguments as an argument to another function.

## Erroneous example

```moonbit
pub fn func_takes_closure[F](f : F) -> Unit {
  ...
}

pub fn accumulate(acc~ : Int, value : Int) -> Int {
  acc + value
}

fn main {
  func_takes_closure(accumulate)
  //                 ^~~~~~~~~~
  // Error: Function with labelled arguments can only be applied directly.
}
```


================================================
File 434: /data/input/moonbit-docs/next/language/error_codes/E4118.md
================================================
# E4118

Cannot match type with map pattern.

You can use map patterns on custom types, as long as they have a method `op_get`
that returns an optional value for a given key.

## Erroneous example

```moonbit
type MyMap[K, V] Map[K, V]

fn main {
  let map : MyMap[String, Int] = { "a": 1, "b": 2, "c": 3 }
  match map {
    { "a": a, .. } => println("a: \{a}")
  //^~~~~~~~~~~~~~
  // Error: Please implement method `op_get` for type MyMap[String, Int] to match it with map pattern.
  }
}
```

## Suggestion

Implement the `op_get` method as suggested in the error message.

```moonbit
pub fn MyMap::op_get[K: Eq + Hash, V](self : MyMap[K, V], key : K) -> V? {
  self._[key]
}
```


================================================
File 435: /data/input/moonbit-docs/next/language/error_codes/E4119.md
================================================
# E4119

This function is not a toplevel function, so it cannot have labelled arguments.

## Erroneous example

```moonbit
fn main {
  fn greet(name~ : String) -> Unit {
    println("Hello, \{name}")
  }
}
```

## Suggestion

You can either remove the labelled argument, using positional argument instead:

```moonbit
fn main {
  fn greet(name : String) -> Unit {
    println("Hello, \{name}")
  }
  greet("world")
}
```

Or you can make the function a toplevel function:

```moonbit
fn greet(name~ : String) -> Unit {
  println("Hello, \{name}")
}

fn main {
  greet(name="World")
}
```


================================================
File 436: /data/input/moonbit-docs/next/language/error_codes/E4120.md
================================================
# E4120

The application might raise errors, but it's not handled. Try adding an infix
operator `!` or `?` to the application.

In MoonBit, we require programmers to explicitly annotate which functions may
raise errors. This is done by adding an infix operator `!` or `?` to the
function application. The `!` operator to re-raise the error, and the `?`
operator is to materialize the error to a `Result[T, E]` type.

## Erroneous example

```moonbit
fn may_raise_error(input : Int) -> Unit! {
  if input == 42 {
    return
  }
  fail!("failed")
}

fn main {
  may_raise_error(42)
  // Error: The application might raise errors of type Error, but it's not handled.
  // Try adding a infix operator `!` or `?` to the application, so that it looks like `...!(...)` or `...?(...)`.
}
```

## Suggestion

You can either re-raise the error:

```moonbit
fn main {
  try {
    may_raise_error!(42)
  } catch {
    error => println("Error: \{error}")
  }
}
```

Or materialize the error to a `Result[T, E]` type:

```moonbit
fn main {
  let result = may_raise_error?(42)
  println("Result: \{result}")
}
```


================================================
File 437: /data/input/moonbit-docs/next/language/error_codes/E4121.md
================================================
# E4121

The attribute (`!`, `?`, `!!` mark) cannot be used on this application.

This error occurs when:

- The attribute (`!`, `?`, `!!` mark) is used on a constructor.
- The attribute (`!`, `?`, `!!` mark) is used on a function that does fit.
  - `!` and `?` must be annotated on a function that may raise errors.
  - `!!` must be annotated on an async function (this will be reported as
    [E4150](E4150.md) though).

## Erroneous example

```moonbit
enum Err {
  IntErr(Int)
}

fn square(x: Int) -> Int {
  x * x
}

fn main {
  IntErr!(1) |> ignore() // Error: The attribute `!` cannot be used on constructors.
  IntErr?(2) |> ignore() // Error: The attribute `?` cannot be used on constructors.
  IntErr!!(3) |> ignore() // Error: The attribute `!!` cannot be used on constructors.
  square!(1) |> ignore() // Error: The attribute `!` cannot be used on application that does not raise errors
  square?(2) |> ignore() // Error: The attribute `?` cannot be used on application that does not raise errors
}
```

## Suggestion

Remove the attribute (`!`, `?`, `!!` mark) from the application.

```moonbit
fn main {
  IntErr(1) |> ignore()
  IntErr(2) |> ignore()
  IntErr(3) |> ignore()
  square(1) |> ignore()
  square(2) |> ignore()
}
```


================================================
File 438: /data/input/moonbit-docs/next/language/error_codes/E4122.md
================================================
# E4122

Invalid raise operation. Can only be used inside a function with error types in
its signature.

There are 3 raise operations in MoonBit, and they must be used inside a function
with error types in its signature or a try block.

- Use the `raise` keyword to raise an error directly.
- Re-raise an error by annotating the function application with the `!` operator.
- Explicitly handle the error using the `try ... catch! ...` block. The `catch!`
  means re-raise all the errors that are not handled in the catch block.

## Erroneous example

Raise the error directly:

```moonbit
type! ArithmeticError {
  DivisionByZero
}

pub fn checked_div(a : Double, b : Double) -> Double {
  if b == 0.0 {
    raise DivisionByZero // Error: raise can only be used inside ...
  }
  return a / b
}
```

Re-raise the error:

```moonbit
pub fn rethrow() -> Unit {
  fail!("throwing") // Error: `!` operator will rethrow the error raised in the function application, and can only be used inside ...
}
```

Catch all errors using `catch!`:

```moonbit
pub fn catch_all() -> Double {
  try {
    fail!("Failed") // Error: catch! will rethrow unhandled error, and can only be used inside ...
  } catch! {
  }
}
```

## Suggestion

You can either modify the surrounding function to have error types in its
signature:

```moonbit
pub fn checked_div(a : Double, b : Double) -> Double!ArithmeticError {
  ...
}

pub fn rethrow() -> Unit! {
  ...
}

pub fn catch_all() -> Double! {
  ...
}
```

Or use the `try ... catch ...` block to handle the error:

```moonbit
pub fn checked_div(a : Double, b : Double) -> Double {
  try {
    if b == 0.0 {
      raise DivisionByZero // Error: raise can only be used inside ...
    }
    return a / b
  } catch {
    _ => {
      println("DivisionByZero")
      @double.not_a_number
    }
  }
}
```


================================================
File 439: /data/input/moonbit-docs/next/language/error_codes/E4124.md
================================================
# E4124

The constructor is ambiguous: it may come from multiple types.

## Erroneous example

```moonbit
enum A {
  A(Int)
  B(Bool)
  C(Double)
}

enum B {
  A(Double)
  B(Int)
  C(Bool)
}

fn main {
  let a = A(1) // Error: The constructor A is ambiguous: it may come from type B or A.
}
```

## Suggestion

Add `T::` before the constructor:

```moonbit
fn main {
  let a = A::A(1)
}
```


================================================
File 440: /data/input/moonbit-docs/next/language/error_codes/E4125.md
================================================
# E4125

`?` operator cannot be used with `..`.

`..` operator allows chaining of method call that returns `Unit`. This is
especially useful when the method performs side-effects, like modifying the
object itself, and thus returns `Unit`.

Using `?` materializes the error that will be raised by the method to
`Result[T, E]`. If one combine the `?` with `..`, the method call will return
`Result[T, E]` instead of `Unit`, which is not allowed by the `..` operator.

## Erroneous example

```moonbit
type A Double derive(Show)

pub fn A::check(self : A) -> Unit! {
  if self._.is_nan() {
    fail!("NaN")
  }
}

pub fn A::div(self : A, other : A) -> A {
  A(self._ / other._)
}

fn main {
  let a : A = 1.0
  let b : A = 2.0
  println(a.div(b)..check?())
}
```

## Suggestion

Use the single dot syntax to call the method, and store the result in a
variable.

```moonbit
fn main {
  let a : A = 1.0
  let b : A = 2.0
  println(a.div(b).check?())
}
```


================================================
File 441: /data/input/moonbit-docs/next/language/error_codes/E4127.md
================================================
# E4127

Type is not an error type.

MoonBit only allow error types (defined with `type!` keyword) to appear after
the exclamation mark (`!`) in the return type of a function.

## Erroneous example

```moonbit
pub fn may_raise_error() -> Unit!String {
  //                             ^~~~~~
  // Error: Type String is not an error type.
  raise "Failed" // Error: Type String is not an error type.
}
```

## Suggestion

You can wrap the type you wish to raise in a error type:

```moonbit
type! StringError String

pub fn may_raise_error() -> Unit!StringError {
  raise StringError("Failed")
}
```


================================================
File 442: /data/input/moonbit-docs/next/language/error_codes/E4128.md
================================================
# E4128

Target of type alias must not be a type parameter.

## Erroneous example

```moonbit
typealias Wrap[T] = T // Error: Target of type alias must not be a type parameter.
```

## Suggestion

Use the type directly without using a typealias:


================================================
File 443: /data/input/moonbit-docs/next/language/error_codes/E4129.md
================================================
# E4129

Found cycle in type alias.

## Erroneous example

```moonbit
typealias A = B // Found cycle A -> B -> A in type alias.
typealias B = A
```

## Suggestion

You can break cycle using new type:

```moonbit
type A B
typealias B = A
```

However, this is equivalent to writing

```moonbit
type A A
```

And this might not be want to want to do. Therefore, we recommend using
newtypes instead of typealiases in most of times:

```moonbit
type A B
type B A
```


================================================
File 444: /data/input/moonbit-docs/next/language/error_codes/E4130.md
================================================
# E4130

`derive` is not allowed for type alias.

Aliases of a type can be used interchangeably with the type itself, so it is not
possible to derive traits for an alias without also deriving them for the type
it aliases. Therefore, MoonBit disallows deriving traits for type aliases.
Instead, one should derive the traits for the type itself.

## Erroneous example

```moonbit
struct MyStruct {
  field: Int
}

typealias StructAlias = MyStruct derive(Show) // Error: `derive` is not allowed for type alias
```

## Suggestion

Move the `derive` attribute to the type itself:

```moonbit
struct MyStruct {
  field: Int
} derive(Show)

typealias StructAlias = MyStruct // Remove `derive`
```

If you do not have control over the type, you can create a new type that wraps
the original type. However, deriving traits for a new type requires the wrapped
type to also implement the trait, which is likely not the case if you were using
a type alias in the first place. In this case, you will need to implement the
trait manually.

```moonbit
type StructWrapper MyStruct

impl Show for StructWrapper with output(self, logger) {
  ...
}
```


================================================
File 445: /data/input/moonbit-docs/next/language/error_codes/E4131.md
================================================
# E4131

The type alias is a function type, not a type constructor.

This error occurs when you try to define a method for a type alias. Aliases of a
type can be used interchangeably with the type itself, and it is not possible to
define method for function types. Therefore, MoonBit disallows defining methods
for type aliases of function types.

## Erroneous example

```moonbit
typealias FuncAlias = (Int) -> Unit

pub fn FuncAlias::call(self : FuncAlias) -> Unit {
  //   ^~~~~~~~~
  // Error: The type alias FuncAlias is a function type, not a type constructor.
  self(0)
}
```

## Suggestion

If you want to define a method for a function type, you should define a new type
that wraps the function type:

```moonbit
type FuncWrap (Int) -> Unit

pub fn FuncWrap::call(self : FuncWrap) -> Unit {
  (self._)(0)
}
```


================================================
File 446: /data/input/moonbit-docs/next/language/error_codes/E4132.md
================================================
# E4132

Invalid test parameter. Only one parameter with type `@test.T` is allowed.

## Erroneous example

```moonbit
test (name : String) {
  ...
}
```

## Suggestion

It is not yet possible to pass custom parameters to tests, and you have to use
the predefined `@test.T` type.

```moonbit
test (it : @test.T) {
  ...
}
```

Or you can remove the parameter if it is not needed:

```moonbit
test {
  ...
}
```


================================================
File 447: /data/input/moonbit-docs/next/language/error_codes/E4133.md
================================================
# E4133

This `for .. in` loop has incorrect number of loop variables.

MoonBit supports only one or two loop variables in `for .. in` loop.

- One loop variable is used for the content of the iterable.
- Two loop variables are used for the index and the content of the iterable
  respectively.

## Erroneous example

```moonbit
fn main {
  for a, b, c in [1, 2, 3] { // Error: This `for .. in` loop has 3 loop variables, but at most 2 is expected.
    ...
  }
}
```

## Suggestion

If you want to iterate over the index and the content of the iterable, you can
use two loop variables:

```moonbit
fn main {
  for i, v in [1, 2, 3] {
    ...
  }
}
```

If you want to iterate over a iterable of tuples, then you need to explicitly
destructure the tuple inside the loop body:

```moonbit
fn main {
  for v in [(1, 2, 3), (4, 5, 6)] {
    let (a, b, c) = v
    ...
  }
}
```


================================================
File 448: /data/input/moonbit-docs/next/language/error_codes/E4134.md
================================================
# E4134

The return type of this anonymous function is expected to include an error type.
Please add the error type to the return type annotation or use `fn!` instead.

## Erroneous example

```moonbit
fn main {
  let draw : (Int) -> Int! = fn(luck : Int) -> Int {
    //                                         ^~~
    // Error: The return type of this anonymous function is expected include an
    // error type. Please add the error type to the return type annotation or
    // use `fn!` instead.
    if luck == 7 {
      return 42
    }
    fail!("Bad luck") // E4122 as well
  }
  try {
    println("Draw: \{draw!(7)}")
  } catch {
    error => println("Error: \{error}")
  }
}
```

## Suggestion

Add the error type to the return type annotation:

```moonbit
fn main {
  let draw : (Int) -> Int! = fn(luck : Int) -> Int! {
    if luck == 7 {
      return 42
    }
    fail!("Bad luck")
  }
  try {
    println("Draw: \{draw!(7)}")
  } catch {
    error => println("Error: \{error}")
  }
}
```


================================================
File 449: /data/input/moonbit-docs/next/language/error_codes/E4135.md
================================================
# E4135

Inconsistent `impl` of trait: implementations have different constraints.

When implementing a trait for a type, all implementations must have the same
constraints. If the two constraints has intersection, then it would be unclear
which implementation to use for types that satisfy both constraints.

## Erroneous example

```moonbit
trait ByteSize { byte_size() -> Int}
impl ByteSize for Byte with byte_size() { 1 }
impl ByteSize for Int with byte_size() { 4 }

trait WordSize { word_size() -> Int }
impl WordSize for Float with word_size() { 1 }
impl WordSize for Double with word_size() { 2 }

trait Size { size(Self) -> Int }

impl[T : ByteSize] Size for Array[T] with size(self) {
  self.length() * T::byte_size()
}

impl[T : WordSize] Size for Array[T] with size(self) {
//<~~~~~~~~~~~~~~~
// Error: Inconsistent `impl` of trait Size for Array at 11:1 and 15:1:
//   type parameters of implementations have different constraints
  self.length() * T::word_size() * 4
}
```

## Suggestion

One way to resolve this issue is to pick one of the implementations and remove
the other:

```moonbit
// Remove the implementation for WordSize
// impl[T : WordSize] Size for Array[T] with size(self) {
//   self.length() * T::word_size() * 4
// }
```

If you want to implementation for both constraints, you can create a new trait
that combines the constraints:

```moonbit
trait ByteWordSize {
  byte_size() -> Int
  word_size() -> Int
}
```

And manually implement the trait for all the types that satisfy the constraints (`ByteSize` or `WordSize`).


================================================
File 450: /data/input/moonbit-docs/next/language/error_codes/E4136.md
================================================
# E4136

This expression has type that is not a newtype.

In MoonBit, you can access the field of underlying struct of a newtype by using
the dot access operator (`.`). However, you cannot access the field of a struct
if it is not wrapped in a newtype.

## Erroneous example

```moonbit
struct Inner {
  value : Int
}

type! ErrorOuter Inner

enum EnumOuter {
  Outer(Inner)
}

fn main {
  let outer : ErrorOuter = ErrorOuter(Inner::{ value: 1 })
  println(outer.value) // Error: This expression has type ErrorOuter, which is a error type type and not a record.
  let outer : EnumOuter = Outer(Inner::{ value: 2 })
  println(outer.value) // Error: This expression has type EnumOuter, which is a variant type and not a record.
}
```

## Suggestion

If you want to access the field of the underlying struct, you should wrap the
in a newtype:

```moonbit
type Outer Inner

fn main {
  let outer : Outer = Inner::{ value: 1 }
  println(outer.value)
}
```


================================================
File 451: /data/input/moonbit-docs/next/language/error_codes/E4137.md
================================================
# E4137

Range operators are currently only supported in `for .. in` loops.

This means you cannot save the range operator in a variable or use it later in
other contexts.

## Erroneous example

```moonbit
fn main {
  let range = 0..<10 // Error: Range operators are currently only supported in `for .. in` loops.
}
```

## Suggestion

One can use the `until` method to generate a range of numbers:

```moonbit
fn main {
  let range = (0).until(10)
  for i in range {
    println(i)
  }
}
```


================================================
File 452: /data/input/moonbit-docs/next/language/error_codes/E4138.md
================================================
# E4138

Range operators only support builtin integer types, they cannot be used on this
type.

## Erroneous example

For example, you cannot use `Float` nor `Double` with range operators.

```moonbit
fn main {
  for f in 0.0..<1.0 {
  }
}
```

## Suggestion

Use integer types for the range operators, and genearte floats from these
integers instead:

```moonbit
fn main {
  for i in 0..<10 {
    println(i.to_float())
  }
}
```

You can also use `until` to construct a range of numbers:

```moonbit
fn main {
  let range : Iter[Double] = (0.0).until(10.0)
  for i in range {
    println(i)
  }
}
```


================================================
File 453: /data/input/moonbit-docs/next/language/error_codes/E4139.md
================================================
# E4139

This expression has type that cannot be implicitly ignored. Use `ignore(...)` or
`let _ = ...` to explicitly ignore it.

`Unit` type can be implicitly ignored.

## Erroneous example

For example,

```moonbit
fn main {
  1 + 1 // This expression has type Int, its value cannot be implicitly ignored.
}
```

The code here show a deeper problem of the logic of the code: discarding the
result makes the computation useless.

## Suggestion

If you do want to discard the result, use `ignore(..)` or `let _ =` to
explicitly discard the value.

```moonbit
fn main {
  ignore(1 + 1)
}
```


================================================
File 454: /data/input/moonbit-docs/next/language/error_codes/E4140.md
================================================
# E4140

Invalid C function name in extern "C" declaration.

When binding a C function with the `extern "C"` declaration, the function name
must be a valid C identifier. This means that the name must satisfy the
following regex:

```
[a-zA-Z_$][a-zA-Z0-9_$]*
```

## Erroneous example

```moonbit
extern "C" fn f1() = "1" // Error: Invalid C function name in extern "C" declaration
```

## Suggestion

Change the function name to a valid C identifier:

```moonbit
extern "C" fn f1() = "f1"
```


================================================
File 455: /data/input/moonbit-docs/next/language/error_codes/E4141.md
================================================
# E4141

This form of application is invalid for the argument, because it is not
declared as optional.

This error happens when you try to forward an optional value to an argument to a
function. This is only allowed when the argument is declared as optional
argument. Even if the argument is declared as a labelled argument with default
value, it is not allowed to forward an optional value to it.

## Erroneous example

```moonbit
fn f(opt~ : Int = 4) -> Unit {
  println("opt: \{opt}")
}

fn main {
  let opt = Some(42)
  f(opt?) // Error: This form of application is invalid for argument opt~, because it is not declared with opt? : _.
}
```

## Suggestion

If you have control over the function you wish to call, you can change the argument
to be optional.

```moonbit
fn f(opt? : Int) -> Unit {
  let opt = match opt {
    Some(opt) => opt
    None => 4
  }
  println("opt: \{opt}")
}
```

However, if you does not have control over the function, you can unwrap the
optional value before passing it to the function.

```moonbit
fn main {
  let opt = Some(42)
  let opt = match opt {
    Some(opt) => opt
    None => 4
  }
  f(opt~)
}
```


================================================
File 456: /data/input/moonbit-docs/next/language/error_codes/E4142.md
================================================
# E4142

This 'const' declaration is not constant.

In MoonBit, you can use `const` to declare a constant value. Only literal value
of immutable primitive types can be assigned to `const`.

- These are constant values: `1`, `"String"`, `1.0`, `true`, `false`, etc.
- These are not constant values: `[1, 2, 3]`, `1 + 1`, `fn() { 1 }`, etc.

## Erroneous example

```moonbit
const A : Int = 1 + 1 // Error: This 'const' declaration is not constant.
```

## Suggestion

As it is not possible to run the computation at compile time and assign the
result to a `const`, you can use a `let` declaration to calculate these result
at initialization time instead.

```moonbit
let a : Int = 1 + 1 // These will be computed at initialization time.
```

If you can compute the value yourself by using, say a calculator, you can
simply assign the result to the `const`.

```moonbit
const A : Int = 2 // This is a constant value.
```


================================================
File 457: /data/input/moonbit-docs/next/language/error_codes/E4143.md
================================================
# E4143

Not a valid constant type, only immutable primitive types are allowed.

In MoonBit, you can use `const` to declare a constant value. Only literal value
of immutable primitive types can be assigned to `const`.

- These are valid constant types: `Int`, `String`, `Byte`, `Char`, `Float`,
  `Bool`, etc.
- These are not valid constant types: `Array[Int]`, `(Int) -> Int`, `Ref[Int]`,
  etc.

## Erroneous example

```moonbit
const A : Array[Int] = [1, 2, 3] // Error: Not a valid constant type, only immutable primitive types are allowed.
```

## Suggestion

You can bind the value to a variable using `let` instead.

```moonbit
let a : Array[Int] = [1, 2, 3]
```


================================================
File 458: /data/input/moonbit-docs/next/language/error_codes/E4144.md
================================================
# E4144

This is a constant, not a constructor, it cannot be applied to arguments.

This error occurs when you try to use a constant as a constructor in pattern.
One possible reason for this error is that you have a constant with the same
name as an constructor from some other packages, and in such case you need to
either use qualified name or type annotations to disambiguate.

## Erroneous example

```moonbit
pub const Value : Int = 1

fn main {
  match { ... } {
    Value(_) => println("Value")
  //^~~~~
  // Error: 'Value' is a constant, not a constructor, it cannot be applied to arguments.
  }
}
```

## Suggestion

If you want to match against the constant, you can remove the playload from the
pattern.

```moonbit
fn main {
  match { ... } {
    Value => println("Value")
  }
}
```

Or if the constant has the same name as a constructor from some other packages,
you can use qualified name or type annotations to disambiguate.

```moonbit
fn main {
  match { ... } {
    @a.Value(_) => println("Value")
  }
}
```


================================================
File 459: /data/input/moonbit-docs/next/language/error_codes/E4145.md
================================================
# E4145

Cannot implement trait because it is sealed.

Sealed trait means the trait is not allowed to be implemented in other packages.
Use `pub(open)` to make the trait open to be implemented by other packages.

## Erroneous example

Suppose there is a package `a` in module `username/hello`:

`a/moon.pkg.json`:

```moonbit
{}
```

`a/a.mbt`:

```moonbit
pub trait Sealed {
  to_int() -> Int
}
```

While in package `b`:

`b/moon.pkg.json`:

```moonbit
{
  "import": [
    "username/hello/a"
  ]
}
```

`b/b.mbt`:

```moonbit
type A Int

impl @a.Sealed for A with to_int(self : A) -> Int { // Error: Cannot implement trait '@a.Sealed' because it is readonly.
  self._
}
```

## Suggestion

You can change the visibility of the trait to `pub(open)`, so that it can be
implemented by other packages.

```moonbit
pub(open) trait Sealed {
  to_int() -> Int
}
```


================================================
File 460: /data/input/moonbit-docs/next/language/error_codes/E4146.md
================================================
# E4146

Type is not supported by range pattern.

MoonBit only support range pattern for integer types. This error occurs when
you try to use a type that is not an integer in a range pattern.

## Erroneous example

```moonbit
fn main {
  let value = 1.0
  match value {
    _..<0.0 => println("negative") // Error: Type Double is not supported by range pattern.
    _ => println("zero or positive")
  }
}
```

## Suggestion

For type that is not an integer but implements the `Compare` trait, you can use
multiple `if-else` expression to achieve the same effect.

```moonbit
fn main {
  let value = 1.0
  if value < 0.0 {
    println("negative")
  } else {
    println("zero or positive")
  }
}
```


================================================
File 461: /data/input/moonbit-docs/next/language/error_codes/E4147.md
================================================
# E4147

Range pattern bounds must satisfy the ordering constraints:

| Pattern | Constraint |
| ------- | ---------- |
| `a..=b` | `a <= b`  |
| `a..<b` | `a < b`   |

## Erroneous example

```moonbit
fn main {
  let value = 1
  match value {
    0..<-10 => println("0..<-10")
  //^~~~~~~
  // Error: Range pattern `a..<b` must satisfy `a < b`.
    _ => println("_")
  }
}
```

## Suggestion

Make sure the range pattern bounds satisfy the ordering constraints. This can be
usually achieved by swapping the bounds.

```moonbit
fn main {
  let value = 1
  match value {
    -10..<0 => println("0..=10")
    _ => println("_")
  }
}
```


================================================
File 462: /data/input/moonbit-docs/next/language/error_codes/E4148.md
================================================
# E4148

The loop label is undeclared.

MoonBit allows programmers to continue to or break from a loop with a label. The
label must be declared at the beginning of one of the loops the `continue` or
`break` statement is in.

## Erroneous example

```moonbit
fn read() -> @bytes.View {
  ...
}

fn main {
  loop read() {
    [] => break
    _ => continue read~ read()
    //            ^~~~~
    // Error: The label read is undeclared.
  }
  // Defining the label here does not work since continue cannot jump to a different loop.
  read~: loop read() {
    [] => break
  }
}
```

## Suggestion

Make sure the label is declared at the beginning of the loop the `continue` or
`break` statement is in.

```moonbit
fn main {
  read~: loop read() {
    [] => break
    _ => continue read~ read()
  }
}
```


================================================
File 463: /data/input/moonbit-docs/next/language/error_codes/E4149.md
================================================
# E4149

Cannot call async function in this context.

Async functions can only be called in async functions.

## Erroneous example

```moonbit
async fn f() -> Int {
  ...
}

fn g() -> Int {
  f!!()
}
```

## Suggestion

You can change the containing function to an async function:

```moonbit
async fn g() -> Int {
  f!!()
}
```


================================================
File 464: /data/input/moonbit-docs/next/language/error_codes/E4150.md
================================================
# E4150

Async function call must be marked with `!!`.

MoonBit require all async function calls to be marked with `!!`, as a way to to
inform the programmer that the function call is async and the control flow will
be suspended here.

## Erroneous example

```moonbit
async fn f() -> Int {
  ...
}

async fn g() -> Int {
  f() // Error: async function call must be marked with `!!`
}
```

## Suggestion

Mark the async function call with `!!`:

```moonbit
async fn g() -> Int {
  f!!()
}
```


================================================
File 465: /data/input/moonbit-docs/next/language/error_codes/index.md
================================================
# Error Codes Index

```{warning}
The error codes index is currently WIP.

Many of the entries contains only verify brief description of the error code.
You are more than welcomed to expand any of the entries by submitting a PR to
[moonbitlang/moonbit-docs](https://github.com/moonbitlang/moonbit-docs).
```

This page lists all error codes produced by the MoonBit compiler.

```{toctree}
:titlesonly:
:glob:
E*
```


================================================
File 466: /data/input/moonbit-docs/next/language/ffi-and-wasm-host.md
================================================
# Foreign Function Interface(FFI)

What we've introduced is about describing pure computation. In reality, you'll need
to interact with the real world. However, the "world" is different for each backend (C, JS, Wasm, WasmGC)
and is sometimes based on runtime ([Wasmtime](https://wasmtime.dev/), Deno, Browser, etc.).

You can use foreign function in MoonBit through FFI to interact with the hosting runtime when embedded inside the browser or command line applications through [Wasmtime](https://wasmtime.dev/) or similar projects.

## Init function

For WebAssembly backend, it is compiled as [start function](https://webassembly.github.io/spec/core/syntax/modules.html#start-function), meaning that it will be executed **before** the instance is available, and the FFIs that relies on the instance's exportations can not be used at this stage;
for JavaScript backend, it means that it will be executed during the importation stage.

## Declare Foreign Reference

You can declare a foreign reference type like this:

```moonbit
extern type Canvas_ctx
```

This will be a type that represents a reference to a foreign object, a `CanvasRenderingContext2D` object held by the hosting JavaScript runtime in this example.

## Declare Foreign Function

You can either import a function with module name and function name or writing an inline function.

### Import function

You can declare a foreign function like this:

```moonbit
fn cos(d : Double) -> Double = "Math" "cos"
```

It's similar to a normal function definition except that the function body is replaced with two strings.

For Wasm(GC) backend, these two strings are used to identify the specific function from a Wasm import object, the first string is the module name, and the second string is the function name. 

For JS backend, these two strings are used to call a static function in the global namespace. The example above becomes similar to `const cos = (d) => Math.cos(d)`.

### Inline function

You can also declare inline functions where the function body is replaced with one string.

For Wasm(GC) backend, you may declare it as a Wasm function without name (which will be generated afterwards):

```moonbit
extern "wasm" fn abs(d : Double) -> Double =
  #|(func (param f64) (result f64))
```

and for JS backend, you may declare it as a lambda expression:

```moonbit
extern "js" fn abs(d : Double) -> Double =
  #|(d) => Math.abs(d)
```

After declaration, you can use foreign functions like regular functions.

For multi-backend project, you may implement backend specific code in the files that ends with `.wasm.mbt` `.wasm-gc.mbt` and `.js.mbt`. Check out [link options](</toolchain/moon/package.md#link-options>) for details.

You may also declare a foreign function that will be invoked upon a foreign object by using the foreign reference type like this:

```moonbit
fn begin_path(self: Canvas_ctx) = "canvas" "begin_path"
```

and apply it to a previously owned reference normally such as `context.begin_path()`.

## Export functions

Functions that are not methods nor polymorphic functions can be exported if they are public and if the link configuration appears in the `moon.pkg.json` of the package:

```json
{
  "link": {
    "wasm": {
      "exports": [ "add", "fib:test" ]
    },
    "wasm-gc": {
      "exports": [ "add", "fib:test" ]
    },
    "js": {
      "exports": [ "add", "fib:test" ],
      "format": "esm"
    }
  }
}
```

Each backend has a separate definition. For JS backend, a `format` option is used to specify whether the generated JavaScript file should be released as an ES Module (`esm`), a CommonJS module (`cjs`), or an immediately invoked function expression (`iife`).

The example above will export function `add` and `fib`, and the function `fib` will be exported with the name of `test`.

## Use compiled Wasm

To use the compiled Wasm, you need to initialize the Wasm module with the host functions so as to meet the needs of the foreign functions, and then use the exported functions provided by the Wasm module.

### Provide host functions

To use the compiled Wasm, you must provide **All** declared foreign functions in Wasm import object.

For example, to use wasm compiled from above code snippet in JavaScript:

```js
WebAssembly.instantiateStreaming(fetch("xxx.wasm"), {
  Math: {
    cos: (d) => Math.cos(d),
  },
});
```

Check out the documentation such as [MDN](https://developer.mozilla.org/en-US/docs/WebAssembly) or the manual of runtime that you're using to embed the Wasm.


In order to passing closure to host, we need to add `make_closure` into `moonbit:ffi`.
e.g. [onclick](https://html.spec.whatwg.org/multipage/webappapis.html#handler-onclick)

```moonbit
extern type MouseEvent
extern type Window
fn onclick(self : Window, e : (MouseEvent) -> Unit) = "Window" "onclick"
pub fn print_hello(self : Window) -> Unit {
  self.onclick(fn (_){ println("hello")})
}
```

```typescript
let importObject = { 
  Window : {
    onclick : (w : Window, f : (e : MouseEvent) => void ) => w.onclick = f 
  },
  spectest: {
    print_char: log
  },
  "moonbit:ffi": {
    make_closure: (funcref, closure) => funcref.bind(null, closure)
  } 
}
WebAssembly.instantiateStreaming(fetch("target/wasm-gc/release/build/lib/lib.wasm"), importObject).then(
  (obj) => {
    obj.instance.exports["print_hello"](window);
  }
);
```

## Example: Smiling face

Let's walk through a full example to draw a smiling face using Canvas API in MoonBit. Suppose you created a new project with `moon new draw`

```moonbit title="lib/draw.mbt"
// We first declare a type representing the context of canvas
extern type Canvas_ctx

// We then declare the foreign function interfaces
fn begin_path(self : Canvas_ctx) = "canvas" "beginPath"
fn arc(self : Canvas_ctx, x : Int, y : Int, radius : Int, start_angle : Double,
    end_angle : Double, counterclockwise : Bool) = "canvas" "arc"
fn move_to(self : Canvas_ctx, x : Int, y : Int) = "canvas" "moveTo"
fn stroke(self : Canvas_ctx) = "canvas" "stroke"

fn get_pi() -> Double = "math" "PI"
let pi : Double = get_pi()

// We then apply these functions to define the drawing function upon the context
pub fn draw(self : Canvas_ctx) -> Unit {
  self.begin_path()
  self.arc(75, 75, 50, 0.0, pi * 2.0, true) // Outer circle
  self.move_to(110, 75)
  self.arc(75, 75, 35, 0.0, pi, false) // Mouth (clockwise)
  self.move_to(65, 65)
  self.arc(60, 65, 5, 0.0, pi * 2.0, true) // Left eye
  self.move_to(95, 65)
  self.arc(90, 65, 5, 0.0, pi * 2.0, true) // Right eye
  self.stroke()
}

// We also demonstrate the `println` functionality here
pub fn display_pi() -> Unit {
  println("PI: \{pi}")
}
```

```json title="lib/moon.pkg.json"
{
  "link": {
    "wasm": {
      "exports": ["draw", "display_pi"]
    },
    "wasm-gc": {
      "exports": ["draw", "display_pi"]
    }
  }
}
```

Build the project using `moon build`. We recommend using Wasm with GC integration whenever possible (which is the default). If the environment does not support the GC feature, use the `--target wasm` option instead.

We now can use it from JavaScript.

```html title="./index.html"
<html lang="en">
  <body>
    <canvas id="canvas" width="150" height="150"></canvas>
  </body>
  <script>
    // import object for defining the FFI
    const importObject = {
      // TODO
    }

    const canvas = document.getElementById("canvas");
    if (canvas.getContext) {
      const ctx = canvas.getContext("2d");
      WebAssembly.instantiateStreaming(fetch("target/wasm-gc/release/build/lib/lib.wasm"), importObject).then(
        (obj) => {
          // Pass the JS object as parameter to draw the smiling face
          obj.instance.exports["draw"](ctx);
          // Display the value of PI
          obj.instance.exports["display_pi"]();
        }
      );
    }
  </script>
</html>
```

For import object, we need to provide all the FFI used in the previously defined program: the canvas rendering API, the math API and finally, an API for printing to the console used by the `println` or `print` function.

As of the canvas rendering API and the math API, we can use the following code to convert the methods of objects into function calls that accept the object as the first parameter, and convert the constant properties of objects into functions that returns the value:

```javascript
function prototype_to_ffi(prototype) {
  return Object.fromEntries(
    Object.entries(Object.getOwnPropertyDescriptors(prototype))
      .filter(([_key, value]) => value.value)
      .map(([key, value]) => {
        if (typeof value.value == 'function')
          return [key, Function.prototype.call.bind(value.value)]
        // TODO: it is also possible to convert properties into getters and setters
        else
          return [key, () => value.value]
      })
  );
}

const importObject = {
  canvas: prototype_to_ffi(CanvasRenderingContext2D.prototype),
  math: prototype_to_ffi(Math),
  // ...
}
```

As of the printing service, we can provide the following closure so that it buffers the bytes of string until it needs to be logged to the console:

```javascript
const [log, flush] = (() => {
  var buffer = [];
  function flush() {
    if (buffer.length > 0) {
      console.log(new TextDecoder("utf-16").decode(new Uint16Array(buffer).valueOf()));
      buffer = [];
    }
  }
  function log(ch) {
    if (ch == '\n'.charCodeAt(0)) { flush(); }
    else if (ch == '\r'.charCodeAt(0)) { /* noop */ }
    else { buffer.push(ch); }
  }
  return [log, flush]
})();

const importObject = {
  // ...
  spectest: {
    print_char: log
  },
}

// ...
WebAssembly.instantiateStreaming(fetch("target/wasm-gc/release/build/lib/lib.wasm"), importObject).then(
  (obj) => {
    // ...
    flush()
  }
);
```

Now, we put them together, so this is our final complete `index.html`:

```html title="./index.html
<!DOCTYPE html>
<html>

<head></head>

<body>
  <canvas id="canvas" width="150" height="150"></canvas>
  <script>
    function prototype_to_ffi(prototype) {
      return Object.fromEntries(
        Object.entries(Object.getOwnPropertyDescriptors(prototype))
          .filter(([_key, value]) => value.value)
          .map(([key, value]) => {
            if (typeof value.value == 'function')
              return [key, Function.prototype.call.bind(value.value)]
            else
              return [key, () => value.value]
          })
      );
    }

    const [log, flush] = (() => {
      var buffer = [];
      function flush() {
        if (buffer.length > 0) {
          console.log(new TextDecoder("utf-16").decode(new Uint16Array(buffer).valueOf()));
          buffer = [];
        }
      }
      function log(ch) {
        if (ch == '\n'.charCodeAt(0)) { flush(); }
        else if (ch == '\r'.charCodeAt(0)) { /* noop */ }
        else { buffer.push(ch); }
      }
      return [log, flush]
    })();



    const importObject = {
      canvas: prototype_to_ffi(CanvasRenderingContext2D.prototype),
      math: prototype_to_ffi(Math),
      spectest: {
        print_char: log
      },
    }

    const canvas = document.getElementById("canvas");
    if (canvas.getContext) {
      const ctx = canvas.getContext("2d");
      WebAssembly.instantiateStreaming(fetch("target/wasm-gc/release/build/lib/lib.wasm"), importObject).then(
        (obj) => {
          obj.instance.exports["draw"](ctx);
          obj.instance.exports["display_pi"]();
          flush()
        }
      );
    }
  </script>
</body>

</html>
```

Make sure that `draw.wasm` and `index.html` are in the same folder, then start a http server at this folder. For example, using Python:

```bash
python3 -m http.server 8080
```

Goto [http://localhost:8080](http://localhost:8080) in your browser, there should be a smile face on the screen and an output on the console:

![A smile face webpage with browser devtools open](../imgs/smile_face_with_log.png)


================================================
File 467: /data/input/moonbit-docs/next/language/fundamentals.md
================================================
# Fundamentals

## Built-in Data Structures

### Boolean

MoonBit has a built-in boolean type, which has two values: `true` and `false`. The boolean type is used in conditional expressions and control structures.

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:dedent:
:start-after: start boolean 1
:end-before: end boolean 1
```

### Number

MoonBit have integer type and floating point type:

| type     | description                                       | example                    |
| -------- | ------------------------------------------------- | -------------------------- |
| `Int16`  | 16-bit signed integer                             | `(42 : Int16)`             |
| `Int`    | 32-bit signed integer                             | `42`                       |
| `Int64`  | 64-bit signed integer                             | `1000L`                    |
| `UInt16` | 16-bit unsigned integer                           | `(14 : UInt16)`            |
| `UInt`   | 32-bit unsigned integer                           | `14U`                      |
| `UInt64` | 64-bit unsigned integer                           | `14UL`                     |
| `Double` | 64-bit floating point, defined by IEEE754         | `3.14`                     |
| `Float`  | 32-bit floating point                             | `(3.14 : Float)`           |
| `BigInt` | represents numeric values larger than other types | `10000000000000000000000N` |

MoonBit also supports numeric literals, including decimal, binary, octal, and hexadecimal numbers.

To improve readability, you may place underscores in the middle of numeric literals such as `1_000_000`. Note that underscores can be placed anywhere within a number, not just every three digits.

- Decimal numbers can have underscore between the numbers. 

  By default, an int literal is signed 32-bit number. For unsigned numbers, a postfix `U` is needed; for 64-bit numbers, a postfix `L` is needed.

  ```{literalinclude} /sources/language/src/builtin/top.mbt
  :language: moonbit
  :dedent:
  :start-after: start number 1
  :end-before: end number 1
  ```

- A binary number has a leading zero followed by a letter "B", i.e. `0b`/`0B`.
  Note that the digits after `0b`/`0B` must be `0` or `1`.

  ```{literalinclude} /sources/language/src/builtin/top.mbt
  :language: moonbit
  :dedent:
  :start-after: start number 2
  :end-before: end number 2
  ```

- An octal number has a leading zero followed by a letter "O", i.e. `0o`/`0O`.
  Note that the digits after `0o`/`0O` must be in the range from `0` through `7`:

  ```{literalinclude} /sources/language/src/builtin/top.mbt
  :language: moonbit
  :dedent:
  :start-after: start number 3
  :end-before: end number 3
  ```

- A hexadecimal number has a leading zero followed by a letter "X", i.e. `0x`/`0X`.
  Note that the digits after the `0x`/`0X` must be in the range `0123456789ABCDEF`.

  ```{literalinclude} /sources/language/src/builtin/top.mbt
  :language: moonbit
  :dedent:
  :start-after: start number 4
  :end-before: end number 4
  ```

- A floating-point number literal is 64-bit floating-point number. To define a float, type annotation is needed.

  ```{literalinclude} /sources/language/src/builtin/top.mbt
  :language: moonbit
  :dedent:
  :start-after: start number 6
  :end-before: end number 6
  ```

  A 64-bit floating-point number can also be defined using hexadecimal format:

  ```{literalinclude} /sources/language/src/builtin/top.mbt
  :language: moonbit
  :dedent:
  :start-after: start number 7
  :end-before: end number 7
  ```

#### Overloaded literal

When the expected type is known, MoonBit can automatically overload literal, and there is no need to specify the type of number via letter postfix:

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:dedent:
:start-after: start number 5
:end-before: end number 5
```

### String

`String` holds a sequence of UTF-16 code units. You can use double quotes to create a string, or use `#|` to write a multi-line string.

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:dedent:
:start-after: start string 1
:end-before: end string 1
```

```{literalinclude} /sources/language/src/builtin/__snapshot__/string_1
:caption: Output
```

In double quotes string, a backslash followed by certain special characters forms an escape sequence:

| escape sequences     | description                                          |
| -------------------- | ---------------------------------------------------- |
| `\n`,`\r`,`\t`,`\b`  | New line, Carriage return, Horizontal tab, Backspace |
| `\\`                 | Backslash                                            |
| `\x41`               | Hexadecimal escape sequence                          |
| `\o102`              | Octal escape sequence                                |
| `\u5154`,`\u{1F600}` | Unicode escape sequence                              |

MoonBit supports string interpolation. It enables you to substitute variables within interpolated strings. This feature simplifies the process of constructing dynamic strings by directly embedding variable values into the text. Variables used for string interpolation must support the `to_string` method.

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:dedent:
:start-after: start string 3
:end-before: end string 3
```

Multi-line strings do not support interpolation by default, but you can enable interpolation for a specific line by changing the leading `#|` to `$|`:

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:dedent:
:start-after: start string 4
:end-before: end string 4
```

```{literalinclude} /sources/language/src/builtin/__snapshot__/string_4
:caption: Output
```

### Char

`Char` represents a Unicode code point.

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:dedent:
:start-after: start char 1
:end-before: end char 1
```

### Byte(s)

A byte literal in MoonBit is either a single ASCII character or a single escape enclosed in single quotes `'`, and preceded by the character `b`. Byte literals are of type `Byte`. For example:

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:start-after: start byte 1
:end-before: end byte 1
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/builtin/__snapshot__/byte_1
:caption: Output
```

A `Bytes` is an immutable sequence of bytes. Similar to byte, bytes literals have the form of `b"..."`. For example:

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:start-after: start byte 2
:end-before: end byte 2
```

A `@buffer.T` is a constructor for bytes that comes with methods for writing different kinds of data. For example:

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:start-after: start buffer 1
:end-before: end buffer 1
```

### Tuple

A tuple is a collection of finite values constructed using round brackets `()` with the elements separated by commas `,`. The order of elements matters; for example, `(1,true)` and `(true,1)` have different types. Here's an example:

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:start-after: start tuple 1
:end-before: end tuple 1
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/builtin/__snapshot__/tuple_1
:caption: Output
```

Tuples can be accessed via pattern matching or index:

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:start-after: start tuple 2
:end-before: end tuple 2
```

### Ref

A `Ref[T]` is a mutable reference containing a value `val` of type `T`.

It can be constructed using `{ val : x }`, and can be accessed using `ref.val`. See [struct](#struct) for detailed explanation.

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:start-after: start ref 1
:end-before: end ref 1
```

### Option and Result

`Option` and `Result` are the most common types to represent a possible error or failure in MoonBit.

- `Option[T]` represents a possibly missing value of type `T`. It can be abbreviated as `T?`.
- `Result[T, E]` represents either a value of type `T` or an error of type `E`.

See [enum](#enum) for detailed explanation.

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:start-after: start option result 1
:end-before: end option result 1
```

### Array

An array is a finite sequence of values constructed using square brackets `[]`, with elements separated by commas `,`. For example:

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:dedent:
:start-after: start array 1
:end-before: end array 1
```

You can use `numbers[x]` to refer to the xth element. The index starts from zero.

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:dedent:
:start-after: start array 2
:end-before: end array 2
```

There are `Array[T]` and `FixedArray[T]`:

`Array[T]` can grow in size, while `FixedArray[T]` has a fixed size, thus it needs to be created with initial value.

``````{warning}
A common pitfall is creating `FixedArray` with the same initial value:

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:dedent:
:start-after: start array pitfall
:end-before: end array pitfall
```

This is because all the cells reference to the same object (the `FixedArray[Int]` in this case). One should use `FixedArray::makei()` instead which creates an object for each index.

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:dedent:
:start-after: start array pitfall solution
:end-before: end array pitfall solution
```
``````

When the expected type is known, MoonBit can automatically overload array, otherwise
`Array[T]` is created:

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:start-after: start array 3
:end-before: end array 3
```

#### ArrayView

Analogous to `slice` in other languages, the view is a reference to a
specific segment of collections. You can use `data[start:end]` to create a
view of array `data`, referencing elements from `start` to `end` (exclusive).
Both `start` and `end` indices can be omitted.

```{literalinclude} /sources/language/src/operator/top.mbt
:language: moonbit
:start-after: start view 1
:end-before: end view 1
```

### Map

MoonBit provides a hash map data structure that preserves insertion order called `Map` in its standard library.
`Map`s can be created via a convenient literal syntax:

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:start-after: start map 1
:end-before: end map 1
```

Currently keys in map literal syntax must be constant. `Map`s can also be destructed elegantly with pattern matching, see [Map Pattern](#map-pattern).

### Json literal

MoonBit supports convenient json handling by overloading literals.
When the expected type of an expression is `Json`, number, string, array and map literals can be directly used to create json data:

```{literalinclude} /sources/language/src/builtin/top.mbt
:language: moonbit
:start-after: start json 1
:end-before: end json 1
```

Json values can be pattern matched too, see [Json Pattern](#json-pattern).

## Functions

Functions take arguments and produce a result. In MoonBit, functions are first-class, which means that functions can be arguments or return values of other functions. MoonBit's naming convention requires that function names should not begin with uppercase letters (A-Z). Compare for constructors in the `enum` section below.

### Top-Level Functions

Functions can be defined as top-level or local. We can use the `fn` keyword to define a top-level function that sums three integers and returns the result, as follows:

```{literalinclude} /sources/language/src/functions/top.mbt
:language: moonbit
:start-after: start top-level functions
:end-before: end top-level functions
```

Note that the arguments and return value of top-level functions require **explicit** type annotations.

### Local Functions

Local functions can be named or anonymous. Type annotations can be omitted for local function definitions: they can be automatically inferred in most cases. For example:

```{literalinclude} /sources/language/src/functions/top.mbt
:language: moonbit
:start-after: start local functions 1
:end-before: end local functions 1
```

There's also a form called **matrix function** that make use of [pattern matching](#pattern-matching):

```{literalinclude} /sources/language/src/functions/top.mbt
:language: moonbit
:start-after: start local functions 3
:end-before: end local functions 3
```

Functions, whether named or anonymous, are _lexical closures_: any identifiers without a local binding must refer to bindings from a surrounding lexical scope. For example:

```{literalinclude} /sources/language/src/functions/top.mbt
:language: moonbit
:start-after: start local functions 2
:end-before: end local functions 2
```

### Function Applications

A function can be applied to a list of arguments in parentheses:

```moonbit
add3(1, 2, 7)
```

This works whether `add3` is a function defined with a name (as in the previous example), or a variable bound to a function value, as shown below:

```{literalinclude} /sources/language/src/functions/top.mbt
:language: moonbit
:start-after: start function application 1
:end-before: end function application 1
```

The expression `add3(1, 2, 7)` returns `10`. Any expression that evaluates to a function value is applicable:

```{literalinclude} /sources/language/src/functions/top.mbt
:language: moonbit
:dedent:
:start-after: start function application 2
:end-before: end function application 2
```

### Labelled arguments

**Top-level** functions can declare labelled argument with the syntax `label~ : Type`. `label` will also serve as parameter name inside function body:

```{literalinclude} /sources/language/src/functions/top.mbt
:language: moonbit
:start-after: start labelled arguments 1
:end-before: end labelled arguments 1
```

Labelled arguments can be supplied via the syntax `label=arg`. `label=label` can be abbreviated as `label~`:

```{literalinclude} /sources/language/src/functions/top.mbt
:language: moonbit
:start-after: start labelled arguments 2
:end-before: end labelled arguments 2
```

Labelled function can be supplied in any order. The evaluation order of arguments is the same as the order of parameters in function declaration.

### Optional arguments

A labelled argument can be made optional by supplying a default expression with the syntax `label~ : Type = default_expr`. If this argument is not supplied at call site, the default expression will be used:

```{literalinclude} /sources/language/src/functions/top.mbt
:language: moonbit
:start-after: start optional arguments 1
:end-before: end optional arguments 1
```

The default expression will be evaluated every time it is used. And the side effect in the default expression, if any, will also be triggered. For example:

```{literalinclude} /sources/language/src/functions/top.mbt
:language: moonbit
:start-after: start optional arguments 2
:end-before: end optional arguments 2
```

If you want to share the result of default expression between different function calls, you can lift the default expression to a toplevel `let` declaration:

```{literalinclude} /sources/language/src/functions/top.mbt
:language: moonbit
:start-after: start optional arguments 3
:end-before: end optional arguments 3
```

Default expression can depend on the value of previous arguments. For example:

```{literalinclude} /sources/language/src/functions/top.mbt
:language: moonbit
:start-after: start optional arguments 4
:end-before: end optional arguments 4
:emphasize-lines: 4
```

#### Automatically insert `Some` when supplying optional arguments

It is quite often optional arguments have type `T?` with `None` as default value.
In this case, passing the argument explicitly requires wrapping a `Some`,
which is ugly:

```{literalinclude} /sources/language/src/functions/top.mbt
:language: moonbit
:start-after: start optional arguments 5
:end-before: end optional arguments 5
```

Fortunately, MoonBit provides a special kind of optional arguments to solve this problem.
Optional arguments declared with `label? : T` has type `T?` and `None` as default value.
When supplying this kind of optional argument directly, MoonBit will automatically insert a `Some`:

```{literalinclude} /sources/language/src/functions/top.mbt
:language: moonbit
:start-after: start optional arguments 6
:end-before: end optional arguments 6
```

Sometimes, it is also useful to pass a value of type `T?` directly,
for example when forwarding optional argument.
MoonBit provides a syntax `label?=value` for this, with `label?` being an abbreviation of `label?=label`:

```{literalinclude} /sources/language/src/functions/top.mbt
:language: moonbit
:start-after: start optional arguments 7
:end-before: end optional arguments 7
```

### Autofill arguments

MoonBit supports filling specific types of arguments automatically at different call site, such as the source location of a function call.
To declare an autofill argument, simply declare an optional argument with `_` as default value.
Now if the argument is not explicitly supplied, MoonBit will automatically fill it at the call site.

Currently MoonBit supports two types of autofill arguments, `SourceLoc`, which is the source location of the whole function call,
and `ArgsLoc`, which is a array containing the source location of each argument, if any:

```{literalinclude} /sources/language/src/functions/top.mbt
:language: moonbit
:start-after: start autofill arguments
:end-before: end autofill arguments
```

Autofill arguments are very useful for writing debugging and testing utilities.

## Control Structures

### Conditional Expressions

A conditional expression consists of a condition, a consequent, and an optional `else` clause or `else if` clause.

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:dedent:
:start-after: start conditional expressions 1
:end-before: end conditional expressions 1
```

The curly brackets around the consequent are required.

Note that a conditional expression always returns a value in MoonBit, and the return values of the consequent and the else clause must be of the same type. Here is an example:

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:dedent:
:start-after: start conditional expressions 3
:end-before: end conditional expressions 3
```

The `else` clause can only be omitted if the return value has type `Unit`.

### Match Expression

The `match` expression is similar to conditional expression, but it uses [pattern matching](#pattern-matching) to decide which consequent to evaluate and extracting variables at the same time.

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:dedent:
:start-after: start match 1
:end-before: end match 1
```

If a possible condition is omitted, the compiler will issue a warning, and the program will terminate if that case were reached.

### Guard Statement

The `guard` statement is used to check a specified invariant.
If the condition of the invariant is satisfied, the program continues executing
the subsequent statements and returns. If the condition is not satisfied (i.e., false),
the code in the `else` block is executed and its evaluation result is returned (the subsequent statements are skipped).

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:dedent:
:start-after: start guard 1
:end-before: end guard 1
```

#### Guard statement and is expression

The `let` statement can be used with [pattern matching](#pattern-matching). However, `let` statement can only handle one case. And using [is expression](#is-expression) with `guard` statement can solve this issue.

In the following example, `getProcessedText` assumes that the input `path` points to resources that are all plain text,
and it uses the `guard` statement to ensure this invariant while extracting the plain text resource.
Compared to using a `match` statement, the subsequent processing of `text` can have one less level of indentation.

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:start-after: start guard 2
:end-before: end guard 2
```

When the `else` part is omitted, the program terminates if the condition specified
in the `guard` statement is not true or cannot be matched.

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:dedent:
:start-after: start guard 3
:end-before: end guard 3
```

### While loop

In MoonBit, `while` loop can be used to execute a block of code repeatedly as long as a condition is true. The condition is evaluated before executing the block of code. The `while` loop is defined using the `while` keyword, followed by a condition and the loop body. The loop body is a sequence of statements. The loop body is executed as long as the condition is true.

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:start-after: start while loop 1
:end-before: end while loop 1
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/controls/__snapshot__/while_loop_1
:caption: Output
```

The loop body supports `break` and `continue`. Using `break` allows you to exit the current loop, while using `continue` skips the remaining part of the current iteration and proceeds to the next iteration.

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:start-after: start while loop 2
:end-before: end while loop 2
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/controls/__snapshot__/while_loop_2
:caption: Output
```

The `while` loop also supports an optional `else` clause. When the loop condition becomes false, the `else` clause will be executed, and then the loop will end.

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:start-after: start while loop 3
:end-before: end while loop 3
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/controls/__snapshot__/while_loop_3
:caption: Output
```

When there is an `else` clause, the `while` loop can also return a value. The return value is the evaluation result of the `else` clause. In this case, if you use `break` to exit the loop, you need to provide a return value after `break`, which should be of the same type as the return value of the `else` clause.

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:start-after: start while loop 4
:end-before: end while loop 4
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/controls/__snapshot__/while_loop_4
:caption: Output
```

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:start-after: start while loop 5
:end-before: end while loop 5
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/controls/__snapshot__/while_loop_5
:caption: Output
```

### For Loop

MoonBit also supports C-style For loops. The keyword `for` is followed by variable initialization clauses, loop conditions, and update clauses separated by semicolons. They do not need to be enclosed in parentheses.
For example, the code below creates a new variable binding `i`, which has a scope throughout the entire loop and is immutable. This makes it easier to write clear code and reason about it:

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:start-after: start for loop 1
:end-before: end for loop 1
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/controls/__snapshot__/for_loop_1
:caption: Output
```

The variable initialization clause can create multiple bindings:

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:dedent:
:start-after: start for loop 2
:end-before: end for loop 2
```

It should be noted that in the update clause, when there are multiple binding variables, the semantics are to update them simultaneously. In other words, in the example above, the update clause does not execute `i = i + 1`, `j = j + 1` sequentially, but rather increments `i` and `j` at the same time. Therefore, when reading the values of the binding variables in the update clause, you will always get the values updated in the previous iteration.

Variable initialization clauses, loop conditions, and update clauses are all optional. For example, the following two are infinite loops:

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:dedent:
:start-after: start for loop 3
:end-before: end for loop 3
```

The `for` loop also supports `continue`, `break`, and `else` clauses. Like the `while` loop, the `for` loop can also return a value using the `break` and `else` clauses.

The `continue` statement skips the remaining part of the current iteration of the `for` loop (including the update clause) and proceeds to the next iteration. The `continue` statement can also update the binding variables of the `for` loop, as long as it is followed by expressions that match the number of binding variables, separated by commas.

For example, the following program calculates the sum of even numbers from 1 to 6:

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:start-after: start for loop 4
:end-before: end for loop 4
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/controls/__snapshot__/for_loop_4
:caption: Output
```

### `for .. in` loop

MoonBit supports traversing elements of different data structures and sequences via the `for .. in` loop syntax:

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:dedent:
:start-after: start for loop 5
:end-before: end for loop 5
```

`for .. in` loop is translated to the use of `Iter` in MoonBit's standard library. Any type with a method `.iter() : Iter[T]` can be traversed using `for .. in`.
For more information of the `Iter` type, see [Iterator](#iterator) below.

`for .. in` loop also supports iterating through a sequence of integers, such as:

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:dedent:
:start-after: start for loop 10
:end-before: end for loop 10
```

In addition to sequences of a single value, MoonBit also supports traversing sequences of two values, such as `Map`, via the `Iter2` type in MoonBit's standard library.
Any type with method `.iter2() : Iter2[A, B]` can be traversed using `for .. in` with two loop variables:

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:dedent:
:start-after: start for loop 6
:end-before: end for loop 6
```

Another example of `for .. in` with two loop variables is traversing an array while keeping track of array index:

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:start-after: start for loop 7
:end-before: end for loop 7
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/controls/__snapshot__/for_loop_7
:caption: Output
```

Control flow operations such as `return`, `break` and error handling are supported in the body of `for .. in` loop:

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:start-after: start for loop 8
:end-before: end for loop 8
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/controls/__snapshot__/for_loop_8
:caption: Output
```

If a loop variable is unused, it can be ignored with `_`.

### Functional loop

Functional loop is a powerful feature in MoonBit that enables you to write loops in a functional style.

A functional loop consumes arguments and returns a value. It is defined using the `loop` keyword, followed by its arguments and the loop body. The loop body is a sequence of clauses, each of which consists of a pattern and an expression. The clause whose pattern matches the input will be executed, and the loop will return the value of the expression. If no pattern matches, the loop will panic. Use the `continue` keyword with arguments to start the next iteration of the loop. Use the `break` keyword with arguments to return a value from the loop. The `break` keyword can be omitted if the value is the last expression in the loop body.

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:start-after: start for loop 9
:end-before: end for loop 9
```

```{warning}
Currently in `loop exprs { ... }`, `exprs` is nonempty list, while `for { ... }` is accepted for infinite loop.
```

### Labelled Continue/Break

When a loop is labelled, it can be referenced from a `break` or `continue` from
within a nested loop. For example:

```{literalinclude} /sources/language/src/controls/top.mbt
:language: moonbit
:start-after: start loop label
:end-before: end loop label
```

## Iterator

An iterator is an object that traverse through a sequence while providing access
to its elements. Traditional OO languages like Java's `Iterator<T>` use `next()`
`hasNext()` to step through the iteration process, whereas functional languages
(JavaScript's `forEach`, Lisp's `mapcar`) provides a high-order function which
takes an operation and a sequence then consumes the sequence with that operation
being applied to the sequence. The former is called _external iterator_ (visible
to user) and the latter is called _internal iterator_ (invisible to user).

The built-in type `Iter[T]` is MoonBit's internal iterator implementation.
Almost all built-in sequential data structures have implemented `Iter`:

```{literalinclude} /sources/language/src/iter/top.mbt
:language: moonbit
:start-after: start iter 1
:end-before: end iter 1
```

Commonly used methods include:

- `each`: Iterates over each element in the iterator, applying some function to each element.
- `fold`: Folds the elements of the iterator using the given function, starting with the given initial value.
- `collect`: Collects the elements of the iterator into an array.

- `filter`: _lazy_ Filters the elements of the iterator based on a predicate function.
- `map`: _lazy_ Transforms the elements of the iterator using a mapping function.
- `concat`: _lazy_ Combines two iterators into one by appending the elements of the second iterator to the first.

Methods like `filter` `map` are very common on a sequence object e.g. Array.
But what makes `Iter` special is that any method that constructs a new `Iter` is
_lazy_ (i.e. iteration doesn't start on call because it's wrapped inside a
function), as a result of no allocation for intermediate value. That's what
makes `Iter` superior for traversing through sequence: no extra cost. MoonBit
encourages user to pass an `Iter` across functions instead of the sequence
object itself.

Pre-defined sequence structures like `Array` and its iterators should be
enough to use. But to take advantages of these methods when used with a custom
sequence with elements of type `S`, we will need to implement `Iter`, namely, a function that returns
an `Iter[S]`. Take `Bytes` as an example:

```{literalinclude} /sources/language/src/iter/top.mbt
:language: moonbit
:start-after: start iter 2
:end-before: end iter 2
```

Almost all `Iter` implementations are identical to that of `Bytes`, the only
main difference being the code block that actually does the iteration.

### Implementation details

The type `Iter[T]` is basically a type alias for `((T) -> IterResult) -> IterResult`,
a higher-order function that takes an operation and `IterResult` is an enum
object that tracks the state of current iteration which consists any of the 2
states:

- `IterEnd`: marking the end of an iteration
- `IterContinue`: marking the end of an iteration is yet to be reached, implying the iteration will still continue at this state.

To put it simply, `Iter[T]` takes a function `(T) -> IterResult` and use it to
transform `Iter[T]` itself to a new state of type `IterResult`. Whether that
state being `IterEnd` `IterContinue` depends on the function.

Iterator provides a unified way to iterate through data structures, and they
can be constructed at basically no cost: as long as `fn(yield)` doesn't
execute, the iteration process doesn't start.

Internally a `Iter::run()` is used to trigger the iteration. Chaining all sorts
of `Iter` methods might be visually pleasing, but do notice the heavy work
underneath the abstraction.

Thus, unlike an external iterator, once the iteration starts
there's no way to stop unless the end is reached. Methods such as `count()`
which counts the number of elements in a iterator looks like an `O(1)` operation
but actually has linear time complexity. Carefully use iterators or
performance issue might occur.

## Custom Data Types

There are two ways to create new data types: `struct` and `enum`.

### Struct

In MoonBit, structs are similar to tuples, but their fields are indexed by field names. A struct can be constructed using a struct literal, which is composed of a set of labeled values and delimited with curly brackets. The type of a struct literal can be automatically inferred if its fields exactly match the type definition. A field can be accessed using the dot syntax `s.f`. If a field is marked as mutable using the keyword `mut`, it can be assigned a new value.

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start struct 1
:end-before: end struct 1
```

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start struct 2
:end-before: end struct 2
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/data/__snapshot__/struct_1
:caption: Output
```

#### Constructing Struct with Shorthand

If you already have some variable like `name` and `email`, it's redundant to repeat those names when constructing a struct. You can use shorthand instead, it behaves exactly the same:

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:dedent:
:start-after: start struct 3
:end-before: end struct 3
```

If there's no other struct that has the same fields, it's redundant to add the struct's name when constructing it:

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:dedent:
:start-after: start struct 5
:end-before: end struct 5
```

#### Struct Update Syntax

It's useful to create a new struct based on an existing one, but with some fields updated.

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start struct 4
:end-before: end struct 4
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/data/__snapshot__/struct_4
:caption: Output
```

### Enum

Enum types are similar to algebraic data types in functional languages. Users familiar with C/C++ may prefer calling it tagged union.

An enum can have a set of cases (constructors). Constructor names must start with capitalized letter. You can use these names to construct corresponding cases of an enum, or checking which branch an enum value belongs to in pattern matching:

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start enum 1
:end-before: end enum 1
```

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:dedent:
:start-after: start enum 2
:end-before: end enum 2
```

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start enum 3
:end-before: end enum 3
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/data/__snapshot__/enum_3
:caption: Output
```

Enum cases can also carry payload data. Here's an example of defining an integer list type using enum:

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start enum 4
:end-before: end enum 4
```

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:dedent:
:start-after: start enum 5
:end-before: end enum 5
```

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start enum 6
:end-before: end enum 6
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/data/__snapshot__/enum_6
:caption: Output
```

#### Constructor with labelled arguments

Enum constructors can have labelled argument:

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start enum 7
:end-before: end enum 7
```

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:dedent:
:start-after: start enum 8
:end-before: end enum 8
```

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start enum 9
:end-before: end enum 9
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/data/__snapshot__/enum_9
:caption: Output
```

It is also possible to access labelled arguments of constructors like accessing struct fields in pattern matching:

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start enum 10
:end-before: end enum 10
```

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start enum 11
:end-before: end enum 11
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/data/__snapshot__/enum_11
:caption: Output
```

#### Constructor with mutable fields

It is also possible to define mutable fields for constructor. This is especially useful for defining imperative data structures:

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start enum 12
:end-before: end enum 12
```

### Newtype

MoonBit supports a special kind of enum called newtype:

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start newtype 1
:end-before: end newtype 1
```

Newtypes are similar to enums with only one constructor (with the same name as the newtype itself). So, you can use the constructor to create values of newtype, or use pattern matching to extract the underlying representation of a newtype:

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start newtype 2
:end-before: end newtype 2
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/data/__snapshot__/newtype_2
:caption: Output
```

Besides pattern matching, you can also use `._` to extract the internal representation of newtypes:

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start newtype 3
:end-before: end newtype 3
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/data/__snapshot__/newtype_3
:caption: Output
```

### Type alias
MoonBit supports type alias via the syntax `typealias Name = TargetType`:

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start typealias 1
:end-before: end typealias 1
```

Unlike all other kinds of type declaration above, type alias does not define a new type,
it is merely a type macro that behaves exactly the same as its definition.
So for example one cannot define new methods or implement traits for a type alias.

```{tip}
Type alias can be used to perform incremental code refactor.

For example, if you want to move a type `T` from `@pkgA` to `@pkgB`,
you can leave a type alias `typealias T = @pkgB.T` in `@pkgA`, and **incrementally** port uses of `@pkgA.T` to `@pkgB.T`.
The type alias can be removed after all uses of `@pkgA.T` is migrated to `@pkgB.T`.
```

### Local types

Moonbit supports declaring structs/enums/newtypes at the top of a toplevel
function, which are only visible within the current toplevel function. These
local types can use the generic parameters of the toplevel function but cannot
introduce additional generic parameters themselves. Local types can derive
methods using derive, but no additional methods can be defined manually. For 
example:

```{literalinclude} /sources/language/src/data/top.mbt
:language: moonbit
:start-after: start local-type 1
:end-before: end local-type 1
```

Currently, local types do not support being declared as error types. 

## Pattern Matching

Pattern matching allows us to match on specific pattern and bind data from data structures.

### Simple Patterns

We can pattern match expressions against

- literals, such as boolean values, numbers, chars, strings, etc
- constants
- structs
- enums
- arrays
- maps
- JSONs

and so on. We can define identifiers to bind the matched values so that they can be used later.

```{literalinclude} /sources/language/src/pattern/top.mbt
:language: moonbit
:dedent:
:start-after: start simple pattern 1
:end-before: end simple pattern 1
```

We can use `_` as wildcards for the values we don't care about, and use `..` to ignore remaining fields of struct or enum, or array (see [array pattern](#array-pattern)).

```{literalinclude} /sources/language/src/pattern/top.mbt
:language: moonbit
:dedent:
:start-after: start simple pattern 2
:end-before: end simple pattern 2
```

We can use `as` to give a name to some pattern, and we can use `|` to match several cases at once. A variable name can only be bound once in a single pattern, and the same set of variables should be bound on both sides of `|` patterns.

```{literalinclude} /sources/language/src/pattern/top.mbt
:language: moonbit
:dedent:
:start-after: start pattern 3
:end-before: end pattern 3
```

### Array Pattern

For `Array`, `FixedArray` and `ArrayView`, MoonBit allows using array pattern.

Array pattern have the following forms:

- `[]` : matching for an empty data structure
- `[pa, pb, pc]` : matching for known number of elements, 3 in this example
- `[pa, ..]` : matching for known number of elements, followed by unknown number of elements
- `[.., pa]` : matching for known number of elements, preceded by unknown number of elements

```{literalinclude} /sources/language/src/pattern/top.mbt
:language: moonbit
:start-after: start pattern 2
:end-before: end pattern 2
```

### Range Pattern
For builtin integer types and `Char`, MoonBit allows matching whether the value falls in a specific range.

Range patterns have the form `a..<b` or `a..=b`, where `..<` means the upper bound is exclusive, and `..=` means inclusive upper bound.
`a` and `b` can be one of:

- literal
- named constant declared with `const`
- `_`, meaning the pattern has no restriction on this side

Here are some examples:

```{literalinclude} /sources/language/src/pattern/top.mbt
:language: moonbit
:dedent:
:start-after: start pattern 4
:end-before: end pattern 4
```

### Map Pattern

MoonBit allows convenient matching on map-like data structures.
Inside a map pattern, the `key : value` syntax will match if `key` exists in the map, and match the value of `key` with pattern `value`.
The `key? : value` syntax will match no matter `key` exists or not, and `value` will be matched against `map[key]` (an optional).

```{literalinclude} /sources/language/src/pattern/top.mbt
:language: moonbit
:dedent:
:start-after: start pattern 5
:end-before: end pattern 5
```

- To match a data type `T` using map pattern, `T` must have a method `op_get(Self, K) -> Option[V]` for some type `K` and `V` (see [method and trait](./methods.md)).
- Currently, the key part of map pattern must be a literal or constant
- Map patterns are always open: the unmatched keys are silently ignored, and `..` needs to be added to identify this nature
- Map pattern will be compiled to efficient code: every key will be fetched at most once

### Json Pattern

When the matched value has type `Json`, literal patterns can be used directly, together with constructors:

```{literalinclude} /sources/language/src/pattern/top.mbt
:language: moonbit
:dedent:
:start-after: start pattern 6
:end-before: end pattern 6
```

## Generics

Generics are supported in top-level function and data type definitions. Type parameters can be introduced within square brackets. We can rewrite the aforementioned data type `List` to add a type parameter `T` to obtain a generic version of lists. We can then define generic functions over lists like `map` and `reduce`.

```{literalinclude} /sources/language/src/generics/top.mbt
:language: moonbit
```

## Special Syntax

### Pipe operator

MoonBit provides a convenient pipe operator `|>`, which can be used to chain regular function calls:

```{literalinclude} /sources/language/src/operator/top.mbt
:language: moonbit
:dedent:
:start-after: start operator 4
:end-before: end operator 4
```

### Cascade Operator

The cascade operator `..` is used to perform a series of mutable operations on
the same value consecutively. The syntax is as follows:

```{literalinclude} /sources/language/src/operator/top.mbt
:language: moonbit
:dedent:
:start-after: start operator 5
:end-before: end operator 5
```

`x..f()..g()` is equivalent to `{x.f(); x.g(); x}`.

Consider the following scenario: for a `StringBuilder` type that has methods
like `write_string`, `write_char`, `write_object`, etc., we often need to perform
a series of operations on the same `StringBuilder` value:

```{literalinclude} /sources/language/src/operator/top.mbt
:language: moonbit
:dedent:
:start-after: start operator 6
:end-before: end operator 6
```

To avoid repetitive typing of `builder`, its methods are often designed to
return `self` itself, allowing operations to be chained using the `.` operator.
To distinguish between immutable and mutable operations, in MoonBit,
for all methods that return `Unit`, cascade operator can be used for
consecutive operations without the need to modify the return type of the methods.

```{literalinclude} /sources/language/src/operator/top.mbt
:language: moonbit
:dedent:
:start-after: start operator 7
:end-before: end operator 7
```

### Is Expression

The `is` expression tests whether a value conforms to a specific pattern. It
returns a `Bool` value and can be used anywhere a boolean value is expected,
for example:

```{literalinclude} /sources/language/src/is/top.mbt
:language: moonbit
:dedent:
:start-after: start is 1
:end-before: end is 1
```

Pattern binders introduced by `is` expressions can be used in the following
contexts:

1. In boolean AND expressions (`&&`):
   binders introduced in the left-hand expression can be used in the right-hand
   expression

   ```{literalinclude} /sources/language/src/is/top.mbt
   :language: moonbit
   :dedent:
   :start-after: start is 2
   :end-before: end is 2
   ```

2. In the first branch of `if` expression: if the condition is a sequence of
   boolean expressions `e1 && e2 && ...`, the binders introduced by the `is`
   expression can be used in the branch where the condition evaluates to `true`.

   ```{literalinclude} /sources/language/src/is/top.mbt
   :language: moonbit
   :dedent:
   :start-after: start is 3
   :end-before: end is 3
   ```

3. In the following statements of a `guard` condition:

   ```{literalinclude} /sources/language/src/is/top.mbt
   :language: moonbit
   :dedent:
   :start-after: start is 4
   :end-before: end is 4
   ```

4. In the body of a `while` loop:

   ```{literalinclude} /sources/language/src/is/top.mbt
   :language: moonbit
   :dedent:
   :start-after: start is 5
   :end-before: end is 5
   ```

### TODO syntax

The `todo` syntax (`...`) is a special construct used to mark sections of code that are not yet implemented or are placeholders for future functionality. For example:

```{literalinclude} /sources/language/src/misc/top.mbt
:language: moonbit
:start-after: start todo 1
:end-before: end todo 1
```


================================================
File 468: /data/input/moonbit-docs/next/language/index.md
================================================
# MoonBit Language

MoonBit is an end-to-end programming language toolchain for cloud and edge computing using WebAssembly. The IDE environment is available at [https://try.moonbitlang.com](https://try.moonbitlang.com) without any installation; it does not rely on any server either.

**Status and aimed timeline**

MoonBit is currently in beta-preview. We expect to reach 1.0 in 2025.

When MoonBit reaches beta, it means any backwards-incompatible changes will be seriously evaluated and MoonBit _can_ be used in production(very rare compiler bugs). MoonBit is developed by a talented full time team who had extensive experience in building language toolchains, so we will grow much faster than the typical language ecosystem, you won't wait long to use MoonBit in your production.

**Main advantages**

- Generate significantly smaller WASM output than any existing solutions.
- Much faster runtime performance.
- State of the art compile-time performance.
- Simple but practical, data-oriented language design.

```{only} html
[Download this section in Markdown](path:/download/language/summary.md)
```

```{toctree}
:hidden:
introduction
fundamentals
methods
error-handling
packages
tests
docs
ffi-and-wasm-host
derive
async-experimental
error_codes/index
```


================================================
File 469: /data/input/moonbit-docs/next/language/introduction.md
================================================
# Introduction

A MoonBit program consists of top-level definitions including:

- type definitions
- function definitions
- constant definitions and variable bindings
- `init` functions, `main` function and/or `test` blocks.

## Expressions and Statements

MoonBit distinguishes between statements and expressions. In a function body, only the last clause should be an expression, which serves as a return value. For example:

```{code-block} moonbit
:class: top-level
fn foo() -> Int {
  let x = 1
  x + 1
}

fn bar() -> Int {
  let x = 1
  //! x + 1
  x + 2
}
```

Expressions include:

- Value literals (e.g. Boolean values, numbers, characters, strings, arrays, tuples, structs)
- Arithmetical, logical, or comparison operations
- Accesses to array elements (e.g. `a[0]`), struct fields (e.g `r.x`), tuple components (e.g. `t.0`), etc.
- Variables and (capitalized) enum constructors
- Anonymous local function definitions
- `match`, `if`, `loop` expressions, etc.

Statements include:

- Named local function definitions
- Local variable bindings
- Assignments
- `return` statements
- Any expression whose return type is `Unit`, (e.g. `ignore`)

A code block can contain multiple statements and one expression, and the value of the expression is the value of the code block.

## Variable Binding

A variable can be declared as mutable or immutable using `let mut` or `let`, respectively. A mutable variable can be reassigned to a new value, while an immutable one cannot.

A constant can only be declared at top level and cannot be changed.

```{code-block} moonbit
:class: top-level
let zero = 0

const ZERO = 0

fn main {
  //! const ZERO = 0 
  let mut i = 10
  i = 20
  println(i + zero + ZERO)
}
```

```{note}
A top level variable binding 
- requires **explicit** type annotation (unless defined using literals such as string, byte or numbers)
- can't be mutable (use `Ref` instead)
```


## Naming conventions

Variables, functions should start with lowercase letters `a-z` and can contain letters, numbers, underscore, and other non-ascii unicode chars.
It is recommended to name them with snake_case.

Constants, types should start with uppercase letters `A-Z` and can contain letters, numbers, underscore, and other non-ascii unicode chars.
It is recommended to name them with PascalCase or SCREAMING_SNAKE_CASE.

## Program entrance

### `init` and `main`
There is a specialized function called `init` function. The `init` function is special:

1. It has no parameter list nor return type.
2. There can be multiple `init` functions in the same package.
3. An `init` function can't be explicitly called or referred to by other functions. 
Instead, all `init` functions will be implicitly called when initializing a package. Therefore, `init` functions should only consist of statements.

```{code-block} moonbit
:class: top-level
fn init {
  let x = 1
  println(x)
}
```

There is another specialized function called `main` function. The `main` function is the main entrance of the program, and it will be executed after the initialization stage.

Same as the `init` function, it has no parameter list nor return type.

```{code-block} moonbit
:class: top-level
fn main {
  let x = 2
  println(x)
}
```

The previous two code snippets will print the following at runtime:

```bash
1
2
```

Only packages that are `main` packages can define such `main` function. Check out [build system tutorial](/toolchain/moon/tutorial) for detail.

```{literalinclude} /sources/language/src/main/moon.pkg.json
:language: json
:caption: moon.pkg.json
```

### `test`

There's also a top-level structure called `test` block. A `test` block defines inline tests, such as:

```{literalinclude} /sources/language/src/test/top.mbt
:language: moonbit
:start-after: start test 1
:end-before: end test 1
```

The following contents will use `test` block and `main` function to demonstrate the execution result,
and we assume that all the `test` blocks pass unless stated otherwise.

================================================
File 470: /data/input/moonbit-docs/next/language/methods.md
================================================
# Method and Trait

## Method system

MoonBit supports methods in a different way from traditional object-oriented languages. A method in MoonBit is just a toplevel function associated with a type constructor.
There are two ways to define a method:

- `fn method_name(self : SelfType, ..)`, where the method belongs to `SelfType`. The name of the first parameter must be `self` here
- `fn SelfTypeName::method_name(...)`, where the method belongs to `SelfTypeName`

```{literalinclude} /sources/language/src/method2/top.mbt
:language: moonbit
:start-after: start method declaration example
:end-before: end method declaration example
```

The difference between these two syntax is:
the syntax `fn method_name(self : T, ..)` defines a regular function.
So the defined method can be involked directly, just like regular functions.
In the `fn T::method_name(..)` syntax, however,
the method is defined in the small namespace `T`, and must be involked using qualified syntax `T::method_name(..)`:

```{literalinclude} /sources/language/src/method2/top.mbt
:language: moonbit
:start-after: start method call syntax example
:end-before: end method call syntax example
```

Unlike regular functions, methods defined using the `TypeName::method_name` syntax support overloading:
different types can define methods of the same name, because each method lives in a different name space:

```{literalinclude} /sources/language/src/method/top.mbt
:language: moonbit
:dedent:
:start-after: start method overload example
:end-before: end method overload example
```

When the first parameter of a method is also the type it belongs to, methods can be called using dot syntax `x.method(...)`. MoonBit automatically finds the correct method based on the type of `x`, there is no need to write the type name and even the package name of the method:

```{literalinclude} /sources/language/src/method/top.mbt
:language: moonbit
:start-after: start method 1
:end-before: end method 1
```

```{literalinclude} /sources/language/src/method2/top.mbt
:language: moonbit
:caption: using package with alias list
:start-after: start dot syntax example
:end-before: end dot syntax example
```

### API design guideline

Since there are two ways to define methods, and both allow dot syntax,
a natural question is which syntax to choose when designing the API of a package.
The rule here is:

- if the package exports only one primary type,
or if a method is intuitively unambiguous in the package,
use the `fn f(self : T, ..)` syntax
- otherwise, use the qualified `fn T::f(..)` syntax

## Operator Overloading

MoonBit supports operator overloading of builtin operators via methods. The method name corresponding to a operator `<op>` is `op_<op>`. For example:

```{literalinclude} /sources/language/src/operator/top.mbt
:language: moonbit
:start-after: start operator 1
:end-before: end operator 1
```

Another example about `op_get` and `op_set`:

```{literalinclude} /sources/language/src/operator/top.mbt
:language: moonbit
:start-after: start operator 2
:end-before: end operator 2
```

```{literalinclude} /sources/language/src/operator/top.mbt
:language: moonbit
:start-after: start operator 3
:end-before: end operator 3
:prepend: "fn main {"
:append: "}"
```

```{literalinclude} /sources/language/src/operator/__snapshot__/operator_3
:caption: Output
```

Currently, the following operators can be overloaded:

| Operator Name         | Method Name  | Recommended Signature   |
| --------------------- | ------------ | ----------------------- |
| `+`                   | `op_add`     | `(A, A) -> X`           |
| `-`                   | `op_sub`     | `(A, A) -> X`           |
| `*`                   | `op_mul`     | `(A, A) -> X`           |
| `/`                   | `op_div`     | `(A, A) -> X`           |
| `%`                   | `op_mod`     | `(A, A) -> X`           |
| `==`                  | `op_equal`   | `(A, A) -> Bool` (Required by trait `Eq`) |
| `<<`                  | `op_shl`     | `(A, B) -> X`           |
| `>>`                  | `op_shr`     | `(A, B) -> X`           |
| `-` (unary)           | `op_neg`     | `(A) -> X`              |
| `_[_]` (get item)     | `op_get`     | `(A, B) -> X`           |
| `_[_] = _` (set item) | `op_set`     | `(A, B, C) -> Unit`     |
| `_[_:_]` (view)       | `op_as_view` | `(A, start? : B, end? : C) -> X` |
| `&`                   | `land`       | `(A, B) -> X`           |
| `\|`                  | `lor`        | `(A, B) -> X`           |
| `^`                   | `lxor`       | `(A, B) -> X`           |

By implementing `op_as_view` method, you can create a view for a user-defined type. Here is an example:

```{literalinclude} /sources/language/src/operator/top.mbt
:language: moonbit
:start-after: start view 2
:end-before: end view 2
```

## Trait system

MoonBit provides a trait system for overloading/ad-hoc polymorphism. Traits declare a list of operations, which must be supplied when a type wants to implement the trait. Traits can be declared as follows:

```{literalinclude} /sources/language/src/trait/top.mbt
:language: moonbit
:start-after: start trait 1
:end-before: end trait 1
```

In the body of a trait definition, a special type `Self` is used to refer to the type that implements the trait.

### Extending traits

A trait can depend on other traits, for example:

```{literalinclude} /sources/language/src/trait/top.mbt
:language: moonbit
:start-after: start super trait 1
:end-before: end super trait 1
```

To implement the sub trait, one will have to implement the super traits,
and the methods defined in the sub trait.

### Implementing traits

To implement a trait, a type must explicitly provide all the methods required by the trait
using the syntax `impl Trait for Type with method_name(...) { ... }`. For example:

```{literalinclude} /sources/language/src/trait/top.mbt
:language: moonbit
:start-after: start trait 2
:end-before: end trait 2
```

Type annotation can be omitted for trait `impl`: MoonBit will automatically infer the type based on the signature of `Trait::method` and the self type.

The author of the trait can also define **default implementations** for some methods in the trait, for example:

```{literalinclude} /sources/language/src/trait/top.mbt
:language: moonbit
:start-after: start trait 3
:end-before: end trait 3
```

Implementers of trait `I` don't have to provide an implementation for `f_twice`: to implement `I`, only `f` is necessary.
They can always override the default implementation with an explicit `impl I for Type with f_twice`, if desired, though.

### Using traits

When declaring a generic function, the type parameters can be annotated with the traits they should implement, allowing the definition of constrained generic functions. For example:

```{literalinclude} /sources/language/src/trait/top.mbt
:language: moonbit
:start-after: start trait 5
:end-before: end trait 5
```

Without the `Eq` requirement, the expression `x == elem` in `contains` will result in a type error. Now, the function `contains` can be called with any type that implements `Eq`, for example:

```{literalinclude} /sources/language/src/trait/top.mbt
:language: moonbit
:start-after: start trait 6
:end-before: end trait 6
```

#### Invoke trait methods directly

Methods of a trait can be called directly via `Trait::method`. MoonBit will infer the type of `Self` and check if `Self` indeed implements `Trait`, for example:

```{literalinclude} /sources/language/src/trait/top.mbt
:language: moonbit
:start-after: start trait 7
:end-before: end trait 7
```

Trait implementations can also be invoked via dot syntax, with the following restrictions:

1. if a regular method is present, the regular method is always favored when using dot syntax
2. only trait implementations that are located in the package of the self type can be invoked via dot syntax
   - if there are multiple trait methods (from different traits) with the same name available, an ambiguity error is reported
3. if neither of the above two rules apply, trait `impl`s in current package will also be searched for dot syntax.
   This allows extending a foreign type locally.
   - these `impl`s can only be called via dot syntax locally, even if they are public.

The above rules ensures that MoonBit's dot syntax enjoys good property while being flexible.
For example, adding a new dependency never break existing code with dot syntax due to ambiguity.
These rules also make name resolution of MoonBit extremely simple:
the method called via dot syntax must always come from current package or the package of the type!

Here's an example of calling trait `impl` with dot syntax:

```{literalinclude} /sources/language/src/trait/top.mbt
:language: moonbit
:start-after: start trait 8
:end-before: end trait 8
```

## Trait objects

MoonBit supports runtime polymorphism via trait objects.
If `t` is of type `T`, which implements trait `I`,
one can pack the methods of `T` that implements `I`, together with `t`,
into a runtime object via `t as &I`.
When the expected type of an expression is known to be a trait object type, `as &I` can be omitted.
Trait object erases the concrete type of a value,
so objects created from different concrete types can be put in the same data structure and handled uniformly:

```{literalinclude} /sources/language/src/trait/top.mbt
:language: moonbit
:start-after: start trait object 1
:end-before: end trait object 1
```

Not all traits can be used to create objects.
"object-safe" traits' methods must satisfy the following conditions:

- `Self` must be the first parameter of a method
- There must be only one occurrence of `Self` in the type of the method (i.e. the first parameter)

Users can define new methods for trait objects, just like defining new methods for structs and enums:

```{literalinclude} /sources/language/src/trait/top.mbt
:language: moonbit
:start-after: start trait object 2
:end-before: end trait object 2
```

## Builtin traits

MoonBit provides the following useful builtin traits:

<!-- MANUAL CHECK https://github.com/moonbitlang/core/blob/80cf250d22a5d5eff4a2a1b9a6720026f2fe8e38/builtin/traits.mbt -->

```moonbit
trait Eq {
  op_equal(Self, Self) -> Bool
}

trait Compare : Eq {
  // `0` for equal, `-1` for smaller, `1` for greater
  compare(Self, Self) -> Int
}

trait Hash {
  hash_combine(Self, Hasher) -> Unit // to be implemented
  hash(Self) -> Int // has default implementation
}

trait Show {
  output(Self, Logger) -> Unit // to be implemented
  to_string(Self) -> String // has default implementation
}

trait Default {
  default() -> Self
}
```

### Deriving builtin traits

MoonBit can automatically derive implementations for some builtin traits:

```{literalinclude} /sources/language/src/trait/top.mbt
:language: moonbit
:start-after: start trait 9
:end-before: end trait 9
```

See [Deriving](./derive.md) for more information about deriving traits.


================================================
File 471: /data/input/moonbit-docs/next/language/packages.md
================================================
# Managing Projects with Packages

When developing projects at large scale, the project usually needs to be divided into smaller modular unit that depends on each other. 
More often, it involves using other people's work: most noticeably is the [core](https://github.com/moonbitlang/core), the standard library of MoonBit.

## Packages and modules

In MoonBit, the most important unit for code organization is a package, which consists of a number of source code files and a single `moon.pkg.json` configuration file.
A package can either be a `main` package, consisting a `main` function, or a package that serves as a library. 

A project, corresponding to a module, consists of multiple packages and a single `moon.mod.json` configuration file.

When using things from another package, the dependency between modules should first be declared inside the `moon.mod.json`.
The dependency between packages should then be declared inside the `moon.pkg.json`.
Then it is possible to use `@pkg` to access the imported entities, where `pkg` is the last part of the imported package's path or the declared alias in `moon.pkg.json`:

```{literalinclude} /sources/language/src/packages/pkgB/moon.pkg.json
:language: json
:caption: pkgB/moon.pkg.json
```

```{literalinclude} /sources/language/src/packages/pkgB/top.mbt
:language: moonbit
:caption: pkgB/top.mbt
```

### Internal Packages

You can define internal packages that are only available for certain packages.

Code in `a/b/c/internal/x/y/z` are only available to packages `a/b/c` and `a/b/c/**`.

## Access Control

By default, all function definitions and variable bindings are _invisible_ to other packages.
You can use the `pub` modifier before toplevel `let`/`fn` to make them public.

There are four different kinds of visibility for types in MoonBit:

- private type, declared with `priv`, completely invisible to the outside world
- abstract type, which is the default visibility for types. Only the name of an abstract type is visible outside, the internal representation of the type is hidden
- readonly types, declared with `pub`. The internal representation of readonly types are visible outside,
but users can only read the values of these types from outside, construction and mutation are not allowed
- fully public types, declared with `pub(all)`. The outside world can freely construct, modify and read values of these types

In addition to the visibility of the type itself, the fields of a public `struct` can be annotated with `priv`,
which will hide the field from the outside world completely.
Note that `struct`s with private fields cannot be constructed directly outside,
but you can update the public fields using the functional struct update syntax.

Readonly types is a very useful feature, inspired by [private types](https://v2.ocaml.org/manual/privatetypes.html) in OCaml. In short, values of `pub` types can be destructed by pattern matching and the dot syntax, but cannot be constructed or mutated in other packages. Note that there is no restriction within the same package where `pub` types are defined.

<!-- MANUAL CHECK -->

```moonbit
// Package A
pub struct RO {
  field: Int
}
test {
  let r = { field: 4 }       // OK
  let r = { ..r, field: 8 }  // OK
}

// Package B
fn println(r : RO) -> Unit {
  println("{ field: ")
  println(r.field)  // OK
  println(" }")
}
test {
  let r : RO = { field: 4 }  // ERROR: Cannot create values of the public read-only type RO!
  let r = { ..r, field: 8 }  // ERROR: Cannot mutate a public read-only field!
}
```

Access control in MoonBit adheres to the principle that a `pub` type, function, or variable cannot be defined in terms of a private type. This is because the private type may not be accessible everywhere that the `pub` entity is used. MoonBit incorporates sanity checks to prevent the occurrence of use cases that violate this principle.

<!-- MANUAL CHECK -->
```moonbit
pub(all) type T1
pub(all) type T2
priv type T3

pub(all) struct S {
  x: T1  // OK
  y: T2  // OK
  z: T3  // ERROR: public field has private type `T3`!
}

// ERROR: public function has private parameter type `T3`!
pub fn f1(_x: T3) -> T1 { ... }
// ERROR: public function has private return type `T3`!
pub fn f2(_x: T1) -> T3 { ... }
// OK
pub fn f3(_x: T1) -> T1 { ... }

pub let a: T3 = { ... } // ERROR: public variable has private type `T3`!
```

## Access control of methods and trait implementations

To make the trait system coherent (i.e. there is a globally unique implementation for every `Type: Trait` pair),
and prevent third-party packages from modifying behavior of existing programs by accident,
MoonBit employs the following restrictions on who can define methods/implement traits for types:

- _only the package that defines a type can define methods for it_. So one cannot define new methods or override old methods for builtin and foreign types.
- _only the package of the type or the package of the trait can define an implementation_.
  For example, only `@pkg1` and `@pkg2` are allowed to write `impl @pkg1.Trait for @pkg2.Type`.

The second rule above allows one to add new functionality to a foreign type by defining a new trait and implementing it.
This makes MoonBit's trait & method system flexible while enjoying good coherence property.

## Visibility of traits and sealed traits

There are four visibility for traits, just like `struct` and `enum`: private, abstract, readonly and fully public.
- Private traits are declared with `priv trait`, and they are completely invisible from outside.
- Abstract trait is the default visibility. Only the name of the trait is visible from outside, and the methods in the trait are not exposed.
- Readonly traits are declared with `pub trait`, their methods can be invoked from outside, but only the current package can add new implementation for readonly traits.
- Fully public traits are declared with `pub(open) trait`, they are open to new implementations outside current package, and their methods can be freely used.

Abstract and readonly traits are sealed, because only the package defining the trait can implement them.
Implementing a sealed (abstract or readonly) trait outside its package result in compiler error.

Implementations have independent visibility, just like functions. The type will not be considered having fulfillled the trait outside current package unless the implementation is `pub`.

```{note}
Currently, you cannot implement an empty trait for a type.
```

Here's an example of abstract trait:

<!-- MANUAL CHECK -->
```moonbit
trait Number {
 op_add(Self, Self) -> Self
 op_sub(Self, Self) -> Self
}

fn add[N : Number](x : N, y: N) -> N {
  Number::op_add(x, y)
}

fn sub[N : Number](x : N, y: N) -> N {
  Number::op_sub(x, y)
}

impl Number for Int with op_add(x, y) { x + y }
impl Number for Int with op_sub(x, y) { x - y }

impl Number for Double with op_add(x, y) { x + y }
impl Number for Double with op_sub(x, y) { x - y }
```

From outside this package, users can only see the following:

```moonbit
trait Number

fn op_add[N : Number](x : N, y : N) -> N
fn op_sub[N : Number](x : N, y : N) -> N

impl Number for Int
impl Number for Double
```

The author of `Number` can make use of the fact that only `Int` and `Double` can ever implement `Number`,
because new implementations are not allowed outside.


================================================
File 472: /data/input/moonbit-docs/next/language/tests.md
================================================
# Writing Tests

Tests are important for improving quality and maintainability of a program. They verify the behavior of a program and also serves as a specification to avoid regressions over time.

MoonBit comes with test support to make the writing easier and simpler.

## Test Blocks

MoonBit provides the test code block for writing inline test cases. For example:

```{literalinclude} /sources/language/src/test/top.mbt
:language: moonbit
:start-after: start test 1
:end-before: end test 1
```

A test code block is essentially a function that returns a `Unit` but may throws a `String` on error, or `Unit!String` as one would see in its signature at the position of return type. It is called during the execution of `moon test` and outputs a test report through the build system. The `assert_eq` function is from the standard library; if the assertion fails, it prints an error message and terminates the test. The string `"test_name"` is used to identify the test case and is optional. 

If a test name starts with `"panic"`, it indicates that the expected behavior of the test is to trigger a panic, and the test will only pass if the panic is triggered. For example:

```{literalinclude} /sources/language/src/test/top.mbt
:language: moonbit
:start-after: start test 2
:end-before: end test 2
```

## Snapshot Tests

Writing tests can be tedious when specifying the expected values. Thus, MoonBit provides three kinds of snapshot tests.
All of which can be inserted or updated automatically using `moon test --update`.

### Snapshotting `Show`

We can use `inspect!(x, content="x")` to inspect anything that implements `Show` trait. 
As we mentioned before, `Show` is a builtin trait that can be derived, providing `to_string` that will print the content of the data structures. 
The labelled argument `content` can be omitted as `moon test --update` will insert it for you:

```{literalinclude} /sources/language/src/test/top.mbt
:language: moonbit
:start-after: start snapshot test 1
:end-before: end snapshot test 1
```

### Snapshotting `JSON`

The problem with the derived `Show` trait is that it does not perform pretty printing, resulting in extremely long output.

The solution is to use `@json.inspect!(x, content=x)`. The benefit is that the resulting content is a JSON structure, which can be more readable after being formatted.

```{literalinclude} /sources/language/src/test/top.mbt
:language: moonbit
:start-after: start snapshot test 2
:end-before: end snapshot test 2
```

One can also implement a custom `ToJson` to keep only the essential information.

### Snapshotting Anything

Still, sometimes we want to not only record one data structure but the output of a whole process.

A full snapshot test can be used to record anything using `@test.T::write` and `@test.T::writeln`:

```{literalinclude} /sources/language/src/test/top.mbt
:language: moonbit
:start-after: start snapshot test 3
:end-before: end snapshot test 3
```

This will create a file under `__snapshot__` of that package with the given filename:

```{literalinclude} /sources/language/src/test/__snapshot__/record_anything.txt
```

This can also be used for applications to test the generated output, whether it were creating an image, a video or some custom data.

## BlackBox Tests and WhiteBox Tests

When developing libraries, it is important to verify if the user can use it correctly. For example, one may forget to make a type or a function public. That's why MoonBit provides BlackBox tests, allowing developers to have a grasp of how others are feeling.

- A test that has access to all the members in a package is called a WhiteBox tests as we can see everything. Such tests can be defined inline or defined in a file whose name ends with `_wbtest.mbt`.

- A test that has access only to the public members in a package is called a BlackBox tests. Such tests need to be defined in a file whose name ends with `_test.mbt`.

The WhiteBox test files (`_wbtest.mbt`) imports the packages defined in the `import` and `wbtest-import` sections of the package configuration (`moon.pkg.json`).

The BlackBox test files (`_test.mbt`) imports the current package and the packages defined in the `import` and `test-import` sections of the package configuration (`moon.pkg.json`).

================================================
File 473: /data/input/moonbit-docs/next/sources/async/src/async.mbt
================================================
// start async function declaration
async fn my_async_function() -> Unit {
  ...
}

// anonymous/local function
test {
  let async_lambda = async fn () {
    ...
  }
  async fn local_async_function() {
    ...
  }
}
// end async function declaration

// start async function call syntax
async fn some_async_function() -> Unit! {
  ...
}

async fn another_async_function() -> Unit! {
  // error will be rethrowed by `!!`
  some_async_function!!()
}
// end async function call syntax

// start async primitive

// `run_async` spawn a new coroutine and execute an async function in it
fn run_async(f : async () -> Unit) -> Unit = "%async.run"

// `suspend` will suspend the execution of the current coroutine.
// The suspension will be handled by a callback passed to `suspend`
async fn suspend[T, E : Error](
  // `f` is a callback for handling suspension
  f : (
    // the first parameter of `f` is used to resume the execution of the coroutine normally
    (T) -> Unit,
    // the second parameter of `f` is used to cancel the execution of the current coroutine
    // by throwing an error at suspension point
    (E) -> Unit
  ) -> Unit
) -> T!E = "%async.suspend"
// end async primitive

// start async example
type! MyError derive(Show)

async fn async_worker(throw_error~ : Bool) -> Unit!MyError {
  suspend!!(fn (resume_ok, resume_err) {
    if throw_error {
      resume_err(MyError)
    } else {
      resume_ok(())
      println("the end of the coroutine")
    }
  })
}

// the program below should print:
//
//   the worker finishes
//   the end of the coroutine
//   after the first coroutine finishes
//   caught MyError
test {
  // when supplying an anonymous function
  // to a higher order function that expects async parameter,
  // the `async` keyword can be omitted
  run_async(fn () {
    try {
      async_worker!!(throw_error=false)
      println("the worker finishes")
    } catch {
      err => println("caught: \{err}")
    }
  })
  println("after the first coroutine finishes")
  run_async(fn () {
    try {
      async_worker!!(throw_error=true)
      println("the worker finishes")
    } catch {
      err => println("caught: \{err}")
    }
  })
}
// end async example

// start async timer example
extern type JSTimer
extern "js" fn js_set_timeout(f : () -> Unit, duration : Int) -> JSTimer =
  #| (f, duration) => setTimeout(f, duration)

async fn sleep(duration : Int) -> Unit! {
  suspend!!(fn (resume_ok, _resume_err) {
    let _ = js_set_timeout(fn () { resume_ok(()) }, duration)
  })
}

test {
  run_async(fn () {
    try {
      sleep!!(500)
      println("timer 1 tick")
      sleep!!(1000)
      println("timer 1 tick")
      sleep!!(1500)
      println("timer 1 tick")
    } catch { _ => panic() }
  })
  run_async(fn () {
    try {
      sleep!!(600)
      println("timer 2 tick")
      sleep!!(600)
      println("timer 2 tick")
      sleep!!(600)
      println("timer 2 tick")
    } catch { _ => panic() }
  })
}
// end async timer example


================================================
File 474: /data/input/moonbit-docs/next/sources/diff/README.md
================================================
# moonbit-community/diff

================================================
File 475: /data/input/moonbit-docs/next/sources/diff/src/part1/bparray.mbt
================================================
// start bparray definition
type BPArray[T] Array[T] // BiPolar Array 

fn BPArray::make[T](capacity : Int, default : T) -> BPArray[T] {
  let arr = Array::make(capacity, default)
  BPArray(arr)
}

fn copy(self : BPArray[Int]) -> BPArray[Int] {
  let BPArray(arr) = self
  let newarr = Array::make(arr.length(), 0)
  for i = 0; i < arr.length(); i = i + 1 {
    newarr[i] = arr[i]
  } else {
    BPArray(newarr)
  }
}

fn op_get[T](self : BPArray[T], idx : Int) -> T {
  let BPArray(arr) = self
  if idx < 0 {
    arr[arr.length() + idx]
  } else {
    arr[idx]
  }
}

fn op_set[T](self : BPArray[T], idx : Int, elem : T) -> Unit {
  let BPArray(arr) = self
  if idx < 0 {
    arr[arr.length() + idx] = elem
  } else {
    arr[idx] = elem
  }
}
// end bparray definition

test "bparray" {
  let foo = BPArray::make(10, "foo")
  foo[9] = "bar"
  foo[8] = "baz"
  assert_eq!(foo[-1], "bar")
  assert_eq!(foo[-2], "baz")
}

================================================
File 476: /data/input/moonbit-docs/next/sources/diff/src/part1/diff.mbt
================================================
// start shortest_edit definition
fn shortest_edit(old~ : Array[Line], new~ : Array[Line]) -> Int {
  let n = old.length()
  let m = new.length()
  let max = n + m
  let v = BPArray::make(2 * max + 1, 0)
  // v[1] = 0
  for d = 0; d < max + 1; d = d + 1 {
    for k = -d; k < d + 1; k = k + 2 {
      let mut x = 0
      let mut y = 0
      // if d == 0 {
      //   x = 0
      // }
      if k == -d || (k != d && v[k - 1] < v[k + 1]) {
        x = v[k + 1]
      } else {
        x = v[k - 1] + 1
      }
      y = x - k
      while x < n && y < m && old[x].text == new[y].text {
        // Skip all matching lines
        x = x + 1
        y = y + 1
      }
      v[k] = x
      if x >= n && y >= m {
        return d
      }
    }
  } else {
    abort("impossible")
  }
}
// end shortest_edit definition

test "shortest_edit" {
  let old = lines("aaa\naaa\naaa")
  let new = lines("bbb\nbbb\nbbb")
  inspect!(shortest_edit(old~, new~), content = "6")
  let old = lines("A\nB\nC\nA\nB\nB\nA")
  let new = lines("C\nB\nA\nB\nA\nC")
  inspect!(shortest_edit(old~, new~), content = "5")
}

================================================
File 477: /data/input/moonbit-docs/next/sources/diff/src/part1/line.mbt
================================================
// start line definition
///|
struct Line {
  number : Int // Line number
  text : String // Does not include newline
} derive(Show)

///|
fn Line::new(number : Int, text : String) -> Line {
  Line::{ number, text }
}
// end line definition

// start lines definition
fn lines(str : String) -> Array[Line] {
  let lines = Array::new(capacity=50)
  let mut line_number = 0
  for line in str.split("\n") {
    line_number = line_number + 1
    lines.push(Line::new(line_number, line))
  } else {
    return lines
  }
}
// end lines definition

test "lines" {
  inspect!(lines(""), content="[]")
  inspect!(
    lines("\n"),
    content=
      #|[{number: 1, text: ""}]
    ,
  )
  inspect!(
    lines("aaa"),
    content=
      #|[{number: 1, text: "aaa"}]
    ,
  )
  inspect!(
    lines("aaa\nbbb"),
    content=
      #|[{number: 1, text: "aaa"}, {number: 2, text: "bbb"}]
    ,
  )
}


================================================
File 478: /data/input/moonbit-docs/next/sources/diff/src/part2/bparray.mbt
================================================
type BPArray[T] Array[T] // BiPolar Array 
  

fn BPArray::make[T](capacity : Int, default : T) -> BPArray[T] {
  let arr = Array::make(capacity, default)
  BPArray(arr)
}

fn copy(self : BPArray[Int]) -> BPArray[Int] {
  let BPArray(arr) = self
  let newarr = Array::make(arr.length(), 0)
  for i = 0; i < arr.length(); i = i + 1 {
    newarr[i] = arr[i]
  } else {
    BPArray(newarr)
  }
}

fn op_get[T](self : BPArray[T], idx : Int) -> T {
  let BPArray(arr) = self
  if idx < 0 {
    arr[arr.length() + idx]
  } else {
    arr[idx]
  }
}

fn op_set[T](self : BPArray[T], idx : Int, elem : T) -> Unit {
  let BPArray(arr) = self
  if idx < 0 {
    arr[arr.length() + idx] = elem
  } else {
    arr[idx] = elem
  }
}

test "bparray" {
  let foo = BPArray::make(10, "foo")
  foo[9] = "bar"
  foo[8] = "baz"
  assert_eq!(foo[-1], "bar")
  assert_eq!(foo[-2], "baz")
}

================================================
File 479: /data/input/moonbit-docs/next/sources/diff/src/part2/diff.mbt
================================================

// start shortest_edit definition
fn shortest_edit(
  old~ : Array[Line],
  new~ : Array[Line]
) -> Array[(BPArray[Int], Int)] {
  let n = old.length()
  let m = new.length()
  let max = n + m
  let v = BPArray::make(2 * max + 1, 0)
  let trace = []
  fn push(v : BPArray[Int], d : Int) -> Unit {
    trace.push((v, d))
  }
  // v[1] = 0
  for d = 0; d < max + 1; d = d + 1 {
    push(v.copy(), d) 
    for k = -d; k < d + 1; k = k + 2 {
      let mut x = 0
      let mut y = 0
      // if d == 0 {
      //   x = 0
      // }
      if k == -d || (k != d && v[k - 1] < v[k + 1]) {
        x = v[k + 1]
      } else {
        x = v[k - 1] + 1
      }
      y = x - k
      while x < n && y < m && old[x].text == new[y].text {
        x = x + 1
        y = y + 1
      }
      v[k] = x
      if x >= n && y >= m {
        return trace
      }
    }
  } else {
    abort("impossible")
  }
}
// end shortest_edit definition


// start backtrack_fst definition
fn backtrack(
  new~ : Array[Line],
  old~ : Array[Line],
  trace : Array[(BPArray[Int], Int)]
) -> Array[Edit] {
  let mut x = old.length()
  let mut y = new.length()
  let edits = Array::new(capacity=trace.length())
  // end backtrack_fst definition
  // start backtrack_snd definition
  for i = trace.length() - 1; i >= 0; i = i - 1 {
    let (v, d) = trace[i]
    let k = x - y
    let prev_k = if k == -d || (k != d && v[k - 1] < v[k + 1]) {
      k + 1
    } else {
      k - 1
    }
    let prev_x = v[prev_k]
    let prev_y = prev_x - prev_k
    while x > prev_x && y > prev_y {
      x = x - 1
      y = y - 1
      edits.push(Equal(old=old[x], new=new[y]))
    }
    if d > 0 {
      if x == prev_x {
        edits.push(Insert(new=new[prev_y]))
      } else if y == prev_y {
        edits.push(Delete(old=old[prev_x]))
      }
      x = prev_x
      y = prev_y
    }
  }
  // end backtrack_snd definition
  return edits
}

// start diff definition
fn diff(old~ : Array[Line], new~ : Array[Line]) -> Array[Edit] {
  let trace = shortest_edit(old~, new~)
  backtrack(old~, new~, trace)
}
// end diff definition

test "myers diff" {
  let old = lines("A\nB\nC\nA\nB\nB\nA")
  let new = lines("C\nB\nA\nB\nA\nC")
  inspect!(
    pprint_diff(diff(old~, new~)),
    content=
      #|-    1         A
      #|-    2         B
      #|     3    1    C
      #|+         2    B
      #|     4    3    A
      #|     5    4    B
      #|-    6         B
      #|     7    5    A
      #|+         6    C
      #|
    ,
  )
}


================================================
File 480: /data/input/moonbit-docs/next/sources/diff/src/part2/edit.mbt
================================================
// start edit definition
enum Edit {
  Insert(new~ : Line)
  Delete(old~ : Line)
  Equal(old~ : Line, new~ : Line) // old, new
} derive(Show)
// end edit definition


// start pprint definition
let line_width = 4

fn pad_right(s : String, width : Int) -> String {
  String::make(width - s.length(), ' ') + s
}

fn pprint_edit(edit : Edit) -> String {
  match edit {
    Insert(_) as edit => {
      let tag = "+"
      let old_line = pad_right("", line_width)
      let new_line = pad_right(edit.new.number.to_string(), line_width)
      let text = edit.new.text
      "\{tag} \{old_line} \{new_line}    \{text}"
    }
    Delete(_) as edit => {
      let tag = "-"
      let old_line = pad_right(edit.old.number.to_string(), line_width)
      let new_line = pad_right("", line_width)
      let text = edit.old.text
      "\{tag} \{old_line} \{new_line}    \{text}"
    }
    Equal(_) as edit => {
      let tag = " "
      let old_line = pad_right(edit.old.number.to_string(), line_width)
      let new_line = pad_right(edit.new.number.to_string(), line_width)
      let text = edit.old.text
      "\{tag} \{old_line} \{new_line}    \{text}"
    }
  }
}

fn pprint_diff(diff : Array[Edit]) -> String {
  let buf = @buffer.new(size_hint = 100)
  for i = diff.length(); i > 0; i = i - 1 {
    buf.write_string(pprint_edit(diff[i - 1]))
    buf.write_char('\n')
  } else {
    buf.contents().to_unchecked_string()
  }
}
// end pprint definition

================================================
File 481: /data/input/moonbit-docs/next/sources/diff/src/part2/line.mbt
================================================
///|
struct Line {
  number : Int // Line number
  text : String // Does not include newline
} derive(Show)

///|
fn Line::new(number : Int, text : String) -> Line {
  Line::{ number, text }
}

///|
fn lines(str : String) -> Array[Line] {
  let lines = Array::new(capacity=50)
  let mut line_number = 0
  for line in str.split("\n") {
    line_number = line_number + 1
    lines.push(Line::new(line_number, line))
  } else {
    return lines
  }
}

test "lines" {
  inspect!(lines(""), content="[]")
  inspect!(
    lines("\n"),
    content=
      #|[{number: 1, text: ""}]
    ,
  )
  inspect!(
    lines("aaa"),
    content=
      #|[{number: 1, text: "aaa"}]
    ,
  )
  inspect!(
    lines("aaa\nbbb"),
    content=
      #|[{number: 1, text: "aaa"}, {number: 2, text: "bbb"}]
    ,
  )
}


================================================
File 482: /data/input/moonbit-docs/next/sources/diff/src/part3/bparray.mbt
================================================
type BPArray[T] Array[T] // BiPolar Array 
  

fn BPArray::make[T](capacity : Int, default : T) -> BPArray[T] {
  let arr = Array::make(capacity, default)
  BPArray(arr)
}

fn copy(self : BPArray[Int]) -> BPArray[Int] {
  let BPArray(arr) = self
  let newarr = Array::make(arr.length(), 0)
  for i = 0; i < arr.length(); i = i + 1 {
    newarr[i] = arr[i]
  } else {
    BPArray(newarr)
  }
}

fn op_get[T](self : BPArray[T], idx : Int) -> T {
  let BPArray(arr) = self
  if idx < 0 {
    arr[arr.length() + idx]
  } else {
    arr[idx]
  }
}

fn op_set[T](self : BPArray[T], idx : Int, elem : T) -> Unit {
  let BPArray(arr) = self
  if idx < 0 {
    arr[arr.length() + idx] = elem
  } else {
    arr[idx] = elem
  }
}

test "bparray" {
  let foo = BPArray::make(10, "foo")
  foo[9] = "bar"
  foo[8] = "baz"
  assert_eq!(foo[-1], "bar")
  assert_eq!(foo[-2], "baz")
}

================================================
File 483: /data/input/moonbit-docs/next/sources/diff/src/part3/diff.mbt
================================================
// start box definition
struct Box {
  left : Int
  right : Int
  top : Int
  bottom : Int
} derive(Show)

struct Snake {
  start : (Int, Int)
  end : (Int, Int)
} derive(Show)

fn width(self : Box) -> Int {
  self.right - self.left
}

fn height(self : Box) -> Int {
  self.bottom - self.top
}

fn size(self : Box) -> Int {
  self.width() + self.height()
}

fn delta(self : Box) -> Int {
  self.width() - self.height()
}
// end box definition
fn is_odd(n : Int) -> Bool {
  (n & 1) == 1
}

fn is_even(n : Int) -> Bool {
  (n & 1) == 0
}

// start search definition
fn forward(
  self : Box,
  forward~ : BPArray[Int],
  backward~ : BPArray[Int],
  depth : Int,
  old~ : Array[Line],
  new~ : Array[Line]
) -> Snake? {
  for k = depth; k >= -depth; k = k - 2 {
    let c = k - self.delta()
    let mut x = 0
    let mut px = 0
    if k == -depth || (k != depth && forward[k - 1] < forward[k + 1]) {
      x = forward[k + 1]
      px = x
    } else {
      px = forward[k - 1]
      x = px + 1
    }
    let mut y = self.top + (x - self.left) - k
    let py = if depth == 0 || x != px { y } else { y - 1 }
    while x < self.right && y < self.bottom && old[x].text == new[y].text {
      x = x + 1
      y = y + 1
    }
    forward[k] = x
    if is_odd(self.delta()) &&
      (c >= -(depth - 1) && c <= depth - 1) &&
      y >= backward[c] {
      return Some(Snake::{ start: (px, py), end: (x, y) })
    }
  }
  return None
}


fn backward(
  self : Box,
  forward~ : BPArray[Int],
  backward~ : BPArray[Int],
  depth : Int,
  old~ : Array[Line],
  new~ : Array[Line]
) -> Snake? {
  for c = depth; c >= -depth; c = c - 2 {
    let k = c + self.delta()
    let mut y = 0
    let mut py = 0
    if c == -depth || (c != depth && backward[c - 1] > backward[c + 1]) {
      y = backward[c + 1]
      py = y
    } else {
      py = backward[c - 1]
      y = py - 1
    }
    let mut x = self.left + (y - self.top) + k
    let px = if depth == 0 || y != py { x } else { x + 1 }
    while x > self.left && y > self.top && old[x - 1].text == new[y - 1].text {
      x = x - 1
      y = y - 1
    }
    backward[c] = y
    if is_even(self.delta()) && (k >= -depth && k <= depth) && x <= forward[k] {
      return Some(Snake::{ start: (x, y), end: (px, py) })
    }
  }
  return None
}
// end search definition

// start midpoint definition
fn midpoint(self : Box, old~ : Array[Line], new~ : Array[Line]) -> Snake? {
  if self.size() == 0 {
    return None
  }
  let max = {
    let half = self.size() / 2
    if is_odd(self.size()) {
      half + 1
    } else {
      half
    }
  }
  let vf = BPArray::make(2 * max + 1, 0)
  vf[1] = self.left
  let vb = BPArray::make(2 * max + 1, 0)
  vb[1] = self.bottom
  for d = 0; d < max + 1; d = d + 1 {
    match self.forward(forward = vf, backward = vb, d, old~, new~) {
      None =>
        match self.backward(forward = vf, backward = vb, d, old~, new~) {
          None => continue
          res => return res
        }
      res => return res
    }
  } else {
    None
  }
}
// end midpoint definition

// start findpath definition
fn find_path(
  box : Box,
  old~ : Array[Line],
  new~ : Array[Line]
) -> Iter[(Int, Int)]? {
  guard midpoint(box, old~, new~) is Some(snake) else { None }
  let start = snake.start
  let end = snake.end
  let headbox = Box::{
    left: box.left,
    top: box.top,
    right: start.0,
    bottom: start.1,
  }
  let tailbox = Box::{
    left: end.0,
    top: end.1,
    right: box.right,
    bottom: box.bottom,
  }
  let head = find_path(headbox, old~, new~).or(Iter::singleton(start))
  let tail = find_path(tailbox, old~, new~).or(Iter::singleton(end))
  Some(head.concat(tail))
}
// end findpath definition


fn linear_diff(old~ : Array[Line], new~ : Array[Line]) -> Array[Edit]? {
  let initial_box = Box::{
    left: 0,
    top: 0,
    right: old.length(),
    bottom: new.length(),
  }
  guard find_path(initial_box, old~, new~) is Some(path) else { None }
  // path length >= 2
  let xy = path.take(1).collect()[0] // (0, 0)
  let mut x1 = xy.0
  let mut y1 = xy.1
  let edits = Array::new(capacity=old.length() + new.length())
  path
  .drop(1)
  .each(
    fn(xy) {
      let x2 = xy.0
      let y2 = xy.1
      while x1 < x2 && y1 < y2 && old[x1].text == new[y1].text {
        edits.push(Equal(old=old[x1], new=new[y1]))
        x1 = x1 + 1
        y1 = y1 + 1
      }
      if x2 - x1 < y2 - y1 {
        edits.push(Insert(new=new[y1]))
        y1 += 1
      }
      if x2 - x1 > y2 - y1 {
        edits.push(Delete(old=old[x1]))
        x1 += 1
      }
      while x1 < x2 && y1 < y2 && old[x1].text == new[y1].text {
        edits.push(Equal(old=old[x1], new=new[y1]))
        x1 = x1 + 1
        y1 = y1 + 1
      }
      x1 = x2
      y1 = y2
    },
  )
  return Some(edits)
}

test "myers diff" {
  let old = lines("A\nB\nC\nA\nB\nB\nA")
  let new = lines("C\nB\nA\nB\nA\nC")
  let r = linear_diff(old~, new~).unwrap()
  inspect!(
    pprint_diff(r),
    content=
      #|-    1         A
      #|-    2         B
      #|     3    1    C
      #|-    4         A
      #|     5    2    B
      #|+         3    A
      #|     6    4    B
      #|     7    5    A
      #|+         6    C
      #|
    ,
  )
}


================================================
File 484: /data/input/moonbit-docs/next/sources/diff/src/part3/edit.mbt
================================================
enum Edit {
  Insert(new~ : Line)
  Delete(old~ : Line)
  Equal(old~ : Line, new~ : Line) // old, new
} derive(Show)

// start pprint definition
let line_width = 4

fn pad_right(s : String, width : Int) -> String {
  String::make(width - s.length(), ' ') + s
}

fn pprint_edit(edit : Edit) -> String {
  match edit {
    Insert(_) as edit => {
      let tag = "+"
      let old_line = pad_right("", line_width)
      let new_line = pad_right(edit.new.number.to_string(), line_width)
      let text = edit.new.text
      "\{tag} \{old_line} \{new_line}    \{text}"
    }
    Delete(_) as edit => {
      let tag = "-"
      let old_line = pad_right(edit.old.number.to_string(), line_width)
      let new_line = pad_right("", line_width)
      let text = edit.old.text
      "\{tag} \{old_line} \{new_line}    \{text}"
    }
    Equal(_) as edit => {
      let tag = " "
      let old_line = pad_right(edit.old.number.to_string(), line_width)
      let new_line = pad_right(edit.new.number.to_string(), line_width)
      let text = edit.old.text
      "\{tag} \{old_line} \{new_line}    \{text}"
    }
  }
}

fn pprint_diff(diff : Array[Edit]) -> String {
  let buf = @buffer.new(size_hint = 100)
  for i = 0; i < diff.length(); i = i + 1 {
    buf.write_string(pprint_edit(diff[i]))
    buf.write_char('\n')
  } else {
    buf.contents().to_unchecked_string()
  }
}
// end pprint definition

================================================
File 485: /data/input/moonbit-docs/next/sources/diff/src/part3/line.mbt
================================================
///|
struct Line {
  number : Int // Line number
  text : String // Does not include newline
} derive(Show)

///|
fn Line::new(number : Int, text : String) -> Line {
  Line::{ number, text }
}

///|
fn lines(str : String) -> Array[Line] {
  let lines = Array::new(capacity=50)
  let mut line_number = 0
  for line in str.split("\n") {
    line_number = line_number + 1
    lines.push(Line::new(line_number, line))
  } else {
    return lines
  }
}

test "lines" {
  inspect!(lines(""), content="[]")
  inspect!(
    lines("\n"),
    content=
      #|[{number: 1, text: ""}]
    ,
  )
  inspect!(
    lines("aaa"),
    content=
      #|[{number: 1, text: "aaa"}]
    ,
  )
  inspect!(
    lines("aaa\nbbb"),
    content=
      #|[{number: 1, text: "aaa"}, {number: 2, text: "bbb"}]
    ,
  )
}


================================================
File 486: /data/input/moonbit-docs/next/sources/gmachine/README.md
================================================
# G-Machine

================================================
File 487: /data/input/moonbit-docs/next/sources/gmachine/src/part1/ast.mbt
================================================
typealias List[E] = @immut/list.T[E]

// start expr_and_scdef definition
enum RawExpr[T] {
  Var(T)
  Num(Int)
  Constructor(tag~:Int, arity~:Int) // tag, arity
  App(RawExpr[T], RawExpr[T])
  Let(Bool, List[(T, RawExpr[T])], RawExpr[T]) // isRec, Defs, Body
  Case(RawExpr[T], List[(Int, List[T], RawExpr[T])])
} derive(Show)

struct ScDef[T] {
  name : String
  args : List[T]
  body : RawExpr[T]
} derive(Show)
// end expr_and_scdef definition

fn is_atom[T](self : RawExpr[T]) -> Bool {
  match self {
    Var(_) => true
    Num(_) => true
    _ => false
  }
}

fn ScDef::new[T](
  name : String,
  args : List[T],
  body : RawExpr[T]
) -> ScDef[T] {
  { name : name, args : args, body : body }
}

// start prelude_defs definition
let prelude_defs : List[ScDef[String]] = {
  let args : (FixedArray[String]) -> List[String] = @immut/list.of
  let id = ScDef::new("I", args(["x"]), Var("x")) // id x = x
  let k = 
    ScDef::new(
      "K",
      args(["x", "y"]),
      Var("x")
    ) // K x y = x
  let k1 = 
    ScDef::new(
      "K1",
      args(["x", "y"]),
      Var("y")
    ) // K1 x y = y
  let s = 
    ScDef::new(
      "S",
      args(["f", "g", "x"]),
      App(App(Var("f"), Var("x")), App(Var("g"), Var("x")))
    ) // S f g x = f x (g x)
  let compose = 
    ScDef::new(
      "compose",
      args(["f", "g", "x"]),
      App(Var("f"), App(Var("g"), Var("x")))
    ) // compose f g x = f (g x)
  let twice = 
    ScDef::new(
      "twice",
      args(["f"]),
      App(App(Var("compose"), Var("f")), Var("f"))
    ) // twice f = compose f f
  @immut/list.of([id, k, k1, s, compose, twice])
}
// end prelude_defs definition

================================================
File 488: /data/input/moonbit-docs/next/sources/gmachine/src/part1/compile.mbt
================================================
// start compile_sc definition
fn compileSC(self : ScDef[String]) -> (String, Int, List[Instruction]) {
  let name = self.name
  let body = self.body
  let mut arity = 0
  fn gen_env(i : Int, args : List[String]) -> List[(String, Int)] {
    match args {
      Nil => {
        arity = i
        return Nil
      }
      Cons(s, ss) => Cons((s, i), gen_env(i + 1, ss))
    }
  }

  let env = gen_env(0, self.args)
  (name, arity, compileR(body, env, arity))
}
// end compile_sc definition

// start compile_r definition
fn compileR(
  self : RawExpr[String],
  env : List[(String, Int)],
  arity : Int
) -> List[Instruction] {
  if arity == 0 {
    compileC(self, env) + @immut/list.of([Update(arity), Unwind])
  } else {
    compileC(self, env) + @immut/list.of([Update(arity), Pop(arity), Unwind])
  }
}
// end compile_r definition

// start compile_c definition
fn compileC(
  self : RawExpr[String],
  env : List[(String, Int)]
) -> List[Instruction] {
  match self {
    Var(s) =>
      match env.lookup(s) {
        None => @immut/list.of([PushGlobal(s)])
        Some(n) => @immut/list.of([PushArg(n)])
      }
    Num(n) => @immut/list.of([PushInt(n)])
    App(e1, e2) =>
      compileC(e2, env) + compileC(e1, argOffset(1, env)) + @immut/list.of([MkApp])
    _ => abort("not support yet")
  }
}
// end compile_c definition

fn argOffset(n : Int, env : List[(String, Int)]) -> List[(String, Int)] {
  env.map(fn { (name, offset) => (name, offset + n) })
}


================================================
File 489: /data/input/moonbit-docs/next/sources/gmachine/src/part1/instruction.mbt
================================================
// start instr definition
enum Instruction {
  Unwind
  PushGlobal(String)
  PushInt(Int)
  PushArg(Int)
  MkApp
  Update(Int)
  Pop(Int)
} derive (Eq, Show)
// end instr definition

================================================
File 490: /data/input/moonbit-docs/next/sources/gmachine/src/part1/lazy.mbt
================================================
// start lazy definition
enum LazyData[T] {
  Waiting(() -> T)
  Done(T)
}

struct LazyRef[T] {
  mut data : LazyData[T]
}

fn extract[T](self : LazyRef[T]) -> T {
  match self.data {
    Waiting(thunk) => {
      let value = thunk()
      self.data = Done(value) // in-place update
      value
    }
    Done(value) => value
  }
}

fn square(x : LazyRef[Int]) -> Int {
  x.extract() * x.extract()
}
// end lazy definition

================================================
File 491: /data/input/moonbit-docs/next/sources/gmachine/src/part1/programs.mbt
================================================
let programs : @hashmap.T[String, String] = {
  let programs = @hashmap.new(capacity=40)
  programs["square"] =
    #| (defn square[x] (mul x x))
  programs["fix"] =
    #| (defn fix[f] (letrec ([x (f x)]) x))
  programs["isNil"] =
    #| (defn isNil[x]
    #|   (case x [(Nil) 1] [(Cons n m) 0]))
  programs["tail"] =
    #| (defn tail[l] (case l [(Cons x xs) xs]))
  programs["fibs"] =
    // fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
    #| (defn fibs[] (Cons 0 (Cons 1 (zipWith add fibs (tail fibs)))))
  programs["take"] =
    #| (defn take[n l]
    #|   (case l
    #|     [(Nil) Nil]
    #|     [(Cons x xs)
    #|        (if (le n 0) Nil (Cons x (take (sub n 1) xs)))]))
  programs["zipWith"] =
    #| (defn zipWith[op l1 l2]
    #|   (case l1
    #|     [(Nil) Nil]
    #|     [(Cons x xs)
    #|       (case l2
    #|         [(Nil) Nil]
    #|         [(Cons y ys) (Cons (op x y) (zipWith op xs ys))])]))
  programs["factorial"] =
    #| (defn factorial[n]
    #|   (if (eq n 0) 1 (mul n (factorial (sub n 1)))))
  programs["abs"] =
    #| (defn abs[n]
    #|   (if (lt n 0) (negate n) n))
  programs["length"] =
    #| (defn length[l]
    #|   (case l
    #|     [(Nil) 0]
    #|     [(Cons x xs) (add 1 (length xs))]))
  programs
}


================================================
File 492: /data/input/moonbit-docs/next/sources/gmachine/src/part1/syntax.mbt
================================================
enum Token {
  DefFn
  Let
  NIL
  CONS
  Case
  Letrec
  Open(Char) // { [ (
  Close(Char) // } ] )
  Id(String)
  Number(Int)
  EOF
} derive(Eq, Show)

fn between(this : Char, lw : Char, up : Char) -> Bool {
  this >= lw && this <= up
}

fn isDigit(this : Char) -> Bool {
  between(this, '0', '9')
}

fn isAlpha(this : Char) -> Bool {
  between(this, 'A', 'Z') || between(this, 'a', 'z')
}

fn isIdChar(this : Char) -> Bool {
  isAlpha(this) || isDigit(this) || this == '_' || this == '-'
}

fn isWhiteSpace(this : Char) -> Bool {
  this == ' ' || this == '\t' || this == '\n'
}

fn to_number(this : Char) -> Int {
  this.to_int() - 48
}

fn isOpen(this : Char) -> Bool {
  this == '(' || this == '[' || this == '{'
}

fn isClose(this : Char) -> Bool {
  this == ')' || this == ']' || this == '}'
}

struct Tokens {
  tokens : Array[Token]
  mut current : Int
} derive(Show)

fn Tokens::new(tokens : Array[Token]) -> Tokens {
  Tokens::{ tokens, current: 0 }
}

fn peek(self : Tokens) -> Token {
  if self.current < self.tokens.length() {
    return self.tokens[self.current]
  } else {
    return EOF
  }
}

type! ParseError String

fn next(self : Tokens, loc~ : SourceLoc = _) -> Unit {
  self.current = self.current + 1
  if self.current > self.tokens.length() {
    abort("Tokens::next(): \{loc}")
  }
}

fn eat(self : Tokens, tok : Token, loc~ : SourceLoc = _) -> Unit!ParseError {
  let __tok = self.peek()
  // assert tok_ != EOF
  if __tok != tok {
    raise ParseError("\{loc} - Tokens::eat(): expect \{tok} but got \{__tok}")
  } else {
    self.next()
  }
}

fn tokenize(source : String) -> Tokens {
  let tokens : Array[Token] = Array::new(capacity=source.length() / 2)
  let mut current = 0
  let source = source.to_array()
  fn peek() -> Char {
    source[current]
  }

  fn next() -> Unit {
    current = current + 1
  }

  while current < source.length() {
    let ch = peek()
    if isWhiteSpace(ch) {
      next()
      continue
    } else if isDigit(ch) {
      let mut num = to_number(ch)
      next()
      while current < source.length() && isDigit(peek()) {
        num = num * 10 + to_number(peek())
        next()
      }
      tokens.push(Number(num))
      continue
    } else if isOpen(ch) {
      next()
      tokens.push(Open(ch))
      continue
    } else if isClose(ch) {
      next()
      tokens.push(Close(ch))
      continue
    } else if isAlpha(ch) {
      let identifier = @buffer.new(size_hint=42)
      identifier.write_char(ch)
      next()
      while current < source.length() && isIdChar(peek()) {
        identifier.write_char(peek())
        next()
      }
      let identifier = identifier.contents().to_unchecked_string()
      match identifier {
        "let" => tokens.push(Let)
        "letrec" => tokens.push(Letrec)
        "Nil" => tokens.push(NIL)
        "Cons" => tokens.push(CONS)
        "case" => tokens.push(Case)
        "defn" => tokens.push(DefFn)
        _ => tokens.push(Id(identifier))
      }
    } else {
      abort("error : invalid Character '\{ch}' in [\{current}]")
    }
  } else {
    return Tokens::new(tokens)
  }
}

test "tokenize" {
  inspect!(tokenize("").tokens, content="[]")
  inspect!(tokenize("12345678").tokens, content="[Number(12345678)]")
  inspect!(tokenize("1234 5678").tokens, content="[Number(1234), Number(5678)]")
  inspect!(
    tokenize("a0 a_0 a-0").tokens,
    content=
      #|[Id("a0"), Id("a_0"), Id("a-0")]
    ,
  )
  inspect!(
    tokenize("(Cons 0 (Cons 1 Nil))").tokens,
    content="[Open('('), CONS, Number(0), Open('('), CONS, Number(1), NIL, Close(')'), Close(')')]",
  )
}

fn parse_num(self : Tokens) -> Int!ParseError {
  match self.peek() {
    Number(n) => {
      self.next()
      return n
    }
    other => raise ParseError("parse_num(): expect a number but got \{other}")
  }
}

fn parse_var(self : Tokens) -> String!ParseError {
  match self.peek() {
    Id(s) => {
      self.next()
      return s
    }
    other => raise ParseError("parse_var(): expect a variable but got \{other}")
  }
}

fn parse_cons(self : Tokens) -> RawExpr[String]!ParseError {
  match self.peek() {
    CONS => {
      self.next()
      let x = self.parse_expr!()
      let xs = self.parse_expr!()
      return App(App(Constructor(tag=1, arity=2), x), xs)
    }
    other => raise ParseError("parse_cons(): expect Cons but got \{other}")
  }
}

fn parse_let(self : Tokens) -> RawExpr[String]!ParseError {
  self.eat!(Let)
  self.eat!(Open('('))
  let defs = self.parse_defs!()
  self.eat!(Close(')'))
  let exp = self.parse_expr!()
  Let(false, defs, exp)
}

fn parse_letrec(self : Tokens) -> RawExpr[String]!ParseError {
  self.eat!(Letrec)
  self.eat!(Open('('))
  let defs = self.parse_defs!()
  self.eat!(Close(')'))
  let exp = self.parse_expr!()
  Let(true, defs, exp)
}

fn parse_case(self : Tokens) -> RawExpr[String]!ParseError {
  self.eat!(Case)
  let exp = self.parse_expr!()
  let alts = self.parse_alts!()
  Case(exp, alts)
}

fn parse_alts(
  self : Tokens
) -> List[(Int, List[String], RawExpr[String])]!ParseError {
  let acc : List[(Int, List[String], RawExpr[String])] = Nil
  loop self.peek(), acc {
    Open('['), acc => {
      self.next()
      self.eat!(Open('('))
      let (tag, variables) = match self.peek() {
        NIL => {
          self.next()
          (0, List::Nil)
        }
        CONS => {
          self.next()
          let x = self.parse_var!()
          let xs = self.parse_var!()
          (1, @immut/list.of([x, xs]))
        }
        other =>
          raise ParseError("parse_alts(): expect NIL or CONS but got \{other}")
      }
      self.eat!(Close(')'))
      let exp = self.parse_expr!()
      let alt = (tag, variables, exp)
      self.eat!(Close(']'))
      continue self.peek(), Cons(alt, acc)
    }
    _, acc => acc.rev()
  }
}

fn parse_defs(self : Tokens) -> List[(String, RawExpr[String])]!ParseError {
  let acc : List[(String, RawExpr[String])] = Nil
  loop self.peek(), acc {
    Open('['), acc => {
      self.next()
      let var = self.parse_var!()
      let value = self.parse_expr!()
      self.eat!(Close(']'))
      continue self.peek(), Cons((var, value), acc)
    }
    _, acc => acc.rev()
  }
}

fn parse_apply(self : Tokens) -> RawExpr[String]!ParseError {
  let mut res = self.parse_expr!()
  while self.peek() != Close(')') {
    res = App(res, self.parse_expr!())
  }
  return res
}

fn parse_expr(self : Tokens) -> RawExpr[String]!ParseError {
  match self.peek() {
    EOF =>
      raise ParseError(
        "parse_expr() : expect a token but got a empty token stream",
      )
    Number(n) => {
      self.next()
      Num(n)
    }
    Id(s) => {
      self.next()
      Var(s)
    }
    NIL => {
      self.next()
      Constructor(tag=0, arity=0)
    }
    Open('(') => {
      self.next()
      let exp = match self.peek() {
        Let => self.parse_let!()
        Letrec => self.parse_letrec!()
        Case => self.parse_case!()
        CONS => self.parse_cons!()
        Id(_) | Open('(') => self.parse_apply!()
        other =>
          raise ParseError("parse_expr(): cant parse \{other} behind a '('")
      }
      self.eat!(Close(')'))
      return exp
    }
    other => raise ParseError("parse_expr(): cant parse \{other}")
  }
}

fn parse_sc(self : Tokens) -> ScDef[String]!ParseError {
  self.eat!(Open('('))
  self.eat!(DefFn)
  let fn_name = self.parse_var!()
  self.eat!(Open('['))
  let args = loop self.peek(), List::Nil {
    tok, acc =>
      if tok != Close(']') {
        let var = self.parse_var!()
        continue self.peek(), Cons(var, acc)
      } else {
        acc.rev()
      }
  }
  self.eat!(Close(']'))
  let body = self.parse_expr!()
  self.eat!(Close(')'))
  ScDef::{ name: fn_name, args, body }
}

test "parse scdef" {
  let test_ = fn!(s) { ignore(tokenize(s).parse_sc!()) }
  for p in programs {
    let (_, p) = p
    test_!(p)
  }
}


================================================
File 493: /data/input/moonbit-docs/next/sources/gmachine/src/part1/top.mbt
================================================
// start run definition
fn run(codes : List[String]) -> Node {
  fn parse_then_compile(code : String) -> (String, Int, List[Instruction]) {
    let tokens = tokenize(code)
    let code = 
      try {
        tokens.parse_sc!()
      } catch {
        ParseError(s) => abort(s)
      } else {
        expr => expr
      }
    let code = compileSC(code)
    return code
  }
  let codes = codes.map(parse_then_compile) + prelude_defs.map(compileSC)
  let (heap, globals) = build_initial_heap(codes)
  let initialState : GState = {
    heap : heap,
    stack : Nil,
    code : @immut/list.of([PushGlobal("main"), Unwind]),
    globals : globals,
    stats : 0
  }
  initialState.reify()
}
// end run definition

test "basic eval" {
  // S K K x => ((K x (K x)) => x
  let main = "(defn main[] (S K K 3))" 
  inspect!(run(@immut/list.of([main])), content = "NNum(3)")
  let main = "(defn main[] (K 0 1))"
  inspect!(run(@immut/list.of([main])), content = "NNum(0)")
  let main = "(defn main[] (K1 0 1))"
  inspect!(run(@immut/list.of([main])), content = "NNum(1)")
  let r = LazyRef::{ data : Waiting(fn (){ 3 + 4 })}
  inspect!(square(r), content = "49")
}

================================================
File 494: /data/input/moonbit-docs/next/sources/gmachine/src/part1/vm.mbt
================================================
// start heap definition
// Use the 'type' keyword to encapsulate an address type.
type Addr Int derive(Eq, Show)

// Describe graph nodes with an enumeration type.
enum Node {
  NNum(Int)
  // The application node
  NApp(Addr, Addr)
  // To store the number of parameters and 
  // the corresponding sequence of instructions for a super combinator
  NGlobal(String, Int, List[Instruction])
  // The Indirection node. The key component of implementing lazy evaluation
  NInd(Addr)
} derive(Eq, Show)

struct GHeap {
  // The heap uses an array, 
  // and the space with None content in the array is available as free memory.
  mut object_count : Int
  memory : Array[Node?]
}

// Allocate heap space for nodes.
fn alloc(self : GHeap, node : Node) -> Addr {
  let heap = self
  fn next(n : Int) -> Int {
    (n + 1) % heap.memory.length()
  }

  fn free(i : Int) -> Bool {
    match heap.memory[i] {
      None => true
      _ => false
    }
  }

  let mut i = heap.object_count
  while not(free(i)) {
    i = next(i)
  }
  heap.memory[i] = Some(node)
  heap.object_count = heap.object_count + 1
  return Addr(i)
}
// end heap definition

fn op_get(self : GHeap, key : Addr) -> Node {
  let Addr(i) = key
  match self.memory[i] {
    Some(node) => node
    None => abort("GHeap::get(): index \{i} was empty")
  }
}

fn op_set(self : GHeap, key : Addr, val : Node) -> Unit {
  self.memory[key._] = Some(val)
}

// start state definition
struct GState {
  mut stack : List[Addr]
  heap : GHeap
  globals : @hashmap.T[String, Addr]
  mut code : List[Instruction]
  mut stats : GStats
}

type GStats Int

fn stat_incr(self : GState) -> Unit {
  self.stats = self.stats._ + 1
}

fn put_stack(self : GState, addr : Addr) -> Unit {
  self.stack = Cons(addr, self.stack)
}

fn put_code(self : GState, instrs : List[Instruction]) -> Unit {
  self.code = instrs + self.code
}

fn pop1(self : GState) -> Addr {
  match self.stack {
    Cons(addr, reststack) => {
      self.stack = reststack
      addr
    }
    Nil => abort("pop1(): stack size smaller than 1")
  }
}

// e1 e2 ..... -> (e1, e2) ......
fn pop2(self : GState) -> (Addr, Addr) {
  match self.stack {
    Cons(addr1, Cons(addr2, reststack)) => {
      self.stack = reststack
      (addr1, addr2)
    }
    _ => abort("pop2(): stack size smaller than 2")
  }
}
// end state definition

// start push_int definition
fn push_int(self : GState, num : Int) -> Unit {
  let addr = self.heap.alloc(NNum(num))
  self.put_stack(addr)
}
// end push_int definition

// start push_global definition
fn push_global(self : GState, name : String) -> Unit {
  let sc = self.globals[name]
  match sc {
    None => abort("push_global(): cant find supercombinator \{name}")
    Some(addr) => self.put_stack(addr)
  }
}
// end push_global definition

// start push_arg definition
fn push_arg(self : GState, offset : Int) -> Unit {
  let appaddr = self.stack.unsafe_nth(offset + 1)
  let arg = match self.heap[appaddr] {
    NApp(_, arg) => arg
    otherwise =>
      abort(
        "pusharg: stack offset \{offset} address \{appaddr} node \{otherwise}",
      )
  }
  self.put_stack(arg)
}
// end push_arg definition

// start mk_apply definition
fn mk_apply(self : GState) -> Unit {
  let (a1, a2) = self.pop2()
  let appaddr = self.heap.alloc(NApp(a1, a2))
  self.put_stack(appaddr)
}
// end mk_apply definition

// start update definition
fn update(self : GState, n : Int) -> Unit {
  let addr = self.pop1()
  let dst = self.stack.unsafe_nth(n)
  self.heap[dst] = NInd(addr)
}
// end update definition

// start unwind definition
fn unwind(self : GState) -> Unit {
  let addr = self.pop1()
  match self.heap[addr] {
    NNum(_) => self.put_stack(addr)
    NApp(a1, _) => {
      self.put_stack(addr)
      self.put_stack(a1)
      self.put_code(Cons(Unwind, Nil))
    }
    NGlobal(_, n, c) =>
      if self.stack.length() < n {
        abort("Unwinding with too few arguments")
      } else {
        self.put_stack(addr)
        self.put_code(c)
      }
    NInd(a) => {
      self.put_stack(a)
      self.put_code(Cons(Unwind, Nil))
    }
  }
}
// end unwind definition

// start build_ih definition
fn build_initial_heap(
  scdefs : List[(String, Int, List[Instruction])]
) -> (GHeap, @hashmap.T[String, Addr]) {
  let heap = { object_count: 0, memory: Array::make(10000, None) }
  let globals = @hashmap.new(capacity=50)
  loop scdefs {
    Nil => ()
    Cons((name, arity, instrs), rest) => {
      let addr = heap.alloc(NGlobal(name, arity, instrs))
      globals[name] = addr
      continue rest
    }
  }
  return (heap, globals)
}
// end build_ih definition

// start step definition
fn step(self : GState) -> Bool {
  match self.code {
    Nil => return false
    Cons(i, rest) => {
      self.code = rest
      self.stat_incr()
      match i {
        PushGlobal(f) => self.push_global(f)
        PushInt(n) => self.push_int(n)
        PushArg(n) => self.push_arg(n)
        MkApp => self.mk_apply()
        Unwind => self.unwind()
        Update(n) => self.update(n)
        Pop(n) => self.stack = self.stack.drop(n)
      }
      return true
    }
  }
}
// end step definition

// start reify definition
fn reify(self : GState) -> Node {
  if self.step() {
    self.reify()
  } else {
    let stack = self.stack
    match stack {
      Cons(addr, Nil) => {
        let res = self.heap[addr]
        return res
      }
      _ => abort("wrong stack \{stack}")
    }
  }
}
// end reify definition


================================================
File 495: /data/input/moonbit-docs/next/sources/gmachine/src/part2/ast.mbt
================================================
typealias List[E] = @immut/list.T[E]


enum RawExpr[T] {
  Var(T)
  Num(Int)
  Constructor(tag~:Int, arity~:Int) // tag, arity
  App(RawExpr[T], RawExpr[T])
  Let(Bool, List[(T, RawExpr[T])], RawExpr[T]) // isRec, Defs, Body
  Case(RawExpr[T], List[(Int, List[T], RawExpr[T])])
} derive(Show)

struct ScDef[T] {
  name : String
  args : List[T]
  body : RawExpr[T]
} derive(Show)

fn is_atom[T](self : RawExpr[T]) -> Bool {
  match self {
    Var(_) => true
    Num(_) => true
    _ => false
  }
}

fn ScDef::new[T](
  name : String,
  args : List[T],
  body : RawExpr[T]
) -> ScDef[T] {
  { name : name, args : args, body : body }
}

let prelude_defs : List[ScDef[String]] = {
  let args : (FixedArray[String]) -> List[String] = @immut/list.of
  let id = ScDef::new("I", args(["x"]), Var("x")) // id x = x
  let k = 
    ScDef::new(
      "K",
      args(["x", "y"]),
      Var("x")
    ) // K x y = x
  let k1 = 
    ScDef::new(
      "K1",
      args(["x", "y"]),
      Var("y")
    ) // K1 x y = y
  let s = 
    ScDef::new(
      "S",
      args(["f", "g", "x"]),
      App(App(Var("f"), Var("x")), App(Var("g"), Var("x")))
    ) // S f g x = f x (g x)
  let compose = 
    ScDef::new(
      "compose",
      args(["f", "g", "x"]),
      App(Var("f"), App(Var("g"), Var("x")))
    ) // compose f g x = f (g x)
  let twice = 
    ScDef::new(
      "twice",
      args(["f"]),
      App(App(Var("compose"), Var("f")), Var("f"))
    ) // twice f = compose f f
  @immut/list.of([id, k, k1, s, compose, twice])
}

================================================
File 496: /data/input/moonbit-docs/next/sources/gmachine/src/part2/compile.mbt
================================================
fn compileSC(self : ScDef[String]) -> (String, Int, List[Instruction]) {
  let name = self.name
  let body = self.body
  let mut arity = 0
  fn gen_env(i : Int, args : List[String]) -> List[(String, Int)] {
    match args {
      Nil => {
        arity = i
        return Nil
      }
      Cons(s, ss) => Cons((s, i), gen_env(i + 1, ss))
    }
  }

  let env = gen_env(0, self.args)
  (name, arity, compileR(body, env, arity))
}


fn compileR(
  self : RawExpr[String],
  env : List[(String, Int)],
  arity : Int
) -> List[Instruction] {
  if arity == 0 {
    compileC(self, env) + @immut/list.of([Update(arity), Unwind])
  } else {
    compileC(self, env) + @immut/list.of([Update(arity), Pop(arity), Unwind])
  }
}

fn compileC(
  self : RawExpr[String],
  env : List[(String, Int)]
) -> List[Instruction] {
  match self {
    Var(s) =>
      match env.lookup(s) {
        None => @immut/list.of([PushGlobal(s)])
        Some(n) => @immut/list.of([Push(n)])
      }
    Num(n) => @immut/list.of([PushInt(n)])
    App(e1, e2) =>
      compileC(e2, env) + compileC(e1, argOffset(1, env)) + @immut/list.of([MkApp])
    Let(rec, defs, e) =>
      if rec {
        compileLetrec(compileC, defs, e, env)
      } else {
        compileLet(compileC, defs, e, env)
      }
    _ => abort("not support yet")
  }
}

fn argOffset(n : Int, env : List[(String, Int)]) -> List[(String, Int)] {
  env.map(fn { (name, offset) => (name, offset + n) })
}

// start compile_let definition
fn compileLet(
  comp : (RawExpr[String], List[(String, Int)]) -> List[Instruction],
  defs : List[(String, RawExpr[String])],
  expr : RawExpr[String],
  env : List[(String, Int)]
) -> List[Instruction] {
  let (env, codes) = loop env, List::Nil, defs {
    env, acc, Nil => (env, acc)
    env, acc, Cons((name, expr), rest) => {
      let code = compileC(expr, env)
      let env = List::Cons((name, 0), argOffset(1, env))
      continue env, acc + code, rest
    }
  }
  codes + comp(expr, env) + @immut/list.of([Slide(defs.length())])
}
// end compile_let definition

// start compile_letrec definition
fn compileLetrec(
  comp : (RawExpr[String], List[(String, Int)]) -> List[Instruction],
  defs : List[(String, RawExpr[String])],
  expr : RawExpr[String],
  env : List[(String, Int)]
) -> List[Instruction] {
  let mut env = env
  loop defs {
    Nil => ()
    Cons((name, _), rest) => {
      env = Cons((name, 0), argOffset(1, env))
      continue rest
    }
  }
  let n = defs.length()
  fn compileDefs(
    defs : List[(String, RawExpr[String])],
    offset : Int
  ) -> List[Instruction] {
    match defs {
      Nil => comp(expr, env) + @immut/list.of([Slide(n)])
      Cons((_, expr), rest) =>
        compileC(expr, env) +
        Cons(Update(offset), compileDefs(rest, offset - 1))
    }
  }

  Cons(Alloc(n), compileDefs(defs, n - 1))
}
// end compile_letrec definition

// start prim definition
let compiled_primitives : List[(String, Int, List[Instruction])] = @immut/list.of(
  [
    // Arith
    (
      "add",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Add, Update(2), Pop(2), Unwind]),
    ),
    (
      "sub",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Sub, Update(2), Pop(2), Unwind]),
    ),
    (
      "mul",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Mul, Update(2), Pop(2), Unwind]),
    ),
    (
      "div",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Div, Update(2), Pop(2), Unwind]),
    ),
    // Compare
    (
      "eq",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Eq, Update(2), Pop(2), Unwind]),
    ),
    (
      "neq",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Ne, Update(2), Pop(2), Unwind]),
    ),
    (
      "ge",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Ge, Update(2), Pop(2), Unwind]),
    ),
    (
      "gt",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Gt, Update(2), Pop(2), Unwind]),
    ),
    (
      "le",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Le, Update(2), Pop(2), Unwind]),
    ),
    (
      "lt",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Lt, Update(2), Pop(2), Unwind]),
    ),
    // MISC
    ("negate", 1, @immut/list.of([Push(0), Eval, Neg, Update(1), Pop(1), Unwind])),
    (
      "if",
      3,
      @immut/list.of(
        [
          Push(0),
          Eval,
          Cond(@immut/list.of([Push(1)]), @immut/list.of([Push(2)])),
          Update(3),
          Pop(3),
          Unwind,
        ],
      ),
    ),
  ],
)
// end prim definition

================================================
File 497: /data/input/moonbit-docs/next/sources/gmachine/src/part2/instruction.mbt
================================================
// start instr definition
enum Instruction {
  Unwind
  PushGlobal(String)
  PushInt(Int)
  Push(Int)
  MkApp
  Slide(Int)
  Update(Int)
  Pop(Int)
  Alloc(Int)
  Eval
  Add
  Sub
  Mul
  Div 
  Neg
  Eq // ==
  Ne // !=
  Lt // <
  Le // <=
  Gt // >
  Ge // >=
  Cond(List[Instruction], List[Instruction])
} derive (Eq, Show)
// end instr definition

================================================
File 498: /data/input/moonbit-docs/next/sources/gmachine/src/part2/programs.mbt
================================================
let programs : @hashmap.T[String, String] = {
  let programs = @hashmap.new(capacity=40)
  programs["square"] =
    #| (defn square[x] (mul x x))
  programs["fix"] =
    #| (defn fix[f] (letrec ([x (f x)]) x))
  programs["isNil"] =
    #| (defn isNil[x]
    #|   (case x [(Nil) 1] [(Cons n m) 0]))
  programs["tail"] =
    #| (defn tail[l] (case l [(Cons x xs) xs]))
  programs["fibs"] =
    // fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
    #| (defn fibs[] (Cons 0 (Cons 1 (zipWith add fibs (tail fibs)))))
  programs["take"] =
    #| (defn take[n l]
    #|   (case l
    #|     [(Nil) Nil]
    #|     [(Cons x xs)
    #|        (if (le n 0) Nil (Cons x (take (sub n 1) xs)))]))
  programs["zipWith"] =
    #| (defn zipWith[op l1 l2]
    #|   (case l1
    #|     [(Nil) Nil]
    #|     [(Cons x xs)
    #|       (case l2
    #|         [(Nil) Nil]
    #|         [(Cons y ys) (Cons (op x y) (zipWith op xs ys))])]))
  programs["factorial"] =
    #| (defn factorial[n]
    #|   (if (eq n 0) 1 (mul n (factorial (sub n 1)))))
  programs["abs"] =
    #| (defn abs[n]
    #|   (if (lt n 0) (negate n) n))
  programs["length"] =
    #| (defn length[l]
    #|   (case l
    #|     [(Nil) 0]
    #|     [(Cons x xs) (add 1 (length xs))]))
  programs
}


================================================
File 499: /data/input/moonbit-docs/next/sources/gmachine/src/part2/syntax.mbt
================================================
enum Token {
  DefFn
  Let
  NIL
  CONS
  Case
  Letrec
  Open(Char) // { [ (
  Close(Char) // } ] )
  Id(String)
  Number(Int)
  EOF
} derive(Eq, Show)

fn between(this : Char, lw : Char, up : Char) -> Bool {
  this >= lw && this <= up
}

fn isDigit(this : Char) -> Bool {
  between(this, '0', '9')
}

fn isAlpha(this : Char) -> Bool {
  between(this, 'A', 'Z') || between(this, 'a', 'z')
}

fn isIdChar(this : Char) -> Bool {
  isAlpha(this) || isDigit(this) || this == '_' || this == '-'
}

fn isWhiteSpace(this : Char) -> Bool {
  this == ' ' || this == '\t' || this == '\n'
}

fn to_number(this : Char) -> Int {
  this.to_int() - 48
}

fn isOpen(this : Char) -> Bool {
  this == '(' || this == '[' || this == '{'
}

fn isClose(this : Char) -> Bool {
  this == ')' || this == ']' || this == '}'
}

struct Tokens {
  tokens : Array[Token]
  mut current : Int
} derive(Show)

fn Tokens::new(tokens : Array[Token]) -> Tokens {
  Tokens::{ tokens, current: 0 }
}

fn peek(self : Tokens) -> Token {
  if self.current < self.tokens.length() {
    return self.tokens[self.current]
  } else {
    return EOF
  }
}

type! ParseError String

fn next(self : Tokens, loc~ : SourceLoc = _) -> Unit {
  self.current = self.current + 1
  if self.current > self.tokens.length() {
    abort("Tokens::next(): \{loc}")
  }
}

fn eat(self : Tokens, tok : Token, loc~ : SourceLoc = _) -> Unit!ParseError {
  let __tok = self.peek()
  // assert tok_ != EOF
  if __tok != tok {
    raise ParseError("\{loc} - Tokens::eat(): expect \{tok} but got \{__tok}")
  } else {
    self.next()
  }
}

fn tokenize(source : String) -> Tokens {
  let tokens : Array[Token] = Array::new(capacity=source.length() / 2)
  let mut current = 0
  let source = source.to_array()
  fn peek() -> Char {
    source[current]
  }

  fn next() -> Unit {
    current = current + 1
  }

  while current < source.length() {
    let ch = peek()
    if isWhiteSpace(ch) {
      next()
      continue
    } else if isDigit(ch) {
      let mut num = to_number(ch)
      next()
      while current < source.length() && isDigit(peek()) {
        num = num * 10 + to_number(peek())
        next()
      }
      tokens.push(Number(num))
      continue
    } else if isOpen(ch) {
      next()
      tokens.push(Open(ch))
      continue
    } else if isClose(ch) {
      next()
      tokens.push(Close(ch))
      continue
    } else if isAlpha(ch) {
      let identifier = @buffer.new(size_hint=42)
      identifier.write_char(ch)
      next()
      while current < source.length() && isIdChar(peek()) {
        identifier.write_char(peek())
        next()
      }
      let identifier = identifier.contents().to_unchecked_string()
      match identifier {
        "let" => tokens.push(Let)
        "letrec" => tokens.push(Letrec)
        "Nil" => tokens.push(NIL)
        "Cons" => tokens.push(CONS)
        "case" => tokens.push(Case)
        "defn" => tokens.push(DefFn)
        _ => tokens.push(Id(identifier))
      }
    } else {
      abort("error : invalid Character '\{ch}' in [\{current}]")
    }
  } else {
    return Tokens::new(tokens)
  }
}

test "tokenize" {
  inspect!(tokenize("").tokens, content="[]")
  inspect!(tokenize("12345678").tokens, content="[Number(12345678)]")
  inspect!(tokenize("1234 5678").tokens, content="[Number(1234), Number(5678)]")
  inspect!(
    tokenize("a0 a_0 a-0").tokens,
    content=
      #|[Id("a0"), Id("a_0"), Id("a-0")]
    ,
  )
  inspect!(
    tokenize("(Cons 0 (Cons 1 Nil))").tokens,
    content="[Open('('), CONS, Number(0), Open('('), CONS, Number(1), NIL, Close(')'), Close(')')]",
  )
}

fn parse_num(self : Tokens) -> Int!ParseError {
  match self.peek() {
    Number(n) => {
      self.next()
      return n
    }
    other => raise ParseError("parse_num(): expect a number but got \{other}")
  }
}

fn parse_var(self : Tokens) -> String!ParseError {
  match self.peek() {
    Id(s) => {
      self.next()
      return s
    }
    other => raise ParseError("parse_var(): expect a variable but got \{other}")
  }
}

fn parse_cons(self : Tokens) -> RawExpr[String]!ParseError {
  match self.peek() {
    CONS => {
      self.next()
      let x = self.parse_expr!()
      let xs = self.parse_expr!()
      return App(App(Constructor(tag=1, arity=2), x), xs)
    }
    other => raise ParseError("parse_cons(): expect Cons but got \{other}")
  }
}

fn parse_let(self : Tokens) -> RawExpr[String]!ParseError {
  self.eat!(Let)
  self.eat!(Open('('))
  let defs = self.parse_defs!()
  self.eat!(Close(')'))
  let exp = self.parse_expr!()
  Let(false, defs, exp)
}

fn parse_letrec(self : Tokens) -> RawExpr[String]!ParseError {
  self.eat!(Letrec)
  self.eat!(Open('('))
  let defs = self.parse_defs!()
  self.eat!(Close(')'))
  let exp = self.parse_expr!()
  Let(true, defs, exp)
}

fn parse_case(self : Tokens) -> RawExpr[String]!ParseError {
  self.eat!(Case)
  let exp = self.parse_expr!()
  let alts = self.parse_alts!()
  Case(exp, alts)
}

fn parse_alts(
  self : Tokens
) -> List[(Int, List[String], RawExpr[String])]!ParseError {
  let acc : List[(Int, List[String], RawExpr[String])] = Nil
  loop self.peek(), acc {
    Open('['), acc => {
      self.next()
      self.eat!(Open('('))
      let (tag, variables) = match self.peek() {
        NIL => {
          self.next()
          (0, List::Nil)
        }
        CONS => {
          self.next()
          let x = self.parse_var!()
          let xs = self.parse_var!()
          (1, @immut/list.of([x, xs]))
        }
        other =>
          raise ParseError("parse_alts(): expect NIL or CONS but got \{other}")
      }
      self.eat!(Close(')'))
      let exp = self.parse_expr!()
      let alt = (tag, variables, exp)
      self.eat!(Close(']'))
      continue self.peek(), Cons(alt, acc)
    }
    _, acc => acc.rev()
  }
}

fn parse_defs(self : Tokens) -> List[(String, RawExpr[String])]!ParseError {
  let acc : List[(String, RawExpr[String])] = Nil
  loop self.peek(), acc {
    Open('['), acc => {
      self.next()
      let var = self.parse_var!()
      let value = self.parse_expr!()
      self.eat!(Close(']'))
      continue self.peek(), Cons((var, value), acc)
    }
    _, acc => acc.rev()
  }
}

fn parse_apply(self : Tokens) -> RawExpr[String]!ParseError {
  let mut res = self.parse_expr!()
  while self.peek() != Close(')') {
    res = App(res, self.parse_expr!())
  }
  return res
}

fn parse_expr(self : Tokens) -> RawExpr[String]!ParseError {
  match self.peek() {
    EOF =>
      raise ParseError(
        "parse_expr() : expect a token but got a empty token stream",
      )
    Number(n) => {
      self.next()
      Num(n)
    }
    Id(s) => {
      self.next()
      Var(s)
    }
    NIL => {
      self.next()
      Constructor(tag=0, arity=0)
    }
    Open('(') => {
      self.next()
      let exp = match self.peek() {
        Let => self.parse_let!()
        Letrec => self.parse_letrec!()
        Case => self.parse_case!()
        CONS => self.parse_cons!()
        Id(_) | Open('(') => self.parse_apply!()
        other =>
          raise ParseError("parse_expr(): cant parse \{other} behind a '('")
      }
      self.eat!(Close(')'))
      return exp
    }
    other => raise ParseError("parse_expr(): cant parse \{other}")
  }
}

fn parse_sc(self : Tokens) -> ScDef[String]!ParseError {
  self.eat!(Open('('))
  self.eat!(DefFn)
  let fn_name = self.parse_var!()
  self.eat!(Open('['))
  let args = loop self.peek(), List::Nil {
    tok, acc =>
      if tok != Close(']') {
        let var = self.parse_var!()
        continue self.peek(), Cons(var, acc)
      } else {
        acc.rev()
      }
  }
  self.eat!(Close(']'))
  let body = self.parse_expr!()
  self.eat!(Close(')'))
  ScDef::{ name: fn_name, args, body }
}

test "parse scdef" {
  let test_ = fn!(s) { ignore(tokenize(s).parse_sc!()) }
  for p in programs {
    let (_, p) = p
    test_!(p)
  }
}


================================================
File 500: /data/input/moonbit-docs/next/sources/gmachine/src/part2/top.mbt
================================================
fn run(codes : List[String]) -> Node {
  fn parse_then_compile(code : String) -> (String, Int, List[Instruction]) {
    let tokens = tokenize(code)
    let code = 
      try {
        tokens.parse_sc!()
      } catch {
        ParseError(s) => abort(s)
      } else {
        expr => expr
      }
    let code = compileSC(code)
    return code
  }
  let codes = codes.map(parse_then_compile) + prelude_defs.map(compileSC)
  let codes = compiled_primitives + codes
  let (heap, globals) = build_initial_heap(codes)
  let initialState : GState = {
    heap : heap,
    stack : Nil,
    // start init definition
    code : @immut/list.of([PushGlobal("main"), Eval]),
    // end init definition
    globals : globals,
    stats : 0,
    dump : Nil
  }
  initialState.reify()
}


test "basic eval" {
  let main = "(defn main[] (let ([add1 (add 1)]) (add1 1)))"
  inspect!(run(@immut/list.of([main])), content = "NNum(2)")
  let main = "(defn main[] (let ([x 4] [y 5]) (sub x y)))"
  inspect!(run(@immut/list.of([main])), content = "NNum(-1)")
}

================================================
File 501: /data/input/moonbit-docs/next/sources/gmachine/src/part2/vm.mbt
================================================

// Use the 'type' keyword to encapsulate an address type.
type Addr Int derive(Eq, Show)

// Describe graph nodes with an enumeration type.
enum Node {
  NNum(Int)
  // The application node
  NApp(Addr, Addr)
  // To store the number of parameters and 
  // the corresponding sequence of instructions for a super combinator
  NGlobal(String, Int, List[Instruction])
  // The Indirection node，The key component of implementing lazy evaluation
  NInd(Addr)
} derive(Eq, Show)

struct GHeap {
  // The heap uses an array, 
  // and the space with None content in the array is available as free memory.
  mut object_count : Int
  memory : Array[Node?]
}

// Allocate heap space for nodes.
fn alloc(self : GHeap, node : Node) -> Addr {
  let heap = self
  fn next(n : Int) -> Int {
    (n + 1) % heap.memory.length()
  }

  fn free(i : Int) -> Bool {
    match heap.memory[i] {
      None => true
      _ => false
    }
  }

  let mut i = heap.object_count
  while not(free(i)) {
    i = next(i)
  }
  heap.memory[i] = Some(node)
  heap.object_count = heap.object_count + 1
  return Addr(i)
}


fn op_get(self : GHeap, key : Addr) -> Node {
  let Addr(i) = key
  match self.memory[i] {
    Some(node) => node
    None => abort("GHeap::get(): index \{i} was empty")
  }
}

fn op_set(self : GHeap, key : Addr, val : Node) -> Unit {
  self.memory[key._] = Some(val)
}


struct GState {
  mut stack : List[Addr]
  heap : GHeap
  globals : @hashmap.T[String, Addr]
  mut dump : List[(List[Instruction], List[Addr])]
  mut code : List[Instruction]
  mut stats : GStats
}

type GStats Int

fn stat_incr(self : GState) -> Unit {
  self.stats = self.stats._ + 1
}

fn put_stack(self : GState, addr : Addr) -> Unit {
  self.stack = Cons(addr, self.stack)
}

fn put_dump(self : GState, codes : List[Instruction], stack : List[Addr]) -> Unit {
  self.dump = Cons((codes, stack), self.dump)
}

fn put_code(self : GState, instrs : List[Instruction]) -> Unit {
  self.code = instrs + self.code
}

fn pop1(self : GState) -> Addr {
  match self.stack {
    Cons(addr, reststack) => {
      self.stack = reststack
      addr
    }
    Nil => abort("pop1(): stack size smaller than 1")
  }
}

// e1 e2 ..... -> (e1, e2) ......
fn pop2(self : GState) -> (Addr, Addr) {
  match self.stack {
    Cons(addr1, Cons(addr2, reststack)) => {
      self.stack = reststack
      (addr1, addr2)
    }
    _ => abort("pop2(): stack size smaller than 2")
  }
}

fn push_int(self : GState, num : Int) -> Unit {
  let addr = self.heap.alloc(NNum(num))
  self.put_stack(addr)
}

fn push_global(self : GState, name : String) -> Unit {
  let sc = self.globals[name]
  match sc {
    None => abort("push_global(): cant find supercombinator \{name}")
    Some(addr) => self.put_stack(addr)
  }
}

// start push definition
fn push(self : GState, offset : Int) -> Unit {
  // Push(n) a0 : . . . : an : s
  //     =>  an : a0 : . . . : an : s
  let addr = self.stack.unsafe_nth(offset)
  self.put_stack(addr)
}
// end push definition

// start slide definition
fn slide(self : GState, n : Int) -> Unit {
  let addr = self.pop1()
  self.stack = Cons(addr, self.stack.drop(n))
}
// end slide definition

// start rearrange definition
fn rearrange(self : GState, n : Int) -> Unit {
  let appnodes = self.stack.take(n)
  let args = appnodes.map(fn (addr) {
    guard self.heap[addr] is NApp(_, arg)
    arg 
  })
  self.stack = args + appnodes.drop(n - 1)
}
// end rearrange definition

fn mk_apply(self : GState) -> Unit {
  let (a1, a2) = self.pop2()
  let appaddr = self.heap.alloc(NApp(a1, a2))
  self.put_stack(appaddr)
}
fn update(self : GState, n : Int) -> Unit {
  let addr = self.pop1()
  let dst = self.stack.unsafe_nth(n)
  self.heap[dst] = NInd(addr)
}

// start unwind definition
fn unwind(self : GState) -> Unit {
  let addr = self.pop1()
  match self.heap[addr] {
    NNum(_) => {
      match self.dump {
        Nil => self.put_stack(addr)
        Cons((instrs, stack), rest_dump) => {
          self.stack = stack
          self.put_stack(addr)
          self.dump = rest_dump
          self.code = instrs
        }
      }
    }
    NApp(a1, _) => {
      self.put_stack(addr)
      self.put_stack(a1)
      self.put_code(@immut/list.of([Unwind]))
    }
    NGlobal(_, n, c) => {
      if self.stack.length() < n {
        abort("Unwinding with too few arguments")
      } else {
        if n != 0 {
          self.rearrange(n)
        } else {
          self.put_stack(addr)
        }
        self.put_code(c)
      }
    }
    NInd(a) => {
      self.put_stack(a)
      self.put_code(@immut/list.of([Unwind]))
    }
  }
}
// end unwind definition

// start alloc definition
fn alloc_nodes(self : GState, n : Int) -> Unit {
  let dummynode : Node = NInd(Addr(-1))
  for i = 0; i < n; i = i + 1 {
    let addr = self.heap.alloc(dummynode)
    self.put_stack(addr)
  }
}
// end alloc definition

// start eval definition
fn eval(self : GState) -> Unit {
  let addr = self.pop1()
  self.put_dump(self.code, self.stack)
  self.stack = @immut/list.of([addr])
  self.code = @immut/list.of([Unwind])
}
// end eval definition

// start cond definition
fn condition(self : GState, i1 : List[Instruction], i2 : List[Instruction]) -> Unit {
  let addr = self.pop1()
  match self.heap[addr] {
    NNum(0) => {
      // false
      self.code = i2 + self.code
    }
    NNum(1) => {
      // true
      self.code = i1 + self.code
    }
    otherwise => abort("cond : \{addr} = \{otherwise}")
  }
}
// end cond definition

// start op definition
fn negate(self : GState) -> Unit {
  let addr = self.pop1()
  match self.heap[addr] {
    NNum(n) => {
      let addr = self.heap.alloc(NNum(-n))
      self.put_stack(addr)
    }
    otherwise => {
      abort("negate: wrong kind of node \{otherwise}, address \{addr}")
    }
  }
}

fn lift_arith2(self : GState, op : (Int, Int) -> Int) -> Unit {
  let (a1, a2) = self.pop2()
  match (self.heap[a1], self.heap[a2]) {
    (NNum(n1), NNum(n2)) => {
      let newnode = Node::NNum(op(n1, n2))
      let addr = self.heap.alloc(newnode)
      self.put_stack(addr)
    }
    (node1, node2) => abort("liftArith2: \{a1} = \{node1} \{a2} = \{node2}")
  }
}

fn lift_cmp2(self : GState, op : (Int, Int) -> Bool) -> Unit {
  let (a1, a2) = self.pop2()
  match (self.heap[a1], self.heap[a2]) {
    (NNum(n1), NNum(n2)) => {
      let flag = op(n1, n2)
      let newnode = if flag { Node::NNum(1) } else { Node::NNum(0) }
      let addr = self.heap.alloc(newnode)
      self.put_stack(addr)
    }
    (node1, node2) => abort("liftCmp2: \{a1} = \{node1} \{a2} = \{node2}")
  }
}
// end op definition

fn build_initial_heap(
  scdefs : List[(String, Int, List[Instruction])]
) -> (GHeap, @hashmap.T[String, Addr]) {
  let heap = { object_count: 0, memory: Array::make(10000, None) }
  let globals = @hashmap.new(capacity=50)
  loop scdefs {
    Nil => ()
    Cons((name, arity, instrs), rest) => {
      let addr = heap.alloc(NGlobal(name, arity, instrs))
      globals[name] = addr
      continue rest
    }
  }
  return (heap, globals)
}



fn step(self : GState) -> Bool {
  match self.code {
    Nil => return false
    Cons(i, rest) => {
      self.code = rest
      self.stat_incr()
      match i {
        PushGlobal(f) => self.push_global(f)
        PushInt(n) => self.push_int(n)
        Push(n) => self.push(n)
        MkApp => self.mk_apply()
        Unwind => self.unwind()
        Update(n) => self.update(n)
        Pop(n) => self.stack = self.stack.drop(n)
        Alloc(n) => self.alloc_nodes(n)
        Eval => self.eval()
        Slide(n) => self.slide(n)
        Add => self.lift_arith2(fn (x, y) { x + y})
        Sub => self.lift_arith2(fn (x, y) { x - y})
        Mul => self.lift_arith2(fn (x, y) { x * y})
        Div => self.lift_arith2(fn (x, y) { x / y})
        Neg => self.negate()
        Eq => self.lift_cmp2(fn (x, y) { x == y })
        Ne => self.lift_cmp2(fn (x, y) { x != y })
        Lt => self.lift_cmp2(fn (x, y) { x < y })
        Le => self.lift_cmp2(fn (x, y) { x <= y })
        Gt => self.lift_cmp2(fn (x, y) { x > y })
        Ge => self.lift_cmp2(fn (x, y) { x >= y })
        Cond(i1, i2) => self.condition(i1, i2)
      }
      return true
    }
  }
}



fn reify(self : GState) -> Node {
  if self.step() {
    self.reify()
  } else {
    let stack = self.stack
    match stack {
      Cons(addr, Nil) => {
        let res = self.heap[addr]
        return res
      }
      _ => abort("wrong stack \{stack}")
    }
  }
}



================================================
File 502: /data/input/moonbit-docs/next/sources/gmachine/src/part3/ast.mbt
================================================
typealias List[E] = @immut/list.T[E]


enum RawExpr[T] {
  Var(T)
  Num(Int)
  Constructor(tag~:Int, arity~:Int) // tag, arity
  App(RawExpr[T], RawExpr[T])
  Let(Bool, List[(T, RawExpr[T])], RawExpr[T]) // isRec, Defs, Body
  Case(RawExpr[T], List[(Int, List[T], RawExpr[T])])
} derive(Show)

struct ScDef[T] {
  name : String
  args : List[T]
  body : RawExpr[T]
} derive(Show)

fn is_atom[T](self : RawExpr[T]) -> Bool {
  match self {
    Var(_) => true
    Num(_) => true
    _ => false
  }
}

fn ScDef::new[T](
  name : String,
  args : List[T],
  body : RawExpr[T]
) -> ScDef[T] {
  { name : name, args : args, body : body }
}

let prelude_defs : List[ScDef[String]] = {
  let args : (FixedArray[String]) -> List[String] = @immut/list.of
  let id = ScDef::new("I", args(["x"]), Var("x")) // id x = x
  let k = 
    ScDef::new(
      "K",
      args(["x", "y"]),
      Var("x")
    ) // K x y = x
  let k1 = 
    ScDef::new(
      "K1",
      args(["x", "y"]),
      Var("y")
    ) // K1 x y = y
  let s = 
    ScDef::new(
      "S",
      args(["f", "g", "x"]),
      App(App(Var("f"), Var("x")), App(Var("g"), Var("x")))
    ) // S f g x = f x (g x)
  let compose = 
    ScDef::new(
      "compose",
      args(["f", "g", "x"]),
      App(Var("f"), App(Var("g"), Var("x")))
    ) // compose f g x = f (g x)
  let twice = 
    ScDef::new(
      "twice",
      args(["f"]),
      App(App(Var("compose"), Var("f")), Var("f"))
    ) // twice f = compose f f
  @immut/list.of([id, k, k1, s, compose, twice])
}

================================================
File 503: /data/input/moonbit-docs/next/sources/gmachine/src/part3/compile.mbt
================================================
fn compileSC(self : ScDef[String]) -> (String, Int, List[Instruction]) {
  let name = self.name
  let body = self.body
  let mut arity = 0
  fn gen_env(i : Int, args : List[String]) -> List[(String, Int)] {
    match args {
      Nil => {
        arity = i
        return Nil
      }
      Cons(s, ss) => Cons((s, i), gen_env(i + 1, ss))
    }
  }

  let env = gen_env(0, self.args)
  (name, arity, compileR(body, env, arity))
}


fn compileR(
  self : RawExpr[String],
  env : List[(String, Int)],
  arity : Int
) -> List[Instruction] {
  if arity == 0 {
    compileE(self, env) + @immut/list.of([Update(arity), Unwind])
  } else {
    compileE(self, env) + @immut/list.of([Update(arity), Pop(arity), Unwind])
  }
}

fn compileC(
  self : RawExpr[String],
  env : List[(String, Int)]
) -> List[Instruction] {
  match self {
    Var(s) =>
      match env.lookup(s) {
        None => @immut/list.of([PushGlobal(s)])
        Some(n) => @immut/list.of([Push(n)])
      }
    Num(n) => @immut/list.of([PushInt(n)])
    // start c_constr definition
    App(App(Constructor(tag = 1, arity = 2), x), xs) => {
      // Cons(x, xs)
      compileC(xs, env) + compileC(x, argOffset(1, env)) + @immut/list.of([Pack(1, 2)])
    }
    // Nil
    Constructor(tag = 0, arity = 0) => @immut/list.of([Pack(0, 0)])
    // end c_constr definition
    App(e1, e2) =>
      compileC(e2, env) + compileC(e1, argOffset(1, env)) + @immut/list.of([MkApp])
    Let(rec, defs, e) =>
      if rec {
        compileLetrec(compileC, defs, e, env)
      } else {
        compileLet(compileC, defs, e, env)
      } 
    _ => abort("not support yet")
  }
}

fn compileE(self : RawExpr[String], env : List[(String, Int)]) -> List[Instruction] {
  match self {
    // start num definition
    Num(n) => @immut/list.of([PushInt(n)])
    // end num definition
    // start let definition
    Let(rec, defs, e) => {
      if rec {
        compileLetrec(compileE, defs, e, env)
      } else {
        compileLet(compileE, defs, e, env)
      }
    }
    // end let definition
    // start if_and_neg definition
    App(App(App(Var("if"), b), e1), e2) => {
      let condition = compileE(b, env)
      let branch1 = compileE(e1, env)
      let branch2 = compileE(e2, env)
      condition +  @immut/list.of([Cond(branch1, branch2)])
    }
    App(Var("negate"), e) => {
      compileE(e, env) + @immut/list.of([Neg])
    }
    // end if_and_neg definition
    // start binop definition
    App(App(Var(op), e0), e1) => {
      match builtinOpS[op] {
        None => compileC(self, env) + @immut/list.of([Eval])
        Some(instr) => {
          let code1 = compileE(e1, env)
          let code0 = compileE(e0, argOffset(1, env))
          code1 + code0 + @immut/list.of([instr])
        }
      }
    }
    // end binop definition
    // start e_constr_case definition
    Case(e, alts) => {
      compileE(e, env) + @immut/list.of([CaseJump(compileAlts(alts, env))])
    }
    Constructor(tag = 0, arity = 0) => {
      // Nil
      @immut/list.of([Pack(0, 0)])
    }
    App(App(Constructor(tag = 1, arity = 2), x), xs) => {
      // Cons(x, xs)
      compileC(xs, env) + compileC(x, argOffset(1, env)) + @immut/list.of([Pack(1, 2)])
    }
    // end e_constr_case definition
    // start default definition
    _ => compileC(self, env) + @immut/list.of([Eval])
    // end default definition
  }
}

fn compileAlts(alts : List[(Int, List[String], RawExpr[String])], env : List[(String, Int)]) -> List[(Int, List[Instruction])] {
  fn buildenv(variables : List[String], off : Int) -> List[(String, Int)] {
    match variables {
      Nil => Nil
      Cons(v, vs) => {
        Cons((v, off), buildenv(vs, off + 1))
      }
    }
  }
  fn go(alts : List[(Int, List[String], RawExpr[String])]) -> List[(Int, List[Instruction])] {
    match alts {
      Nil => Nil
      Cons(alt, rest) => {
        let (tag, variables, body) = alt
        let offset = variables.length()
        let env = buildenv(variables, 0) + argOffset(offset, env)
        let code = 
          @immut/list.of([Split]) + compileE(body, env) + @immut/list.of([Slide(offset)])
        Cons((tag, code), go(rest))
      }
    }
  }
  go(alts)
}


fn argOffset(n : Int, env : List[(String, Int)]) -> List[(String, Int)] {
  env.map(fn { (name, offset) => (name, offset + n) })
}


fn compileLet(
  comp : (RawExpr[String], List[(String, Int)]) -> List[Instruction],
  defs : List[(String, RawExpr[String])],
  expr : RawExpr[String],
  env : List[(String, Int)]
) -> List[Instruction] {
  let (env, codes) = loop env, List::Nil, defs {
    env, acc, Nil => (env, acc)
    env, acc, Cons((name, expr), rest) => {
      let code = compileC(expr, env)
      let env = List::Cons((name, 0), argOffset(1, env))
      continue env, acc + code, rest
    }
  }
  codes + comp(expr, env) + @immut/list.of([Slide(defs.length())])
}

fn compileLetrec(
  comp : (RawExpr[String], List[(String, Int)]) -> List[Instruction],
  defs : List[(String, RawExpr[String])],
  expr : RawExpr[String],
  env : List[(String, Int)]
) -> List[Instruction] {
  let mut env = env
  loop defs {
    Nil => ()
    Cons((name, _), rest) => {
      env = Cons((name, 0), argOffset(1, env))
      continue rest
    }
  }
  let n = defs.length()
  fn compileDefs(
    defs : List[(String, RawExpr[String])],
    offset : Int
  ) -> List[Instruction] {
    match defs {
      Nil => comp(expr, env) + @immut/list.of([Slide(n)])
      Cons((_, expr), rest) =>
        compileC(expr, env) +
        Cons(Update(offset), compileDefs(rest, offset - 1))
    }
  }

  Cons(Alloc(n), compileDefs(defs, n - 1))
}



let compiled_primitives : List[(String, Int, List[Instruction])] = @immut/list.of(
  [
    // Arith
    (
      "add",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Add, Update(2), Pop(2), Unwind]),
    ),
    (
      "sub",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Sub, Update(2), Pop(2), Unwind]),
    ),
    (
      "mul",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Mul, Update(2), Pop(2), Unwind]),
    ),
    (
      "div",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Div, Update(2), Pop(2), Unwind]),
    ),
    // Compare
    (
      "eq",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Eq, Update(2), Pop(2), Unwind]),
    ),
    (
      "neq",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Ne, Update(2), Pop(2), Unwind]),
    ),
    (
      "ge",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Ge, Update(2), Pop(2), Unwind]),
    ),
    (
      "gt",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Gt, Update(2), Pop(2), Unwind]),
    ),
    (
      "le",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Le, Update(2), Pop(2), Unwind]),
    ),
    (
      "lt",
      2,
      @immut/list.of([Push(1), Eval, Push(1), Eval, Lt, Update(2), Pop(2), Unwind]),
    ),
    // MISC
    ("negate", 1, @immut/list.of([Push(0), Eval, Neg, Update(1), Pop(1), Unwind])),
    (
      "if",
      3,
      @immut/list.of(
        [
          Push(0),
          Eval,
          Cond(@immut/list.of([Push(1)]), @immut/list.of([Push(2)])),
          Update(3),
          Pop(3),
          Unwind,
        ],
      ),
    ),
  ],
)

// start builtin definition
let builtinOpS : @hashmap.T[String, Instruction] = {
  let table  = @hashmap.new(capacity = 50)
  table["add"] = Add 
  table["mul"] = Mul
  table["sub"] = Sub
  table["div"] = Div
  table["eq"]  = Eq
  table["neq"] = Ne
  table["ge"] = Ge 
  table["gt"] = Gt
  table["le"] = Le
  table["lt"] = Lt
  table
}
// end builtin definition

================================================
File 504: /data/input/moonbit-docs/next/sources/gmachine/src/part3/instruction.mbt
================================================
// start instr definition
enum Instruction {
  Unwind
  PushGlobal(String)
  PushInt(Int)
  Push(Int)
  MkApp
  Slide(Int)
  Update(Int)
  Pop(Int)
  Alloc(Int)
  Eval
  Add
  Sub
  Mul
  Div 
  Neg
  Eq // ==
  Ne // !=
  Lt // <
  Le // <=
  Gt // >
  Ge // >=
  Cond(List[Instruction], List[Instruction])
  Pack(Int, Int) // tag, arity
  CaseJump(List[(Int, List[Instruction])])
  Split
  Print
} derive (Eq, Show)
// end instr definition

================================================
File 505: /data/input/moonbit-docs/next/sources/gmachine/src/part3/programs.mbt
================================================
let programs : @hashmap.T[String, String] = {
  let programs = @hashmap.new(capacity=40)
  programs["square"] =
    #| (defn square[x] (mul x x))
  programs["fix"] =
    #| (defn fix[f] (letrec ([x (f x)]) x))
  programs["isNil"] =
    #| (defn isNil[x]
    #|   (case x [(Nil) 1] [(Cons n m) 0]))
  programs["tail"] =
    #| (defn tail[l] (case l [(Cons x xs) xs]))
  programs["fibs"] =
    // fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
    #| (defn fibs[] (Cons 0 (Cons 1 (zipWith add fibs (tail fibs)))))
  programs["take"] =
    #| (defn take[n l]
    #|   (case l
    #|     [(Nil) Nil]
    #|     [(Cons x xs)
    #|        (if (le n 0) Nil (Cons x (take (sub n 1) xs)))]))
  programs["zipWith"] =
    #| (defn zipWith[op l1 l2]
    #|   (case l1
    #|     [(Nil) Nil]
    #|     [(Cons x xs)
    #|       (case l2
    #|         [(Nil) Nil]
    #|         [(Cons y ys) (Cons (op x y) (zipWith op xs ys))])]))
  programs["factorial"] =
    #| (defn factorial[n]
    #|   (if (eq n 0) 1 (mul n (factorial (sub n 1)))))
  programs["abs"] =
    #| (defn abs[n]
    #|   (if (lt n 0) (negate n) n))
  programs["length"] =
    #| (defn length[l]
    #|   (case l
    #|     [(Nil) 0]
    #|     [(Cons x xs) (add 1 (length xs))]))
  programs
}


================================================
File 506: /data/input/moonbit-docs/next/sources/gmachine/src/part3/syntax.mbt
================================================
enum Token {
  DefFn
  Let
  NIL
  CONS
  Case
  Letrec
  Open(Char) // { [ (
  Close(Char) // } ] )
  Id(String)
  Number(Int)
  EOF
} derive(Eq, Show)

fn between(this : Char, lw : Char, up : Char) -> Bool {
  this >= lw && this <= up
}

fn isDigit(this : Char) -> Bool {
  between(this, '0', '9')
}

fn isAlpha(this : Char) -> Bool {
  between(this, 'A', 'Z') || between(this, 'a', 'z')
}

fn isIdChar(this : Char) -> Bool {
  isAlpha(this) || isDigit(this) || this == '_' || this == '-'
}

fn isWhiteSpace(this : Char) -> Bool {
  this == ' ' || this == '\t' || this == '\n'
}

fn to_number(this : Char) -> Int {
  this.to_int() - 48
}

fn isOpen(this : Char) -> Bool {
  this == '(' || this == '[' || this == '{'
}

fn isClose(this : Char) -> Bool {
  this == ')' || this == ']' || this == '}'
}

struct Tokens {
  tokens : Array[Token]
  mut current : Int
} derive(Show)

fn Tokens::new(tokens : Array[Token]) -> Tokens {
  Tokens::{ tokens, current: 0 }
}

fn peek(self : Tokens) -> Token {
  if self.current < self.tokens.length() {
    return self.tokens[self.current]
  } else {
    return EOF
  }
}

type! ParseError String

fn next(self : Tokens, loc~ : SourceLoc = _) -> Unit {
  self.current = self.current + 1
  if self.current > self.tokens.length() {
    abort("Tokens::next(): \{loc}")
  }
}

fn eat(self : Tokens, tok : Token, loc~ : SourceLoc = _) -> Unit!ParseError {
  let __tok = self.peek()
  // assert tok_ != EOF
  if __tok != tok {
    raise ParseError("\{loc} - Tokens::eat(): expect \{tok} but got \{__tok}")
  } else {
    self.next()
  }
}

fn tokenize(source : String) -> Tokens {
  let tokens : Array[Token] = Array::new(capacity=source.length() / 2)
  let mut current = 0
  let source = source.to_array()
  fn peek() -> Char {
    source[current]
  }

  fn next() -> Unit {
    current = current + 1
  }

  while current < source.length() {
    let ch = peek()
    if isWhiteSpace(ch) {
      next()
      continue
    } else if isDigit(ch) {
      let mut num = to_number(ch)
      next()
      while current < source.length() && isDigit(peek()) {
        num = num * 10 + to_number(peek())
        next()
      }
      tokens.push(Number(num))
      continue
    } else if isOpen(ch) {
      next()
      tokens.push(Open(ch))
      continue
    } else if isClose(ch) {
      next()
      tokens.push(Close(ch))
      continue
    } else if isAlpha(ch) {
      let identifier = @buffer.new(size_hint=42)
      identifier.write_char(ch)
      next()
      while current < source.length() && isIdChar(peek()) {
        identifier.write_char(peek())
        next()
      }
      let identifier = identifier.contents().to_unchecked_string()
      match identifier {
        "let" => tokens.push(Let)
        "letrec" => tokens.push(Letrec)
        "Nil" => tokens.push(NIL)
        "Cons" => tokens.push(CONS)
        "case" => tokens.push(Case)
        "defn" => tokens.push(DefFn)
        _ => tokens.push(Id(identifier))
      }
    } else {
      abort("error : invalid Character '\{ch}' in [\{current}]")
    }
  } else {
    return Tokens::new(tokens)
  }
}

test "tokenize" {
  inspect!(tokenize("").tokens, content="[]")
  inspect!(tokenize("12345678").tokens, content="[Number(12345678)]")
  inspect!(tokenize("1234 5678").tokens, content="[Number(1234), Number(5678)]")
  inspect!(
    tokenize("a0 a_0 a-0").tokens,
    content=
      #|[Id("a0"), Id("a_0"), Id("a-0")]
    ,
  )
  inspect!(
    tokenize("(Cons 0 (Cons 1 Nil))").tokens,
    content="[Open('('), CONS, Number(0), Open('('), CONS, Number(1), NIL, Close(')'), Close(')')]",
  )
}

fn parse_num(self : Tokens) -> Int!ParseError {
  match self.peek() {
    Number(n) => {
      self.next()
      return n
    }
    other => raise ParseError("parse_num(): expect a number but got \{other}")
  }
}

fn parse_var(self : Tokens) -> String!ParseError {
  match self.peek() {
    Id(s) => {
      self.next()
      return s
    }
    other => raise ParseError("parse_var(): expect a variable but got \{other}")
  }
}

fn parse_cons(self : Tokens) -> RawExpr[String]!ParseError {
  match self.peek() {
    CONS => {
      self.next()
      let x = self.parse_expr!()
      let xs = self.parse_expr!()
      return App(App(Constructor(tag=1, arity=2), x), xs)
    }
    other => raise ParseError("parse_cons(): expect Cons but got \{other}")
  }
}

fn parse_let(self : Tokens) -> RawExpr[String]!ParseError {
  self.eat!(Let)
  self.eat!(Open('('))
  let defs = self.parse_defs!()
  self.eat!(Close(')'))
  let exp = self.parse_expr!()
  Let(false, defs, exp)
}

fn parse_letrec(self : Tokens) -> RawExpr[String]!ParseError {
  self.eat!(Letrec)
  self.eat!(Open('('))
  let defs = self.parse_defs!()
  self.eat!(Close(')'))
  let exp = self.parse_expr!()
  Let(true, defs, exp)
}

fn parse_case(self : Tokens) -> RawExpr[String]!ParseError {
  self.eat!(Case)
  let exp = self.parse_expr!()
  let alts = self.parse_alts!()
  Case(exp, alts)
}

fn parse_alts(
  self : Tokens
) -> List[(Int, List[String], RawExpr[String])]!ParseError {
  let acc : List[(Int, List[String], RawExpr[String])] = Nil
  loop self.peek(), acc {
    Open('['), acc => {
      self.next()
      self.eat!(Open('('))
      let (tag, variables) = match self.peek() {
        NIL => {
          self.next()
          (0, List::Nil)
        }
        CONS => {
          self.next()
          let x = self.parse_var!()
          let xs = self.parse_var!()
          (1, @immut/list.of([x, xs]))
        }
        other =>
          raise ParseError("parse_alts(): expect NIL or CONS but got \{other}")
      }
      self.eat!(Close(')'))
      let exp = self.parse_expr!()
      let alt = (tag, variables, exp)
      self.eat!(Close(']'))
      continue self.peek(), Cons(alt, acc)
    }
    _, acc => acc.rev()
  }
}

fn parse_defs(self : Tokens) -> List[(String, RawExpr[String])]!ParseError {
  let acc : List[(String, RawExpr[String])] = Nil
  loop self.peek(), acc {
    Open('['), acc => {
      self.next()
      let var = self.parse_var!()
      let value = self.parse_expr!()
      self.eat!(Close(']'))
      continue self.peek(), Cons((var, value), acc)
    }
    _, acc => acc.rev()
  }
}

fn parse_apply(self : Tokens) -> RawExpr[String]!ParseError {
  let mut res = self.parse_expr!()
  while self.peek() != Close(')') {
    res = App(res, self.parse_expr!())
  }
  return res
}

fn parse_expr(self : Tokens) -> RawExpr[String]!ParseError {
  match self.peek() {
    EOF =>
      raise ParseError(
        "parse_expr() : expect a token but got a empty token stream",
      )
    Number(n) => {
      self.next()
      Num(n)
    }
    Id(s) => {
      self.next()
      Var(s)
    }
    NIL => {
      self.next()
      Constructor(tag=0, arity=0)
    }
    Open('(') => {
      self.next()
      let exp = match self.peek() {
        Let => self.parse_let!()
        Letrec => self.parse_letrec!()
        Case => self.parse_case!()
        CONS => self.parse_cons!()
        Id(_) | Open('(') => self.parse_apply!()
        other =>
          raise ParseError("parse_expr(): cant parse \{other} behind a '('")
      }
      self.eat!(Close(')'))
      return exp
    }
    other => raise ParseError("parse_expr(): cant parse \{other}")
  }
}

fn parse_sc(self : Tokens) -> ScDef[String]!ParseError {
  self.eat!(Open('('))
  self.eat!(DefFn)
  let fn_name = self.parse_var!()
  self.eat!(Open('['))
  let args = loop self.peek(), List::Nil {
    tok, acc =>
      if tok != Close(']') {
        let var = self.parse_var!()
        continue self.peek(), Cons(var, acc)
      } else {
        acc.rev()
      }
  }
  self.eat!(Close(']'))
  let body = self.parse_expr!()
  self.eat!(Close(')'))
  ScDef::{ name: fn_name, args, body }
}

test "parse scdef" {
  let test_ = fn!(s) { ignore(tokenize(s).parse_sc!()) }
  for p in programs {
    let (_, p) = p
    test_!(p)
  }
}


================================================
File 507: /data/input/moonbit-docs/next/sources/gmachine/src/part3/top.mbt
================================================
fn run(codes : List[String]) -> String {
  fn parse_then_compile(code : String) -> (String, Int, List[Instruction]) {
    let tokens = tokenize(code)
    let code = 
      try {
        tokens.parse_sc!()
      } catch {
        ParseError(s) => abort(s)
      } else {
        expr => expr
      }
    let code = compileSC(code)
    return code
  }
  let codes = codes.map(parse_then_compile) + prelude_defs.map(compileSC)
  let codes = compiled_primitives + codes
  let (heap, globals) = build_initial_heap(codes)
  let initialState : GState = {
    output : @buffer.new(size_hint = 60),
    heap : heap,
    stack : Nil,
    // start init definition
    code : @immut/list.of([PushGlobal("main"), Eval, Print]),
    // end init definition
    globals : globals,
    stats : 0,
    dump : Nil
  }
  initialState.reify()
}


test "basic eval" {
  let basic = []
  for kv in programs.iter() {
    let (_, v) = kv
    basic.push(v)
  }
  let basic = @immut/list.from_array(basic)
  
  let main = "(defn main[] (take 20 fibs))"
  inspect!(run(Cons(main, basic)), content = "0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 Nil")
}


================================================
File 508: /data/input/moonbit-docs/next/sources/gmachine/src/part3/vm.mbt
================================================

// Use the 'type' keyword to encapsulate an address type.
type Addr Int derive(Eq, Show)

// Describe graph nodes with an enumeration type.
enum Node {
  NNum(Int)
  // The application node
  NApp(Addr, Addr)
  // To store the number of parameters and 
  // the corresponding sequence of instructions for a super combinator
  NGlobal(String, Int, List[Instruction])
  // The Indirection node，The key component of implementing lazy evaluation
  NInd(Addr)
  NConstr(Int, List[Addr])
} derive(Eq, Show)

struct GHeap {
  // The heap uses an array, 
  // and the space with None content in the array is available as free memory.
  mut object_count : Int
  memory : Array[Node?]
}

// Allocate heap space for nodes.
fn alloc(self : GHeap, node : Node) -> Addr {
  let heap = self
  fn next(n : Int) -> Int {
    (n + 1) % heap.memory.length()
  }

  fn free(i : Int) -> Bool {
    match heap.memory[i] {
      None => true
      _ => false
    }
  }

  let mut i = heap.object_count
  while not(free(i)) {
    i = next(i)
  }
  heap.memory[i] = Some(node)
  heap.object_count = heap.object_count + 1
  return Addr(i)
}


fn op_get(self : GHeap, key : Addr) -> Node {
  let Addr(i) = key
  match self.memory[i] {
    Some(node) => node
    None => abort("GHeap::get(): index \{i} was empty")
  }
}

fn op_set(self : GHeap, key : Addr, val : Node) -> Unit {
  self.memory[key._] = Some(val)
}


struct GState {
  output : @buffer.T
  mut stack : List[Addr]
  heap : GHeap
  globals : @hashmap.T[String, Addr]
  mut dump : List[(List[Instruction], List[Addr])]
  mut code : List[Instruction]
  mut stats : GStats
}

type GStats Int

fn stat_incr(self : GState) -> Unit {
  self.stats = self.stats._ + 1
}

fn put_stack(self : GState, addr : Addr) -> Unit {
  self.stack = Cons(addr, self.stack)
}

fn put_dump(self : GState, codes : List[Instruction], stack : List[Addr]) -> Unit {
  self.dump = Cons((codes, stack), self.dump)
}

fn put_code(self : GState, instrs : List[Instruction]) -> Unit {
  self.code = instrs + self.code
}

fn pop1(self : GState) -> Addr {
  match self.stack {
    Cons(addr, reststack) => {
      self.stack = reststack
      addr
    }
    Nil => abort("pop1(): stack size smaller than 1")
  }
}

// e1 e2 ..... -> (e1, e2) ......
fn pop2(self : GState) -> (Addr, Addr) {
  match self.stack {
    Cons(addr1, Cons(addr2, reststack)) => {
      self.stack = reststack
      (addr1, addr2)
    }
    _ => abort("pop2(): stack size smaller than 2")
  }
}

fn push_int(self : GState, num : Int) -> Unit {
  let addr = self.heap.alloc(NNum(num))
  self.put_stack(addr)
}

fn push_global(self : GState, name : String) -> Unit {
  let sc = self.globals[name]
  match sc {
    None => abort("push_global(): cant find supercombinator \{name}")
    Some(addr) => self.put_stack(addr)
  }
}


fn push(self : GState, offset : Int) -> Unit {
  // Push(n) a0 : . . . : an : s
  //     =>  an : a0 : . . . : an : s
  let addr = self.stack.unsafe_nth(offset)
  self.put_stack(addr)
}

fn slide(self : GState, n : Int) -> Unit {
  let addr = self.pop1()
  self.stack = Cons(addr, self.stack.drop(n))
}

fn rearrange(self : GState, n : Int) -> Unit {
  let appnodes = self.stack.take(n)
  let args = appnodes.map(fn (addr) {
    guard self.heap[addr] is NApp(_, arg)
    arg 
  })
  self.stack = args + appnodes.drop(n - 1)
}


fn mk_apply(self : GState) -> Unit {
  let (a1, a2) = self.pop2()
  let appaddr = self.heap.alloc(NApp(a1, a2))
  self.put_stack(appaddr)
}
fn update(self : GState, n : Int) -> Unit {
  let addr = self.pop1()
  let dst = self.stack.unsafe_nth(n)
  self.heap[dst] = NInd(addr)
}


fn unwind(self : GState) -> Unit {
  let addr = self.pop1()
  match self.heap[addr] {
    NNum(_) => {
      match self.dump {
        Nil => self.put_stack(addr)
        Cons((instrs, stack), rest_dump) => {
          self.stack = stack
          self.put_stack(addr)
          self.dump = rest_dump
          self.code = instrs
        }
      }
    }
    NApp(a1, _) => {
      self.put_stack(addr)
      self.put_stack(a1)
      self.put_code(@immut/list.of([Unwind]))
    }
    // start unwind_g definition
    NGlobal(_, n, c) => {
      let k = self.stack.length()
      if k < n {
        match self.dump {
          Nil => abort("Unwinding with too few arguments")
          Cons((i, s), rest) => {
            // a1 : ...... : ak
            // ||
            // ak : s
            self.stack = self.stack.drop(k - 1) + s
            self.dump = rest
            self.code = i
          }
        }
      } else {
        if n != 0 {
          self.rearrange(n)
        } else {
          self.put_stack(addr)
        }
        self.put_code(c)
      }
    }
    // end unwind_g definition
    NInd(a) => {
      self.put_stack(a)
      self.put_code(@immut/list.of([Unwind]))
    }
    NConstr(_, _) => {
      match self.dump {
        Nil => abort("Unwinding with too few arguments")
        Cons((i, s), rest) => {
          self.dump = rest
          self.stack = s
          self.code = i
          self.put_stack(addr)
        }
      }
    }
  }
}

fn alloc_nodes(self : GState, n : Int) -> Unit {
  let dummynode : Node = NInd(Addr(-1))
  for i = 0; i < n; i = i + 1 {
    let addr = self.heap.alloc(dummynode)
    self.put_stack(addr)
  }
}

fn eval(self : GState) -> Unit {
  let addr = self.pop1()
  self.put_dump(self.code, self.stack)
  self.stack = @immut/list.of([addr])
  self.code = @immut/list.of([Unwind])
}

fn condition(self : GState, i1 : List[Instruction], i2 : List[Instruction]) -> Unit {
  let addr = self.pop1()
  match self.heap[addr] {
    NNum(0) => {
      // false
      self.code = i2 + self.code
    }
    NNum(1) => {
      // true
      self.code = i1 + self.code
    }
    otherwise => abort("cond : \{addr} = \{otherwise}")
  }
}

fn negate(self : GState) -> Unit {
  let addr = self.pop1()
  match self.heap[addr] {
    NNum(n) => {
      let addr = self.heap.alloc(NNum(-n))
      self.put_stack(addr)
    }
    otherwise => {
      abort("negate: wrong kind of node \{otherwise}, address \{addr}")
    }
  }
}

fn lift_arith2(self : GState, op : (Int, Int) -> Int) -> Unit {
  let (a1, a2) = self.pop2()
  match (self.heap[a1], self.heap[a2]) {
    (NNum(n1), NNum(n2)) => {
      let newnode = Node::NNum(op(n1, n2))
      let addr = self.heap.alloc(newnode)
      self.put_stack(addr)
    }
    (node1, node2) => abort("liftArith2: \{a1} = \{node1} \{a2} = \{node2}")
  }
}

fn lift_cmp2(self : GState, op : (Int, Int) -> Bool) -> Unit {
  let (a1, a2) = self.pop2()
  match (self.heap[a1], self.heap[a2]) {
    (NNum(n1), NNum(n2)) => {
      let flag = op(n1, n2)
      let newnode = if flag { Node::NNum(1) } else { Node::NNum(0) }
      let addr = self.heap.alloc(newnode)
      self.put_stack(addr)
    }
    (node1, node2) => abort("liftCmp2: \{a1} = \{node1} \{a2} = \{node2}")
  }
}

// start split_pack definition
fn pack(self : GState, t : Int, n : Int) -> Unit {
  let addrs = self.stack.take(n)
  self.stack = self.stack.drop(n)
  let addr = self.heap.alloc(NConstr(t, addrs))
  self.put_stack(addr)
}

fn split(self : GState) -> Unit {
  let addr = self.pop1()
  match self.heap[addr] {
    NConstr(_, addrs) => {
      // n == addrs.length()
      self.stack = addrs + self.stack
    }
    _ => panic()
  }
}
// end split_pack definition

// start casejump definition
fn casejump(self : GState, table : List[(Int, List[Instruction])]) -> Unit {
  let addr = self.pop1()
  match self.heap[addr] {
    NConstr(t, _) => {
      match table.lookup(t) {
        None => abort("casejump")
        Some(instrs) => { 
          self.code = instrs + self.code
          self.put_stack(addr)
        }
      }
    }
    otherwise => abort("casejump(): addr = \{addr} node = \{otherwise}")
  }
}
// end casejump definition

// start gprint definition
fn gprint(self : GState) -> Unit {
  let addr = self.pop1()
  match self.heap[addr] {
    NNum(n) => {
      self.output.write_string(n.to_string())
      self.output.write_char(' ')
    }
    NConstr(0, Nil) => self.output.write_string("Nil")
    NConstr(1, Cons(addr1, Cons(addr2, Nil))) => {
      self.code = @immut/list.of([Instruction::Eval, Print, Eval, Print]) + self.code
      self.put_stack(addr2)
      self.put_stack(addr1)
    }
    _ => panic()
  }
}
// end gprint definition


fn build_initial_heap(
  scdefs : List[(String, Int, List[Instruction])]
) -> (GHeap, @hashmap.T[String, Addr]) {
  let heap = { object_count: 0, memory: Array::make(10000, None) }
  let globals = @hashmap.new(capacity=50)
  loop scdefs {
    Nil => ()
    Cons((name, arity, instrs), rest) => {
      let addr = heap.alloc(NGlobal(name, arity, instrs))
      globals[name] = addr
      continue rest
    }
  }
  return (heap, globals)
}



fn step(self : GState) -> Bool {
  match self.code {
    Nil => return false
    Cons(i, rest) => {
      self.code = rest
      self.stat_incr()
      match i {
        PushGlobal(f) => self.push_global(f)
        PushInt(n) => self.push_int(n)
        Push(n) => self.push(n)
        MkApp => self.mk_apply()
        Unwind => self.unwind()
        Update(n) => self.update(n)
        Pop(n) => self.stack = self.stack.drop(n)
        Alloc(n) => self.alloc_nodes(n)
        Eval => self.eval()
        Slide(n) => self.slide(n)
        Add => self.lift_arith2(fn (x, y) { x + y})
        Sub => self.lift_arith2(fn (x, y) { x - y})
        Mul => self.lift_arith2(fn (x, y) { x * y})
        Div => self.lift_arith2(fn (x, y) { x / y})
        Neg => self.negate()
        Eq => self.lift_cmp2(fn (x, y) { x == y })
        Ne => self.lift_cmp2(fn (x, y) { x != y })
        Lt => self.lift_cmp2(fn (x, y) { x < y })
        Le => self.lift_cmp2(fn (x, y) { x <= y })
        Gt => self.lift_cmp2(fn (x, y) { x > y })
        Ge => self.lift_cmp2(fn (x, y) { x >= y })
        Cond(i1, i2) => self.condition(i1, i2)
        Pack(tag, arity) => self.pack(tag, arity)
        CaseJump(alts) => self.casejump(alts)
        Split => self.split()
        Print => self.gprint()
      }
      return true
    }
  }
}



fn reify(self : GState) -> String {
  if self.step() {
    self.reify()
  } else {
    self.output.contents().to_unchecked_string()
  }
}



================================================
File 509: /data/input/moonbit-docs/next/sources/lambda-expression/README.md
================================================
# moonbit-community/lambda

Check `tutorial/example/lambda`.

================================================
File 510: /data/input/moonbit-docs/next/sources/lambda-expression/src/top.mbt
================================================
enum Term {
  Var(String) // Variable
  Abs(String, Term) // Define lambda, variables represented by strings
  App(Term, Term) // Call lambda
}

struct Index {
  name : String
  depth : Int
}

enum TermDBI {
  Var(String, Int)
  Abs(String, TermDBI)
  App(TermDBI, TermDBI)
}

impl Show for TermDBI with output(self : TermDBI, logger) -> Unit {
  match self {
    Var(name, _) => logger.write_string(name)
    Abs(name, body) => logger.write_string("(\\\{name}.\{body})")
    App(t1, t2) => logger.write_string("\{t1} \{t2}")
  }
}

/// https://bor0.wordpress.com/2019/03/19/writing-a-lambda-calculus-evaluator-in-haskell/
fn bruijn(self : Term) -> Result[TermDBI, String] {
  // Find the depth corresponding to the first varname in the environment
  fn find(map : @immut/list.T[Index], varname : String) -> Result[Int, String] {
    match map {
      Nil => Err(varname)
      Cons(i, rest) =>
        if i.name == varname {
          Ok(i.depth)
        } else {
          find(rest, varname)
        }
    }
  }

  fn go(m : @immut/list.T[Index], t : Term) -> Result[TermDBI, String] {
    match t {
      Var(name) => {
        let idx = find(m, name)
        match idx {
          Err(name) => Err(name)
          Ok(idx) => Ok(Var(name, idx))
        }
      }
      Abs(varname, body) => {
        let m = @immut/list.Cons(
          { name: varname, depth: 0 },
          m.map(fn(index) { { name: index.name, depth: index.depth + 1 } }),
        )
        let res = go(m, body)
        match res {
          Err(name) => Err(name)
          Ok(term) => Ok(Abs(varname, term))
        }
      }
      App(e1, e2) =>
        match (go(m, e1), go(m, e2)) {
          (Ok(e1), Ok(e2)) => Ok(App(e1, e2))
          (Err(name), _) => Err(name)
          (_, Err(name)) => Err(name)
        }
    }
  }

  go(Nil, self)
}

fn subst(t1 : TermDBI, t2 : TermDBI) -> TermDBI {
  fn go(t1 : TermDBI, t2 : TermDBI, depth : Int) -> TermDBI {
    match t1 {
      Var(_, d) => if d == depth { t2 } else { t1 }
      Abs(name, t) => Abs(name, go(t, t2, depth + 1))
      App(tl, tr) => App(go(tl, t2, depth), go(tr, t2, depth))
    }
  }

  go(t1, t2, 0)
}

fn eval(self : TermDBI) -> TermDBI {
  match self {
    App(t1, t2) =>
      match (eval(t1), eval(t2)) {
        (Abs(_, t1), t2) => eval(subst(t1, t2))
        (t1, t2) => App(t1, t2)
      }
    Abs(_) => self
    // Eval should not encounter any free variables
    _ => panic()
  }
}

test {
  // (\x.x x) (\y.y)
  let exp : Term = App(Abs("x", App(Var("x"), Var("x"))), Abs("x", Var("x")))
  let exp = exp.bruijn()
  match exp {
    Err(name) => fail!("err on \{name}\n")
    Ok(t) => {
      inspect!(
        t,
        content=
          #|(\x.x x) (\x.x)
        ,
      )
      let t = eval(t)
      inspect!(
        t,
        content=
          #|(\x.x)
        ,
      )
    }
  }
}


================================================
File 511: /data/input/moonbit-docs/next/sources/language/README.md
================================================
# moonbit-community/language

Covers everything mentioned in `language` section.

================================================
File 512: /data/input/moonbit-docs/next/sources/language/src/builtin/top.mbt
================================================
let boolean : Unit = {
  // start boolean 1
  let a = true
  let b = false
  let c = a && b
  let d = a || b
  let e = not(a)
  // end boolean 1

}

let number : Unit = {
  // start number 1
  let a = 1234
  let b : Int = 1_000_000 + a
  let unsigned_num       : UInt   = 4_294_967_295U
  let large_num          : Int64  = 9_223_372_036_854_775_807L
  let unsigned_large_num : UInt64 = 18_446_744_073_709_551_615UL
  // end number 1

  // start number 2
  let bin = 0b110010
  let another_bin = 0B110010
  // end number 2

  // start number 3
  let octal = 0o1234
  let another_octal = 0O1234
  // end number 3

  // start number 4
  let hex = 0XA
  let another_hex = 0xA_B_C
  // end number 4

  // start number 6
  let double = 3.14 // Double
  let float : Float = 3.14
  let float2 = (3.14 : Float)
  // end number 6

  // start number 7
  let hex_double = 0x1.2P3 // (1.0 + 2 / 16) * 2^(+3) == 9
  // end number 7

  // start number 5
  let int : Int = 42
  let uint : UInt = 42
  let int64 : Int64 = 42
  let double : Double = 42
  let float : Float = 42
  let bigint : BigInt = 42
  // end number 5

}

test "string 1" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start string 1
  let a = "兔rabbit"
  println(a[0])
  println(a[1])
  let b =
    #| Hello
    #| MoonBit\n
    #|
  println(b)
  // end string 1
  t.snapshot!(filename="string_1")
}

let string : Unit = {
  // start string 3
  let x = 42
  println("The answer is \{x}")
  // end string 3
}

test "string 4" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start string 4
  let lang = "MoonBit"
  let str =
    #| Hello
    #| ---
    $| \{lang}\n
    #| ---
  println(str)
  // end string 4
  t.snapshot!(filename="string_4")
}

let char : Unit = {
  // start char 1
  let a : Char = 'A'
  let b = '\x41'
  let c = '兔'
  let zero = '\u{30}'
  let zero = '\u0030'
  // end char 1

}

test "byte 1" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start byte 1
  let b1 : Byte = b'a'
  println(b1.to_int())
  let b2 = b'\xff'
  println(b2.to_int())
  // end byte 1
  t.snapshot!(filename="byte_1")
}

// start byte 2
test {
  let b1 : Bytes = b"abcd"
  let b2 = b"\x61\x62\x63\x64"
  assert_eq!(b1, b2)
}
// end byte 2

// start buffer 1
test "buffer 1" {
  let buf : @buffer.T = @buffer.new()
  buf.write_bytes(b"Hello")
  buf.write_byte(b'!')
  assert_eq!(buf.contents(), b"Hello!")
}
// end buffer 1

test "tuple 1" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start tuple 1
  fn pack(
    a : Bool,
    b : Int,
    c : String,
    d : Double
  ) -> (Bool, Int, String, Double) {
    (a, b, c, d)
  }

  let quad = pack(false, 100, "text", 3.14)
  let (bool_val, int_val, str, float_val) = quad
  println("\{bool_val} \{int_val} \{str} \{float_val}")
  // end tuple 1
  t.snapshot!(filename="tuple_1")
}

// start tuple 2
test {
  let t = (1, 2)
  let (x1, y1) = t
  let x2 = t.0
  let y2 = t.1
  assert_eq!(x1, x2)
  assert_eq!(y1, y2)
}
// end tuple 2

let array : Unit = {
  // start array 1
  let numbers = [1, 2, 3, 4]
  // end array 1

}

// start array 2
test {
  let numbers = [1, 2, 3, 4]
  let a = numbers[2]
  numbers[3] = 5
  let b = a + numbers[3]
  assert_eq!(b, 8)
}
// end array 2

// start array 3
let fixed_array_1 : FixedArray[Int] = [1, 2, 3]
let fixed_array_2 = ([1, 2, 3] : FixedArray[Int])
let array_3 = [1, 2, 3] // Array[Int]
// end array 3

// start array pitfall
test {
  let two_dimension_array = FixedArray::make(10, FixedArray::make(10, 0))
  two_dimension_array[0][5] = 10
  assert_eq!(two_dimension_array[5][5], 10)
}
// end array pitfall

// start array pitfall solution
test {
  let two_dimension_array = FixedArray::makei(
    10, 
    fn (_i) { FixedArray::make(10, 0) }
  )
  two_dimension_array[0][5] = 10
  assert_eq!(two_dimension_array[5][5], 0)
}
// end array pitfall solution

// start map 1
let map : Map[String, Int] = { "x": 1, "y": 2, "z": 3 }
// end map 1

// start json 1
let moon_pkg_json_example : Json = {
  "import": ["moonbitlang/core/builtin", "moonbitlang/core/coverage"],
  "test-import": ["moonbitlang/core/random"],
}
// end json 1

// start ref 1
let a : Ref[Int] = { val : 100 }

test {
  a.val = 200
  assert_eq!(a.val, 200)
  a.val += 1
  assert_eq!(a.val, 201)
}
// end ref 1

// start option result 1
test {
  let a : Option[Int] = None
  let b : Option[Int] = Some(42)
  let c : Result[Int, String] = Ok(42)
  let d : Result[Int, String] = Err("error")
  match a {
    Some(_) => assert_true!(false)
    None => assert_true!(true)
  }
  match d {
    Ok(_) => assert_true!(false)
    Err(_) => assert_true!(true)
  }
}
// end option result 1

================================================
File 513: /data/input/moonbit-docs/next/sources/language/src/controls/top.mbt
================================================
fn a() -> Int {
  let x = 1
  let y = 1
  let z = 1
  let expr1 = 1
  let expr2 = 1
  let expr3 = 1
  // start conditional expressions 1
  if x == y {
    expr1
  } else if x == z {
    expr2
  } else {
    expr3
  }
  // end conditional expressions 1
}

fn c() -> Unit {
  let size = 0
  // start conditional expressions 3
  let initial = if size < 1 { 1 } else { size }
  // end conditional expressions 3
}

test "while loop 1" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start while loop 1
  let mut i = 5
  while i > 0 {
    println(i)
    i = i - 1
  }
  // end while loop 1
  t.snapshot!(filename="while_loop_1")
}

test "while loop 2" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start while loop 2
  let mut i = 5
  while i > 0 {
    i = i - 1
    if i == 4 {
      continue
    }
    if i == 1 {
      break
    }
    println(i)
  }
  // end while loop 2
  t.snapshot!(filename="while_loop_2")
}

test "while loop 3" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start while loop 3
  let mut i = 2
  while i > 0 {
    println(i)
    i = i - 1
  } else {
    println(i)
  }
  // end while loop 3
  t.snapshot!(filename="while_loop_3")
}

test "while loop 4" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start while loop 4
  let mut i = 10
  let r = while i > 0 {
    i = i - 1
    if i % 2 == 0 {
      break 5
    }
  } else {
    7
  }
  println(r)
  // end while loop 4
  t.snapshot!(filename="while_loop_4")
}

test "while loop 5" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start while loop 5
  let mut i = 10
  let r = while i > 0 {
    i = i - 1
  } else {
    7
  }
  println(r)
  // end while loop 5
  t.snapshot!(filename="while_loop_5")
}

test "for loop 1" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start for loop 1
  for i = 0; i < 5; i = i + 1 {
    println(i)
  }
  // end for loop 1
  t.snapshot!(filename="for_loop_1")
}

fn d() -> Unit {
  // start for loop 2
  for i = 0, j = 0; i + j < 100; i = i + 1, j = j + 1 {
    println(i)
  }
  // end for loop 2
}

fn infinite_loop() -> Unit {
  // start for loop 3
  for i = 1; ; i = i + 1 {
    println(i)
  }
  for {
    println("loop forever")
  }
  // end for loop 3
}

test "for loop 4" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start for loop 4
  let sum = for i = 1, acc = 0; i <= 6; i = i + 1 {
    if i % 2 == 0 {
      println("even: \{i}")
      continue i + 1, acc + i
    }
  } else {
    acc
  }
  println(sum)
  // end for loop 4
  t.snapshot!(filename="for_loop_4")
}

fn e() -> Unit {
  // start for loop 5
  for x in [1, 2, 3] {
    println(x)
  }
  // end for loop 5
  // start for loop 6
  for k, v in { "x": 1, "y": 2, "z": 3 } {
    println(k)
    println(v)
  }
  // end for loop 6
  // start for loop 7
  for index, elem in [4, 5, 6] {
    let i = index + 1
    println("The \{i}-th element of the array is \{elem}")
  }
  // end for loop 7
}

test "for loop 7" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start for loop 7
  for index, elem in [4, 5, 6] {
    let i = index + 1
    println("The \{i}-th element of the array is \{elem}")
  }
  // end for loop 7
  t.snapshot!(filename="for_loop_7")
}

test "for loop 8" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start for loop 8
  let map = { "x": 1, "y": 2, "z": 3, "w": 4 }
  for k, v in map {
    if k == "y" {
      continue
    }
    println("\{k}, \{v}")
    if k == "z" {
      break
    }
  }
  // end for loop 8
  t.snapshot!(filename="for_loop_8")
}

// start for loop 9
test {
  fn sum(xs : @immut/list.T[Int]) -> Int {
    loop xs, 0 {
      Nil, acc => break acc // <=> Nil, acc => acc
      Cons(x, rest), acc => continue rest, x + acc
    }
  }

  assert_eq!(sum(Cons(1, Cons(2, Cons(3, Nil)))), 6)
}
// end for loop 9

// start for loop 10
test {
  let mut i = 0
  for j in 0..<10 {
    i += j
  }
  assert_eq!(i, 45)
  let mut k = 0
  for l in 0..=10 {
    k += l
  }
  assert_eq!(k, 55)
}
// end for loop 10

// start loop label
test "break label" {
  let mut count = 0
  let xs = [1, 2, 3]
  let ys = [4, 5, 6]
  let res = outer~: for i in xs {
    for j in ys {
      count = count + i
      break outer~ j
    }
  } else {
    -1
  }
  assert_eq!(res, 4)
  assert_eq!(count, 1)
}

test "continue label" {
  let mut count = 0
  let init = 10
  let res =outer~: loop init {
    0 => 42
    i => {
      for {
        count = count + 1
        continue outer~ i - 1
      }
    }
  }
  assert_eq!(res, 42)
  assert_eq!(count, 10)
}
// end loop label

// start guard 1
fn guarded_get(array : Array[Int], index : Int) -> Int? {
  guard index >= 0 && index < array.length() else { None }
  Some(array[index])
}

test {
  inspect!(guarded_get([1, 2, 3], -1), content="None")
}
// end guard 1

fn process(string : String) -> String {
  string
}

// start guard 2
enum Resource {
  Folder(Array[String])
  PlainText(String)
  JsonConfig(Json)
}

fn getProcessedText(
  resources : Map[String, Resource],
  path : String
) -> String!Error {
  guard resources[path] is Some(resource) else {
    fail!("\{path} not found")
  }
  guard resource is PlainText(text) else {
    fail!("\{path} is not plain text")
  }
  process(text)
}
// end guard 2

fn g() -> Unit {
  let condition = true
  let expr = Some(5)
  // start guard 3
  guard condition  // <=> guard condition else { panic() }
  guard expr is Some(x)
  // <=> guard expr is Some(x) else { _ => panic() }
  // end guard 3
}

// start match 1
fn decide_sport(weather : String, humidity : Int) -> String {
  match weather {
    "sunny" => "tennis"
    "rainy" => if humidity > 80 { "swimming" } else { "football" }
    _ => "unknown"
  }
}

test {
  assert_eq!(decide_sport("sunny", 0), "tennis")
}
// end match 1


================================================
File 514: /data/input/moonbit-docs/next/sources/language/src/data/top.mbt
================================================
// start struct 1
struct User {
  id : Int
  name : String
  mut email : String
}
// end struct 1

test "struct 1" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start struct 2
  let u = User::{ id: 0, name: "John Doe", email: "john@doe.com" }
  u.email = "john@doe.name"
  //! u.id = 10
  println(u.id)
  println(u.name)
  println(u.email)
  // end struct 2
  t.snapshot!(filename="struct_1")
}

let struct_3 : Unit = {
  // start struct 3
  let name = "john"
  let email = "john@doe.com"
  let u = User::{ id: 0, name, email }
  // end struct 3
  // start struct 5
  let u2 = { id : 0, name, email }
  // end struct 5
}

test "struct 4" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start struct 4
  let user = { id: 0, name: "John Doe", email: "john@doe.com" }
  let updated_user = { ..user, email: "john@doe.name" }
  println(
    $|{ id: \{user.id}, name: \{user.name}, email: \{user.email} }
    $|{ id: \{updated_user.id}, name: \{updated_user.name}, email: \{updated_user.email} }
    ,
  )
  // end struct 4
  t.snapshot!(filename="struct_4")
}

// start enum 1
/// An enum type that represents the ordering relation between two values,
/// with three cases "Smaller", "Greater" and "Equal"
enum Relation {
  Smaller
  Greater
  Equal
}
// end enum 1

test "enum 3" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start enum 2
  /// compare the ordering relation between two integers
  fn compare_int(x : Int, y : Int) -> Relation {
    if x < y {
      // when creating an enum, if the target type is known, 
      // you can write the constructor name directly
      Smaller
    } else if x > y {
      // but when the target type is not known,
      // you can always use `TypeName::Constructor` to create an enum unambiguously
      Relation::Greater
    } else {
      Equal
    }
  }

  /// output a value of type `Relation`
  fn print_relation(r : Relation) -> Unit {
    // use pattern matching to decide which case `r` belongs to
    match r {
      // during pattern matching, if the type is known, 
      // writing the name of constructor is sufficient
      Smaller => println("smaller!")
      // but you can use the `TypeName::Constructor` syntax 
      // for pattern matching as well
      Relation::Greater => println("greater!")
      Equal => println("equal!")
    }
  }
  // end enum 2
  // start enum 3
  print_relation(compare_int(0, 1))
  print_relation(compare_int(1, 1))
  print_relation(compare_int(2, 1))
  // end enum 3
  t.snapshot!(filename="enum_3")
}

// start enum 4
enum List {
  Nil
  // constructor `Cons` carries additional payload: the first element of the list,
  // and the remaining parts of the list
  Cons(Int, List)
}
// end enum 4

test "enum 6" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start enum 5
  // In addition to binding payload to variables,
  // you can also continue matching payload data inside constructors.
  // Here's a function that decides if a list contains only one element
  fn is_singleton(l : List) -> Bool {
    match l {
      // This branch only matches values of shape `Cons(_, Nil)`, 
      // i.e. lists of length 1
      Cons(_, Nil) => true
      // Use `_` to match everything else
      _ => false
    }
  }

  fn print_list(l : List) -> Unit {
    // when pattern-matching an enum with payload,
    // in additional to deciding which case a value belongs to
    // you can extract the payload data inside that case
    match l {
      Nil => println("nil")
      // Here `x` and `xs` are defining new variables 
      // instead of referring to existing variables,
      // if `l` is a `Cons`, then the payload of `Cons` 
      // (the first element and the rest of the list)
      // will be bind to `x` and `xs
      Cons(x, xs) => {
        println("\{x},")
        print_list(xs)
      }
    }
  }
  // end enum 5
  // start enum 6
  // when creating values using `Cons`, the payload of by `Cons` must be provided
  let l : List = Cons(1, Cons(2, Nil))
  println(is_singleton(l))
  print_list(l)
  // end enum 6
  t.snapshot!(filename="enum_6")
}

// start enum 7
enum E {
  // `x` and `y` are labelled argument
  C(x~ : Int, y~ : Int)
}
// end enum 7

test "enum 9" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start enum 8
  // pattern matching constructor with labelled arguments
  fn f(e : E) -> Unit {
    match e {
      // `label=pattern`
      C(x=0, y=0) => println("0!")
      // `x~` is an abbreviation for `x=x`
      // Unmatched labelled arguments can be omitted via `..`
      C(x~, ..) => println(x)
    }
  }
  // end enum 8
  // start enum 9
  f(C(x=0, y=0))
  let x = 0
  f(C(x~, y=1)) // <=> C(x=x, y=1)
  // end enum 9
  t.snapshot!(filename="enum_9")
}

// start enum 10
enum Object {
  Point(x~ : Double, y~ : Double)
  Circle(x~ : Double, y~ : Double, radius~ : Double)
}

type! NotImplementedError  derive(Show)

fn distance_with(self : Object, other : Object) -> Double!NotImplementedError {
  match (self, other) {
    // For variables defined via `Point(..) as p`,
    // the compiler knows it must be of constructor `Point`,
    // so you can access fields of `Point` directly via `p.x`, `p.y` etc.
    (Point(_) as p1, Point(_) as p2) => {
      let dx = p2.x - p1.x
      let dy = p2.y - p1.y
      (dx * dx + dy * dy).sqrt()
    }
    (Point(_), Circle(_)) | (Circle(_), Point(_)) | (Circle(_), Circle(_)) =>
      raise NotImplementedError
  }
}
// end enum 10

test "enum 11" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start enum 11
  let p1 : Object = Point(x=0, y=0)
  let p2 : Object = Point(x=3, y=4)
  let c1 : Object = Circle(x=0, y=0, radius=2)
  try {
    println(p1.distance_with!(p2))
    println(p1.distance_with!(c1))
  } catch {
    e => println(e)
  }
  // end enum 11
  t.snapshot!(filename="enum_11")
}

// start enum 12
// A set implemented using mutable binary search tree.
struct Set[X] {
  mut root : Tree[X]
}

fn Set::insert[X : Compare](self : Set[X], x : X) -> Unit {
  self.root = self.root.insert(x, parent=Nil)
}

// A mutable binary search tree with parent pointer
enum Tree[X] {
  Nil
  // only labelled arguments can be mutable
  Node(
    mut value~ : X,
    mut left~ : Tree[X],
    mut right~ : Tree[X],
    mut parent~ : Tree[X]
  )
}

// In-place insert a new element to a binary search tree.
// Return the new tree root
fn Tree::insert[X : Compare](
  self : Tree[X],
  x : X,
  parent~ : Tree[X]
) -> Tree[X] {
  match self {
    Nil => Node(value=x, left=Nil, right=Nil, parent~)
    Node(_) as node => {
      let order = x.compare(node.value)
      if order == 0 {
        // mutate the field of a constructor
        node.value = x
      } else if order < 0 {
        // cycle between `node` and `node.left` created here
        node.left = node.left.insert(x, parent=node)
      } else {
        node.right = node.right.insert(x, parent=node)
      }
      // The tree is non-empty, so the new root is just the original tree
      node
    }
  }
}
// end enum 12

// start newtype 1
// `UserId` is a fresh new type different from `Int`, 
// and you can define new methods for `UserId`, etc.
// But at the same time, the internal representation of `UserId` 
// is exactly the same as `Int`
type UserId Int

type UserName String
// end newtype 1

test "newtype 2" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start newtype 2
  let id : UserId = UserId(1)
  let name : UserName = UserName("John Doe")
  let UserId(uid) = id // uid : Int
  let UserName(uname) = name // uname: String
  println(uid)
  println(uname)
  // end newtype 2
  t.snapshot!(filename="newtype_2")
}

test "newtype 3" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start newtype 3
  let id : UserId = UserId(1)
  let uid : Int = id._
  println(uid)
  // end newtype 3
  t.snapshot!(filename="newtype_3")
}

// start typealias 1
pub typealias Index = Int

// type alias are private by default
typealias MapString[X] = Map[String, X]
// end typealias 1

// start local-type 1
fn toplevel[T: Show](x: T) -> Unit {
  enum LocalEnum {
    A(T)
    B(Int)
  } derive(Show)
  struct LocalStruct {
    a: (String, T)
  } derive(Show)
  type LocalNewtype T derive(Show)
  ...
}
// end local-type 1

================================================
File 515: /data/input/moonbit-docs/next/sources/language/src/derive/default.mbt
================================================
// start derive default struct
struct DeriveDefault {
  x : Int
  y : Option[String]
} derive(Default, Eq, Show)

test "derive default struct" {
  let p = DeriveDefault::default()
  assert_eq!(p, DeriveDefault::{ x: 0, y: None })
}
// end derive default struct

// start derive default enum
enum DeriveDefaultEnum {
  Case1(Int)
  Case2(label~ : String)
  Case3
} derive(Default, Eq, Show)

test "derive default enum" {
  assert_eq!(DeriveDefaultEnum::default(), DeriveDefaultEnum::Case3)
}
// end derive default enum

================================================
File 516: /data/input/moonbit-docs/next/sources/language/src/derive/eq_compare.mbt
================================================
// start derive eq_compare struct
struct DeriveEqCompare {
  x : Int
  y : Int
} derive(Eq, Compare)

test "derive eq_compare struct" {
  let p1 = DeriveEqCompare::{ x: 1, y: 2 }
  let p2 = DeriveEqCompare::{ x: 2, y: 1 }
  let p3 = DeriveEqCompare::{ x: 1, y: 2 }
  let p4 = DeriveEqCompare::{ x: 1, y: 3 }

  // Eq
  assert_eq!(p1 == p2, false)
  assert_eq!(p1 == p3, true)
  assert_eq!(p1 == p4, false)

  assert_eq!(p1 != p2, true)
  assert_eq!(p1 != p3, false)
  assert_eq!(p1 != p4, true)
  
  // Compare
  assert_eq!(p1 < p2, true)
  assert_eq!(p1 < p3, false)
  assert_eq!(p1 < p4, true)
  assert_eq!(p1 > p2, false)
  assert_eq!(p1 > p3, false)
  assert_eq!(p1 > p4, false)
  assert_eq!(p1 <= p2, true)
  assert_eq!(p1 >= p2, false)
}
// end derive eq_compare struct

// start derive eq_compare enum
enum DeriveEqCompareEnum {
  Case1(Int)
  Case2(label~ : String)
  Case3
} derive(Eq, Compare)

test "derive eq_compare enum" {
  let p1 = DeriveEqCompareEnum::Case1(42)
  let p2 = DeriveEqCompareEnum::Case1(43)
  let p3 = DeriveEqCompareEnum::Case1(42)
  let p4 = DeriveEqCompareEnum::Case2(label="hello")
  let p5 = DeriveEqCompareEnum::Case2(label="world")
  let p6 = DeriveEqCompareEnum::Case2(label="hello")
  let p7 = DeriveEqCompareEnum::Case3

  // Eq
  assert_eq!(p1 == p2, false)
  assert_eq!(p1 == p3, true)
  assert_eq!(p1 == p4, false)

  assert_eq!(p1 != p2, true)
  assert_eq!(p1 != p3, false)
  assert_eq!(p1 != p4, true)

  // Compare
  assert_eq!(p1 < p2, true) // 42 < 43
  assert_eq!(p1 < p3, false)
  assert_eq!(p1 < p4, true) // Case1 < Case2
  assert_eq!(p4 < p5, true)
  assert_eq!(p4 < p6, false)
  assert_eq!(p4 < p7, true) // Case2 < Case3
}
// end derive eq_compare enum

================================================
File 517: /data/input/moonbit-docs/next/sources/language/src/derive/hash.mbt
================================================
// start derive hash struct
struct DeriveHash {
  x : Int
  y : Option[String]
} derive(Hash, Eq, Show)

test "derive hash struct" {
  let hs = @hashset.new()
  hs.add(DeriveHash::{x: 123, y: None})
  hs.add(DeriveHash::{x: 123, y: None})
  assert_eq!(hs.size(), 1)
  hs.add(DeriveHash::{x: 123, y: Some("456")})
  assert_eq!(hs.size(), 2)
}
// end derive hash struct

================================================
File 518: /data/input/moonbit-docs/next/sources/language/src/derive/json.mbt
================================================
// start json basic
struct JsonTest1 {
  x: Int
  y: Int
} derive(FromJson, ToJson, Eq, Show)

enum JsonTest2 {
  A(x~: Int)
  B(x~: Int, y~: Int)
} derive(FromJson, ToJson, Eq, Show)

test "json basic"{
  let input = JsonTest1::{ x: 123, y: 456 }
  let expected: Json = { "x": 123, "y": 456 }
  assert_eq!(input.to_json(), expected)
  assert_eq!(@json.from_json!(expected), input)

  let input = JsonTest2::A(x=123)
  let expected: Json = { "$tag": "A", "x": 123 }
  assert_eq!(input.to_json(), expected)
  assert_eq!(@json.from_json!(expected), input)
}
// end json basic

// start json args
struct JsonTest3 {
  x: Int
  y: Int
} derive(
  FromJson(fields(x(rename = "renamedX"))), 
  ToJson(fields(x(rename = "renamedX"))),
  Eq, Show
)

enum JsonTest4 {
  A(x~: Int)
  B(x~: Int, y~: Int)
} derive(
  FromJson(rename_fields = "SCREAMING_SNAKE_CASE", repr(ext_tagged)),
  ToJson(rename_fields = "SCREAMING_SNAKE_CASE", repr(ext_tagged)),
  Eq, Show
)

test "json args"{
  let input = JsonTest3::{ x: 123, y: 456 }
  let expected: Json = { "renamedX": 123, "y": 456 }
  assert_eq!(input.to_json(), expected)
  assert_eq!(@json.from_json!(expected), input)

  let input = JsonTest4::A(x=123)
  let expected: Json = { "A": { "X": 123 } }
  assert_eq!(input.to_json(), expected)
  assert_eq!(@json.from_json!(expected), input)
}
// end json args



================================================
File 519: /data/input/moonbit-docs/next/sources/language/src/derive/show.mbt
================================================
// start derive show struct
struct MyStruct {
  x : Int
  y : Int
} derive(Show)

test "derive show struct" {
  let p = MyStruct::{ x: 1, y: 2 }
  assert_eq!(Show::to_string(p), "{x: 1, y: 2}")
}
// end derive show struct

// start derive show enum
enum MyEnum {
  Case1(Int)
  Case2(label~ : String)
  Case3
} derive(Show)

test "derive show enum" {
  assert_eq!(Show::to_string(MyEnum::Case1(42)), "Case1(42)")
  assert_eq!(Show::to_string(MyEnum::Case2(label="hello")), "Case2(label=\"hello\")")
  assert_eq!(Show::to_string(MyEnum::Case3), "Case3")
}
// end derive show enum

================================================
File 520: /data/input/moonbit-docs/next/sources/language/src/error/top.mbt
================================================
// start error 1
type! E1 Int // error type E1 has one constructor E1 with an Int payload

type! E2  // error type E2 has one constructor E2 with no payload

type! E3 { // error type E3 has three constructors like a normal enum type
  A
  B(Int, x~ : String)
  C(mut x~ : String, Char, y~ : Bool)
}
// end error 1

// start error 2
type! DivError String

fn div(x : Int, y : Int) -> Int!DivError {
  if y == 0 {
    raise DivError("division by zero")
  }
  x / y
}
// end error 2

impl Show for DivError with output(self, logger) {
  match self {
    DivError(e) => Show::output(e, logger)
  }
}

let signature : Unit = {
  // start error 3
  fn f() -> Unit! {
    ...
  }

  fn g!() -> Unit {
    ...
  }

  fn h() -> Unit!Error {
    ...
  }
  // end error 3

}

// start error 4
type! IntError Int

fn h(f : (Int) -> Int!, x : Int) -> Unit {
  ...
}

fn g() -> Unit {
  let _ = h(fn! { x => raise IntError(x) }, 0)
  let _ = h(fn!(x) { raise IntError(x) }, 0)

}
// end error 4

// start error 5
// Result::unwrap_or_error
fn unwrap_or_error[T, E : Error](result : Result[T, E]) -> T!E {
  match result {
    Ok(x) => x
    Err(e) => raise e
  }
}
// end error 5

test {
  (Ok(1) : Result[Int, Error]).unwrap_or_error!() |> ignore
}

// start error 6
type! E4

type! E5

fn f(e : Error) -> Unit {
  match e {
    E4 => println("E1")
    E5 => println("E2")
    _ => println("unknown error")
  }
}
// end error 6

// start error 7
fn div_reraise(x : Int, y : Int) -> Int!DivError {
  div!(x, y) // Rethrow the error if `div` raised an error
}
// end error 7

// start error 8
test {
  let res = div?(6, 3)
  inspect!(res, content="Ok(2)")
  let res = div?(6, 0)
  inspect!(
    res,
    content=
      #|Err("division by zero")
    ,
  )
}
// end error 8

test "error 9" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start error 9
  try {
    div!(42, 0)
  } catch {
    DivError(s) => println(s)
  } else {
    v => println(v)
  }
  // end error 9
  t.snapshot!(filename="error_9")
}

fn error() -> Unit {
  // start error 10
  try {
    println(div!(42, 0))
  } catch {
    _ => println("Error")
  }
  // end error 10

  // start error 11
  let a = try {
    div!(42, 0)
  } catch {
    _ => 0
  }
  println(a)
  // end error 11
}

// start error 12
type T Int

type! E Int derive(Show)

fn k(self : T) -> Unit!E {
  ...
}

fn l() -> Unit!E {
  let x = T(42)
  k!(x)
  x.k!()
  x |> k!()
}
// end error 12

fn catch_() -> Unit! {
  // start error 13
  fn f1() -> Unit!E1 {
    ...
  }

  fn f2() -> Unit!E2 {
    ...
  }

  try {
    f1!()
    f2!()
  } catch {
    E1(_) => ...
    E2 => ...
    _ => ...
  }
  // end error 13
  // start error 14
  try {
    f1!()
    f2!()
  } catch! {
    E1(_) => ...
  }
  // end error 14
}


================================================
File 521: /data/input/moonbit-docs/next/sources/language/src/functions/top.mbt
================================================
// start expression
fn foo() -> Int {
  let x = 1
  x + 1
}

fn bar() -> Int {
  let x = 1
  //! x + 1
  x + 2
}
// end expression

// start top-level functions
fn add3(x : Int, y : Int, z : Int) -> Int {
  x + y + z
}
// end top-level functions

// start function application 1
test {
  let add3 = fn(x, y, z) { x + y + z }
  assert_eq!(add3(1, 2, 7), 10)
}
// end function application 1

// start function application 2
test {
  let f = fn(x) { x + 1 }
  let g = fn(x) { x + 2 }
  let w = (if true { f } else { g })(3)
  assert_eq!(w, 4)
}
// end function application 2

// start local functions 1
fn local_1() -> Int {
  fn inc(x) { // named as `inc`
    x + 1
  }
  // anonymous, instantly applied to integer literal 6
  (fn(x) { x + inc(2) })(6)
}

test {
  assert_eq!(local_1(), 9)
}
// end local functions 1

// start local functions 2
let global_y = 3

fn local_2(x : Int) -> (Int, Int) {
  fn inc() {
    x + 1
  }

  fn four() {
    global_y + 1
  }

  (inc(), four())
}

test {
  assert_eq!(local_2(3), (4, 4))
}
// end local functions 2

// start local functions 3
let extract : (Int?, Int) -> Int = fn {
  Some(x), _ => x
  None, default => default
}
// end local functions 3

// start labelled arguments 1
fn labelled_1(arg1~ : Int, arg2~ : Int) -> Int {
  arg1 + arg2
}
// end labelled arguments 1

// start labelled arguments 2
test {
  let arg1 = 1
  assert_eq!(labelled_1(arg2=2, arg1~), 3)
}
// end labelled arguments 2

// start optional arguments 1
fn optional(opt~ : Int = 42) -> Int {
  opt
}

test {
  assert_eq!(optional(), 42)
  assert_eq!(optional(opt=0), 0)
}
// end optional arguments 1

// start optional arguments 2
fn incr(counter~ : Ref[Int] = { val: 0 }) -> Ref[Int] {
  counter.val = counter.val + 1
  counter
}

test {
  inspect!(incr(), content="{val: 1}")
  inspect!(incr(), content="{val: 1}")
  let counter : Ref[Int] = { val: 0 }
  inspect!(incr(counter~), content="{val: 1}")
  inspect!(incr(counter~), content="{val: 2}")
}
// end optional arguments 2

// start optional arguments 3
let default_counter : Ref[Int] = { val: 0 }

fn incr_2(counter~ : Ref[Int] = default_counter) -> Int {
  counter.val = counter.val + 1
  counter.val
}

test {
  assert_eq!(incr_2(), 1)
  assert_eq!(incr_2(), 2)
}
// end optional arguments 3

// start optional arguments 4
fn sub_array[X](
  xs : Array[X],
  offset~ : Int,
  len~ : Int = xs.length() - offset
) -> Array[X] {
  xs[offset:offset + len].iter().to_array()
}

test {
  assert_eq!(sub_array([1, 2, 3], offset=1), [2, 3])
  assert_eq!(sub_array([1, 2, 3], offset=1, len=1), [2])
}
// end optional arguments 4

struct Image {
  width : Int
  height : Int
}

// start optional arguments 5
fn ugly_constructor(width~ : Int? = None, height~ : Int? = None) -> Image {
  ...
}

let img : Image = ugly_constructor(width=Some(1920), height=Some(1080))
// end optional arguments 5

// start optional arguments 6
fn nice_constructor(width? : Int, height? : Int) -> Image {
  ...
}

let img2 : Image = nice_constructor(width=1920, height=1080)
// end optional arguments 6

// start optional arguments 7
fn image(width? : Int, height? : Int) -> Image {
  ...
}

fn fixed_width_image(height? : Int) -> Image {
  image(width=1920, height?)
}
// end optional arguments 7

// start autofill arguments
fn f(_x : Int, loc~ : SourceLoc = _, args_loc~ : ArgsLoc = _) -> String {
  $|loc of whole function call: \{loc}
  $|loc of arguments: \{args_loc}
  // loc of whole function call: <filename>:7:3-7:10
  // loc of arguments: [Some(<filename>:7:5-7:6), Some(<filename>:7:8-7:9), None, None]
}
// end autofill arguments


================================================
File 522: /data/input/moonbit-docs/next/sources/language/src/generics/top.mbt
================================================
enum List[T] {
  Nil
  Cons(T, List[T])
}

fn map[S, T](self : List[S], f : (S) -> T) -> List[T] {
  match self {
    Nil => Nil
    Cons(x, xs) => Cons(f(x), map(xs, f))
  }
}

fn reduce[S, T](self : List[S], op : (T, S) -> T, init : T) -> T {
  match self {
    Nil => init
    Cons(x, xs) => reduce(xs, op, op(init, x))
  }
}


================================================
File 523: /data/input/moonbit-docs/next/sources/language/src/is/top.mbt
================================================
// start is 1
fn is_none[T](x : T?) -> Bool {
  x is None
}

fn start_with_lower_letter(s: String) -> Bool {
  s is ['a'..='z', ..]
}
// end is 1

// start is 2
fn f(x : Int?) -> Bool {
  x is Some(v) && v >= 0
}
// end is 2

// start is 3
fn g(x : Array[Int?]) -> Unit {
  if x is [v, .. rest] && v is Some(i) && i is 0..=10 {
    println(v)
    println(i)
    println(rest)
  }
}
// end is 3

// start is 4
fn h(x : Int?) -> Unit {
  guard x is Some(v) 
  println(v)
}
// end is 4

// start is 5
fn i(x : Int?) -> Unit {
  let mut m = x
  while m is Some(v) {
    println(v)
    m = None
  }
}
// end is 5


================================================
File 524: /data/input/moonbit-docs/next/sources/language/src/iter/top.mbt
================================================
// start iter 1
///|
fn filter_even(l : Array[Int]) -> Array[Int] {
  let l_iter : Iter[Int] = l.iter()
  l_iter.filter(fn { x => (x & 1) == 0 }).collect()
}

///|
fn fact(n : Int) -> Int {
  let start = 1
  let range : Iter[Int] = start.until(n)
  range.fold(Int::op_mul, init=start)
}
// end iter 1

// start iter 2
///|
fn iter(data : Bytes) -> Iter[Byte] {
  Iter::new(fn(visit : (Byte) -> IterResult) -> IterResult {
    for byte in data {
      guard visit(byte) is IterContinue else { break IterEnd }

    } else {
      IterContinue
    }
  })
}
// end iter 2


================================================
File 525: /data/input/moonbit-docs/next/sources/language/src/main/top.mbt
================================================
// start init
fn init {
  let x = 1
  println(x)
}
// end init

// start main
fn main {
  let x = 2
  println(x)
}
// end main

================================================
File 526: /data/input/moonbit-docs/next/sources/language/src/method/top.mbt
================================================
// start method 1
pub(all) enum List[X] {
  Nil
  Cons(X, List[X])
}

pub fn concat[X](self : List[List[X]]) -> List[X] {
  ...
}
// end method 1

// start method overload example
struct T1 {
  x1 : Int
}

fn T1::default() -> T1 {
  { x1: 0 }
}

struct T2 {
  x2 : Int
}

fn T2::default() -> T2 {
  { x2: 0 }
}

test {
  let t1 = T1::default()
  let t2 = T2::default()

}
// end method overload example


================================================
File 527: /data/input/moonbit-docs/next/sources/language/src/method2/top.mbt
================================================
// start method declaration example
enum List[X] {
  Nil
  Cons(X, List[X])
}

fn length[X](self : List[X]) -> Int {
  ...
}

fn List::length_qualified[X](xs : List[X]) -> Int {
  ...
}
// end method declaration example

fn _call_syntax_example() -> Unit {
// start method call syntax example
  let l : List[Int] = Nil
  println(length(l))
  println(List::length_qualified(l))
// end method call syntax example
}

fn f() -> Unit {
  let xs : @list.List[@list.List[Unit]] = Nil
// start dot syntax example
  // assume `xs` is a list of lists, all the following three lines are equivalent
  let _ = xs.concat()
  let _ = @list.List::concat(xs)
  let _ = @list.concat(xs)
// end dot syntax example
}


================================================
File 528: /data/input/moonbit-docs/next/sources/language/src/misc/top.mbt
================================================
// start doc string 1
/// Return a new array with reversed elements.
///
/// # Example
///
/// ```
/// reverse([1,2,3,4]) |> println()
/// ```
fn reverse[T](xs : Array[T]) -> Array[T] {
  ...
}
// end doc string 1

// start todo 1
fn todo_in_func() -> Int {
  ...
}
// end todo 1


================================================
File 529: /data/input/moonbit-docs/next/sources/language/src/operator/top.mbt
================================================
// start operator 1
struct T {
  x : Int
}

fn op_add(self : T, other : T) -> T {
  { x: self.x + other.x }
}

test {
  let a = { x: 0 }
  let b = { x: 2 }
  assert_eq!((a + b).x, 2)
}
// end operator 1

// start operator 2
struct Coord {
  mut x : Int
  mut y : Int
} derive(Show)

fn op_get(self : Coord, key : String) -> Int {
  match key {
    "x" => self.x
    "y" => self.y
  }
}

fn op_set(self : Coord, key : String, val : Int) -> Unit {
  match key {
    "x" => self.x = val
    "y" => self.y = val
  }
}
// end operator 2

test "operator 3" (t : @test.T) {
  let println = fn(show) { t.writeln(show) }
  // start operator 3
  let c = { x: 1, y: 2 }
  println(c)
  println(c["y"])
  c["x"] = 23
  println(c)
  println(c["x"])
  // end operator 3
  t.snapshot!(filename="operator_3")
}

fn add(i : Int, j : Int) -> Int {
  i + j
}

fn pipe() -> Unit {
  // start operator 4
  5 |> ignore // <=> ignore(5)
  [] |> Array::push(5) // <=> Array::push([], 5)
  1
  |> add(5) // <=> add(1, 5)
  |> ignore // <=> ignore(add(1, 5))
  // end operator 4
}

trait Ignore {
  f(Self) -> Unit
}

impl Ignore for Unit with f(u) { u }

fn cascade() -> Unit {
  let x : Unit = ()
  // start operator 5
  x..f()
  // end operator 5
  // start operator 6
  let builder = StringBuilder::new()
  builder.write_char('a')
  builder.write_char('a')
  builder.write_object(1001)
  builder.write_string("abcdef")
  let result = builder.to_string()
  // end operator 6

  // start operator 7
  let result = StringBuilder::new()
    ..write_char('a')
    ..write_char('a')
    ..write_object(1001)
    ..write_string("abcdef")
    .to_string()
  // end operator 7

}

fn land(self : T, other : T) -> T {
  { x: self.x & other.x }
}

fn lor(self : T, other : T) -> T {
  { x: self.x | other.x }
}

fn lxor(self : T, other : T) -> T {
  { x: self.x ^ other.x }
}

fn op_shl(self : T, other : Int) -> T {
  { x: self.x << other }
}

fn op_shr(self : T, other : Int) -> T {
  { x: self.x >> other }
}

test {
  let a = { x: 0b1010 }
  let b = { x: 0b1100 }
  assert_eq!((a & b).x, 0b1000)
  assert_eq!((a | b).x, 0b1110)
  assert_eq!((a ^ b).x, 0b0110)
  assert_eq!((a << 2).x, 0b101000)
  assert_eq!((b >> 2).x, 0b11)
}

// start view 1
test {
  let xs = [0, 1, 2, 3, 4, 5]
  let s1 : ArrayView[Int] = xs[2:]
  inspect!(s1, content="[2, 3, 4, 5]")
  inspect!(xs[:4], content="[0, 1, 2, 3]")
  inspect!(xs[2:5], content="[2, 3, 4]")
  inspect!(xs[:], content="[0, 1, 2, 3, 4, 5]")
}
// end view 1

// start view 2
type DataView String

struct Data {}

fn Data::op_as_view(_self : Data, start~ : Int = 0, end? : Int) -> DataView {
  "[\{start}, \{end.or(100)})"
}

test {
  let data = Data::{  }
  inspect!(data[:]._, content="[0, 100)")
  inspect!(data[2:]._, content="[2, 100)")
  inspect!(data[:5]._, content="[0, 5)")
  inspect!(data[2:5]._, content="[2, 5)")
}
// end view 2


================================================
File 530: /data/input/moonbit-docs/next/sources/language/src/packages/pkgA/top.mbt
================================================
pub fn incr(x : Int) -> Int {
  x + 1
}

================================================
File 531: /data/input/moonbit-docs/next/sources/language/src/packages/pkgB/top.mbt
================================================
pub fn add1(x : Int) -> Int {
  @c.incr(@pkgA.incr(x))
}

================================================
File 532: /data/input/moonbit-docs/next/sources/language/src/packages/pkgC/top.mbt
================================================
pub fn incr(x : Int) -> Int {
  x + 1
}

================================================
File 533: /data/input/moonbit-docs/next/sources/language/src/pattern/top.mbt
================================================
struct User {
  id : String
  name : String
  email : String
}

let user : Unit = {
  let u = { id: "1", name: "John", email: "john@example.com" }
  // start pattern 1
  let id = match u {
    { id, name: _, email: _ } => id
  }

  // <=>
  let { id, name: _, email: _ } = u

  // <=>
  let { id, .. } = u
  // end pattern 1

}

// start pattern 2
test {
  let ary = [1, 2, 3, 4]
  if ary is [a, b, ..] && a == 1 && b == 2 {
    inspect!("a = \{a}, b = \{b}", content="a = 1, b = 2")
  } else {
    fail!("")
  }
  guard ary is [.., a, b] else { fail!("") }
  inspect!("a = \{a}, b = \{b}", content="a = 3, b = 4")
}
// end pattern 2

enum Arith {
  Lit(Int)
  Add(Arith, Arith)
  Mul(Arith, Arith)
}

fn eval(expr : Arith) -> Int {
  // start pattern 3
  match expr {
    //! Add(e1, e2) | Lit(e1) => ...
    Lit(n) as a => ...
    Add(e1, e2) | Mul(e1, e2) => ...
    _ => ...
  }
  // end pattern 3
}

// start pattern 4
const Zero = 0

fn sign(x : Int) -> Int {
  match x {
    _..<Zero => -1
    Zero => 0
    1..<_ => 1
  }
}

fn classify_char(c : Char) -> String {
  match c {
    'a'..='z' => "lowercase"
    'A'..='Z' => "uppercase"
    '0'..='9' => "digit"
    _ => "other"
  }
}
// end pattern 4

fn map() -> Unit {
  let map = { "a": 1 }
  // start pattern 5
  match map {
    // matches if any only if "b" exists in `map`
    { "b": _, .. } => ...
    // matches if and only if "b" does not exist in `map` and "a" exists in `map`.
    // When matches, bind the value of "a" in `map` to `x`
    { "b"? : None, "a": x, .. } => ...
    // compiler reports missing case: { "b"? : None, "a"? : None }
  }
  // end pattern 5
}

fn json() -> Unit {
  let json = Null
  // start pattern 6
  match json {
    { "version": "1.0.0", "import": [..] as imports, .. } => ...
    { "version": Number(i), "import": Array(imports), ..} => ...
    _ => ...
  }
  // end pattern 6
}

// start simple pattern 1
const ONE = 1

fn match_int(x : Int) -> Unit {
  match x {
    0 => println("zero")
    ONE => println("one")
    value => println(value)
  }
}
// end simple pattern 1

// start simple pattern 2
struct Point3D {
  x : Int
  y : Int
  z : Int
}

fn match_point3D(p : Point3D) -> Unit {
  match p {
    { x: 0, .. } => println("on yz-plane")
    _ => println("not on yz-plane")
  }
}

enum Point[T] {
  Point2D(Int, Int, name~: String, payload~ : T)
}

fn match_point[T](p : Point[T]) -> Unit {
  match p {
    //! Point2D(0, 0) => println("2D origin")
    Point2D(0, 0, ..) => println("2D origin")
    Point2D(_) => println("2D point")
    _ => panic()
  }
}
// end simple pattern 2


================================================
File 534: /data/input/moonbit-docs/next/sources/language/src/test/top.mbt
================================================
// start test 1
test "test_name" {
  assert_eq!(1 + 1, 2)
  assert_eq!(2 + 2, 4)
  inspect!([1, 2, 3], content="[1, 2, 3]")
}
// end test 1

// start test 2
test "panic_test" {
  let _ : Int = Option::None.unwrap()

}
// end test 2

// start snapshot test 1
struct X { x : Int } derive(Show)

test "show snapshot test" {
  inspect!({x: 10}, content="{x: 10}")
}
// end snapshot test 1

// start snapshot test 2
enum Rec {
  End
  Really_long_name_that_is_difficult_to_read(Rec)
} derive(Show, ToJson)

test "json snapshot test" {
  let r = Really_long_name_that_is_difficult_to_read(
    Really_long_name_that_is_difficult_to_read(
      Really_long_name_that_is_difficult_to_read(End),
    ),
  )
  inspect!(
    r,
    content="Really_long_name_that_is_difficult_to_read(Really_long_name_that_is_difficult_to_read(Really_long_name_that_is_difficult_to_read(End)))",
  )
  @json.inspect!(
    r,
    content={
      "$tag": "Really_long_name_that_is_difficult_to_read",
      "0": {
        "$tag": "Really_long_name_that_is_difficult_to_read",
        "0": {
          "$tag": "Really_long_name_that_is_difficult_to_read",
          "0": { "$tag": "End" },
        },
      },
    },
  )
}
// end snapshot test 2

// start snapshot test 3
test "record anything" (t : @test.T) {
  t.write("Hello, world!")
  t.writeln(" And hello, MoonBit!")
  t.snapshot!(filename="record_anything.txt")
}
// end snapshot test 3

================================================
File 535: /data/input/moonbit-docs/next/sources/language/src/trait/top.mbt
================================================
// start trait 1
pub(open) trait I {
  method_(Int) -> Int
  method_with_label(Int, label~: Int) -> Int
  //! method_with_label(Int, label?: Int) -> Int
}
// end trait 1

// start trait 2
pub(open) trait MyShow {
  to_string(Self) -> String
}

struct MyType {}

pub impl MyShow for MyType with to_string(self) { ... }

struct MyContainer[T] {}

// trait implementation with type parameters.
// `[X : Show]` means the type parameter `X` must implement `Show`,
// this will be covered later.
pub impl[X : MyShow] MyShow for MyContainer[X] with to_string(self) { ... }
// end trait 2

// start trait 3
pub(open) trait J {
  f(Self) -> Unit
  f_twice(Self) -> Unit
}

impl J with f_twice(self) {
  self.f()
  self.f()
}
// end trait 3

// start trait 5
fn contains[X : Eq](xs : Array[X], elem : X) -> Bool {
  for x in xs {
    if x == elem {
      return true
    }
  } else {
    false
  }
}
// end trait 5

// start trait 6
struct Point {
  x : Int
  y : Int
}

impl Eq for Point with op_equal(p1, p2) {
  p1.x == p2.x && p1.y == p2.y
}

test {
  assert_false!(contains([ 1, 2, 3 ], 4))
  assert_true!(contains([ 1.5, 2.25, 3.375 ], 2.25))
  assert_false!(contains([ { x: 2, y: 3 } ], { x: 4, y: 9 }))
}
// end trait 6

// start trait 7
test {
  assert_eq!(Show::to_string(42), "42")
  assert_eq!(Compare::compare(1.0, 2.5), -1)
}
// end trait 7

// start trait 8
struct MyCustomType {}

pub impl Show for MyCustomType with output(self, logger) { ... }

fn f() -> Unit {
  let x = MyCustomType::{  }
  let _ = x.to_string()

}
// end trait 8

// start trait 9
struct T {
  a : Int
  b : Int
} derive(Eq, Compare, Show, Default)

test {
  let t1 = T::default()
  let t2 = T::{ a: 1, b: 1 }
  inspect!(t1, content="{a: 0, b: 0}")
  inspect!(t2, content="{a: 1, b: 1}")
  assert_not_eq!(t1, t2)
  assert_true!(t1 < t2)
}
// end trait 9

// start super trait 1
pub(open) trait Position {
  pos(Self) -> (Int, Int)
}
pub(open) trait Draw {
  draw(Self) -> Unit
}

pub(open) trait Object : Position + Draw {}
// end super trait 1

// start trait object 1
pub(open) trait Animal {
  speak(Self) -> String
}

type Duck String

fn Duck::make(name : String) -> Duck {
  Duck(name)
}

impl Animal for Duck with speak(self) {
  "\{self._}: quack!"
}

type Fox String

fn Fox::make(name : String) -> Fox {
  Fox(name)
}

impl Animal for Fox with speak(_self) {
  "What does the fox say?"
}

test {
  let duck1 = Duck::make("duck1")
  let duck2 = Duck::make("duck2")
  let fox1 = Fox::make("fox1")
  let animals : Array[&Animal] = [ duck1, duck2, fox1 ]
  inspect!(
    animals.map(fn(animal) { animal.speak() }),
    content=
      #|["duck1: quack!", "duck2: quack!", "What does the fox say?"]
    ,
  )
}
// end trait object 1

// start trait object 2
pub(open) trait Logger {
  write_string(Self, String) -> Unit
}

pub(open) trait CanLog {
  log(Self, &Logger) -> Unit
}

fn &Logger::write_object[Obj : CanLog](self : &Logger, obj : Obj) -> Unit {
  obj.log(self)
}

// use the new method to simplify code
pub impl[A : CanLog, B : CanLog] CanLog for (A, B) with log(self, logger) {
  let (a, b) = self
  logger
  ..write_string("(")
  ..write_object(a)
  ..write_string(", ")
  ..write_object(b)
  .write_string(")")
}
// end trait object 2


================================================
File 536: /data/input/moonbit-docs/next/sources/language/src/variable/top.mbt
================================================
let zero = 0

const ZERO = 0

fn main {
  //! const ZERO = 0 
  let mut i = 10
  i = 20
  println(i + zero + ZERO)
}


================================================
File 537: /data/input/moonbit-docs/next/sources/segment-tree/README.md
================================================
# Segment Tree

Check `tutorial/example/segment-tree`.

================================================
File 538: /data/input/moonbit-docs/next/sources/segment-tree/src/part1/top.mbt
================================================
// start node definition
enum Node {
  Nil
  Node(Int, Node, Node)
}
// end node definition

impl ToJson for Node with to_json(self) {
  match self {
    Nil => "Nil"
    Node(value, left, right) => {
      let left_json = left.to_json()
      let right_json = right.to_json()
      [Number(value.to_double()), left_json, right_json]
    }
  }
}

// start op_add definition
fn op_add(self : Node, v : Node) -> Node {
  match (self, v) {
    (Node(left, _, _), Node(right, _, _)) => Node(left + right, self, v)
    (Node(_), Nil) => self
    (Nil, Node(_)) => v
    (Nil, Nil) => Nil
  }
}
// end op_add definition

// start build definition
fn build(data : ArrayView[Int]) -> Node {
  if data.length() == 1 {
    Node(data[0], Nil, Nil)
  } else {
    let mid = (data.length() + 1) >> 1
    build(data[0:mid]) + build(data[mid:])
  }
}
// end build definition

// start build test
test {
  let tree = build([1, 2, 3, 4, 5][:])
  @json.inspect!(
    tree,
    content=[
      15,
      [6, [3, [1, "Nil", "Nil"], [2, "Nil", "Nil"]], [3, "Nil", "Nil"]],
      [9, [4, "Nil", "Nil"], [5, "Nil", "Nil"]],
    ],
  )
}
// end build test

// start query definition
let empty_node : Node = Node(0, Nil, Nil)

fn query(self : Node, l : Int, r : Int, query_l : Int, query_r : Int) -> Node {
  if query_l > r || l > query_r {
    empty_node
  } else if query_l <= l && query_r >= r {
    self
  } else {
    guard self is Node(_, left, right)
    let mid = (l + r) >> 1
    left.query(l, mid, query_l, query_r) +
    right.query(mid + 1, r, query_l, query_r)
  }
}
// end query definition

// start query test

test {
  let tree = build([1, 2, 3, 4, 5][:])
  let sum = match tree.query(1, 5, 1, 3) {
    Node(sum, _, _) => sum
    _ => fail!("Expected Node")
  }
  inspect!(sum, content="6")
}
// end query test


================================================
File 539: /data/input/moonbit-docs/next/sources/segment-tree/src/part2/top.mbt
================================================
// start data definition
enum Data {
  Data(sum~ : Int, len~ : Int)
}

enum LazyTag {
  Nil
  Tag(Int)
}

enum Node {
  Nil
  Node(data~ : Data, tag~ : LazyTag, left~ : Node, right~ : Node)
}
// end data definition

impl ToJson for Data with to_json(data) {
  let Data(sum~, len~) = data
  [Number(sum.to_double()), Number(len.to_double())]
}

impl ToJson for LazyTag with to_json(tag) {
  match tag {
    Nil => "Nil"
    Tag(value) => Number(value.to_double())
  }
}

impl ToJson for Node with to_json(node) {
  match node {
    Nil => "Nil"
    Node(data~, tag~, left~, right~) => {
      let data_json = data.to_json()
      let tag_json = tag.to_json()
      let left_json = left.to_json()
      let right_json = right.to_json()
      {
        "data": data_json,
        "tag": tag_json,
        "left": left_json,
        "right": right_json,
      }
    }
  }
}

// start op_add definition
fn Data::op_add(self : Data, v : Data) -> Data {
  match (self, v) {
    (Data(sum=a, len=len_a), Data(sum=b, len=len_b)) =>
      Data(sum=a + b, len=len_a + len_b)
  }
}

fn Node::op_add(self : Node, v : Node) -> Node {
  match (self, v) {
    (Node(data=l, ..), Node(data=r, ..)) =>
      Node(data=l + r, tag=Nil, left=self, right=v)
    (Node(_), Nil) => self
    (Nil, Node(_)) => v
    (Nil, Nil) => Nil
  }
}
// end op_add definition

// start lazytag definition
fn LazyTag::op_add(self : LazyTag, v : LazyTag) -> LazyTag {
  match (self, v) {
    (Tag(a), Tag(b)) => Tag(a + b)
    (Nil, t) | (t, Nil) => t
  }
}

fn apply(self : Node, v : LazyTag) -> Node {
  match (self, v) {
    (Node(data=Data(sum=a, len=length), tag~, left~, right~), Tag(v) as new_tag) =>
      Node(
        data=Data(sum=a + v * length, len=length),
        tag=tag + new_tag,
        left~,
        right~,
      )
    (_, Nil) => self
    (Nil, _) => Nil
  }
}
// end lazytag definition

// start build definition
fn build(data : ArrayView[Int]) -> Node {
  if data.length() == 1 {
    Node(data=Data(sum=data[0], len=1), tag=Nil, left=Nil, right=Nil)
  } else {
    let mid = (data.length() + 1) >> 1
    build(data[0:mid]) + build(data[mid:])
  }
}
// end build definition

// start modify definition
fn modify(
  self : Node,
  l : Int,
  r : Int,
  modify_l : Int,
  modify_r : Int,
  tag : LazyTag
) -> Node {
  if modify_l > r || l > modify_r {
    self
  } else if modify_l <= l && modify_r >= r {
    self.apply(tag)
  } else {
    guard self is Node(left~, right~, ..)
    let mid = (l + r) >> 1
    left.modify(l, mid, modify_l, modify_r, tag) +
    right.modify(mid + 1, r, modify_l, modify_r, tag)
  }
}
// end modify definition

// start query definition
let empty_node : Node = Node(
  data=Data(sum=0, len=0),
  tag=Nil,
  left=Nil,
  right=Nil,
)

fn query(self : Node, l : Int, r : Int, query_l : Int, query_r : Int) -> Node {
  if query_l > r || l > query_r {
    empty_node
  } else if query_l <= l && query_r >= r {
    self
  } else {
    guard self is Node(tag~, left~, right~, ..)
    let mid = (l + r) >> 1
    left.apply(tag).query(l, mid, query_l, query_r) +
    right.apply(tag).query(mid + 1, r, query_l, query_r)
  }
}
// end query definition

test {
  let tree = build([1, 2, 3, 4, 5][:])
  @json.inspect!(
    tree.modify(1, 5, 1, 3, Tag(1)).query(1, 5, 1, 3),
    content={
      "data": [9, 3],
      "tag": "Nil",
      "left": {
        "data": [9, 3],
        "tag": 1,
        "left": {
          "data": [3, 2],
          "tag": "Nil",
          "left": {
            "data": [1, 1],
            "tag": "Nil",
            "left": "Nil",
            "right": "Nil",
          },
          "right": {
            "data": [2, 1],
            "tag": "Nil",
            "left": "Nil",
            "right": "Nil",
          },
        },
        "right": { "data": [3, 1], "tag": "Nil", "left": "Nil", "right": "Nil" },
      },
      "right": { "data": [0, 0], "tag": "Nil", "left": "Nil", "right": "Nil" },
    },
  )
}


================================================
File 540: /data/input/moonbit-docs/next/toolchain/index.md
================================================
# Toolchains

Here are some manuals that may help you use the toolchains of the programming language:

- [MoonBit's Build System](./moon/index.md): full manual of `moon` build system.
- VSCode extension
- ...

```{only} html
[Download this section in Markdown](path:/download/toolchain/summary.md)
```

```{toctree}
:maxdepth: 2
:caption: Contents:
moon/index

================================================
File 541: /data/input/moonbit-docs/next/toolchain/moon/commands.md
================================================
# Command-Line Help for `moon`

This document contains the help content for the `moon` command-line program.

**Command Overview:**

* [`moon`↴](#moon)
* [`moon new`↴](#moon-new)
* [`moon build`↴](#moon-build)
* [`moon check`↴](#moon-check)
* [`moon run`↴](#moon-run)
* [`moon test`↴](#moon-test)
* [`moon clean`↴](#moon-clean)
* [`moon fmt`↴](#moon-fmt)
* [`moon doc`↴](#moon-doc)
* [`moon info`↴](#moon-info)
* [`moon add`↴](#moon-add)
* [`moon remove`↴](#moon-remove)
* [`moon install`↴](#moon-install)
* [`moon tree`↴](#moon-tree)
* [`moon login`↴](#moon-login)
* [`moon register`↴](#moon-register)
* [`moon publish`↴](#moon-publish)
* [`moon package`↴](#moon-package)
* [`moon update`↴](#moon-update)
* [`moon coverage`↴](#moon-coverage)
* [`moon coverage report`↴](#moon-coverage-report)
* [`moon coverage clean`↴](#moon-coverage-clean)
* [`moon generate-build-matrix`↴](#moon-generate-build-matrix)
* [`moon upgrade`↴](#moon-upgrade)
* [`moon shell-completion`↴](#moon-shell-completion)
* [`moon version`↴](#moon-version)

## `moon`

**Usage:** `moon <COMMAND>`

**Subcommands:**

* `new` — Create a new MoonBit module
* `build` — Build the current package
* `check` — Check the current package, but don't build object files
* `run` — Run a main package
* `test` — Test the current package
* `clean` — Remove the target directory
* `fmt` — Format source code
* `doc` — Generate documentation
* `info` — Generate public interface (`.mbti`) files for all packages in the module
* `add` — Add a dependency
* `remove` — Remove a dependency
* `install` — Install dependencies
* `tree` — Display the dependency tree
* `login` — Log in to your account
* `register` — Register an account at mooncakes.io
* `publish` — Publish the current module
* `package` — Package the current module
* `update` — Update the package registry index
* `coverage` — Code coverage utilities
* `generate-build-matrix` — Generate build matrix for benchmarking (legacy feature)
* `upgrade` — Upgrade toolchains
* `shell-completion` — Generate shell completion for bash/elvish/fish/pwsh/zsh to stdout
* `version` — Print version information and exit



## `moon new`

Create a new MoonBit module

**Usage:** `moon new [OPTIONS] [PACKAGE_NAME]`

**Arguments:**

* `<PACKAGE_NAME>` — The name of the package

**Options:**

* `--lib` — Create a library package instead of an executable
* `--path <PATH>` — Output path of the package
* `--user <USER>` — The user name of the package
* `--name <NAME>` — The name part of the package
* `--license <LICENSE>` — The license of the package

  Default value: `Apache-2.0`
* `--no-license` — Do not set a license for the package



## `moon build`

Build the current package

**Usage:** `moon build [OPTIONS]`

**Options:**

* `--std` — Enable the standard library (default)
* `--nostd` — Disable the standard library
* `-g`, `--debug` — Emit debug information
* `--release` — Compile in release mode
* `--strip` — Enable stripping debug information
* `--no-strip` — Disable stripping debug information
* `--target <TARGET>` — Select output target

  Possible values: `wasm`, `wasm-gc`, `js`, `native`, `all`

* `--serial` — Handle the selected targets sequentially
* `--enable-coverage` — Enable coverage instrumentation
* `--sort-input` — Sort input files
* `--output-wat` — Output WAT instead of WASM
* `-d`, `--deny-warn` — Treat all warnings as errors
* `--no-render` — Don't render diagnostics from moonc (don't pass '-error-format json' to moonc)
* `--warn-list <WARN_LIST>` — Warn list config
* `--alert-list <ALERT_LIST>` — Alert list config
* `--frozen` — Do not sync dependencies, assuming local dependencies are up-to-date
* `-w`, `--watch` — Monitor the file system and automatically build artifacts



## `moon check`

Check the current package, but don't build object files

**Usage:** `moon check [OPTIONS] [PACKAGE_PATH]`

**Arguments:**

* `<PACKAGE_PATH>` — The package(and it's deps) to check

**Options:**

* `--std` — Enable the standard library (default)
* `--nostd` — Disable the standard library
* `-g`, `--debug` — Emit debug information
* `--release` — Compile in release mode
* `--strip` — Enable stripping debug information
* `--no-strip` — Disable stripping debug information
* `--target <TARGET>` — Select output target

  Possible values: `wasm`, `wasm-gc`, `js`, `native`, `all`

* `--serial` — Handle the selected targets sequentially
* `--enable-coverage` — Enable coverage instrumentation
* `--sort-input` — Sort input files
* `--output-wat` — Output WAT instead of WASM
* `-d`, `--deny-warn` — Treat all warnings as errors
* `--no-render` — Don't render diagnostics from moonc (don't pass '-error-format json' to moonc)
* `--warn-list <WARN_LIST>` — Warn list config
* `--alert-list <ALERT_LIST>` — Alert list config
* `--output-json` — Output in json format
* `--frozen` — Do not sync dependencies, assuming local dependencies are up-to-date
* `-w`, `--watch` — Monitor the file system and automatically check files
* `--patch-file <PATCH_FILE>` — The patch file to check, Only valid when checking specified package
* `--no-mi` — Whether to skip the mi generation, Only valid when checking specified package



## `moon run`

Run a main package

**Usage:** `moon run [OPTIONS] <PACKAGE_OR_MBT_FILE> [ARGS]...`

**Arguments:**

* `<PACKAGE_OR_MBT_FILE>` — The package or .mbt file to run
* `<ARGS>` — The arguments provided to the program to be run

**Options:**

* `--std` — Enable the standard library (default)
* `--nostd` — Disable the standard library
* `-g`, `--debug` — Emit debug information
* `--release` — Compile in release mode
* `--strip` — Enable stripping debug information
* `--no-strip` — Disable stripping debug information
* `--target <TARGET>` — Select output target

  Possible values: `wasm`, `wasm-gc`, `js`, `native`, `all`

* `--serial` — Handle the selected targets sequentially
* `--enable-coverage` — Enable coverage instrumentation
* `--sort-input` — Sort input files
* `--output-wat` — Output WAT instead of WASM
* `-d`, `--deny-warn` — Treat all warnings as errors
* `--no-render` — Don't render diagnostics from moonc (don't pass '-error-format json' to moonc)
* `--warn-list <WARN_LIST>` — Warn list config
* `--alert-list <ALERT_LIST>` — Alert list config
* `--frozen` — Do not sync dependencies, assuming local dependencies are up-to-date
* `--build-only` — Only build, do not run the code



## `moon test`

Test the current package

**Usage:** `moon test [OPTIONS]`

**Options:**

* `--std` — Enable the standard library (default)
* `--nostd` — Disable the standard library
* `-g`, `--debug` — Emit debug information
* `--release` — Compile in release mode
* `--strip` — Enable stripping debug information
* `--no-strip` — Disable stripping debug information
* `--target <TARGET>` — Select output target

  Possible values: `wasm`, `wasm-gc`, `js`, `native`, `all`

* `--serial` — Handle the selected targets sequentially
* `--enable-coverage` — Enable coverage instrumentation
* `--sort-input` — Sort input files
* `--output-wat` — Output WAT instead of WASM
* `-d`, `--deny-warn` — Treat all warnings as errors
* `--no-render` — Don't render diagnostics from moonc (don't pass '-error-format json' to moonc)
* `--warn-list <WARN_LIST>` — Warn list config
* `--alert-list <ALERT_LIST>` — Alert list config
* `-p`, `--package <PACKAGE>` — Run test in the specified package
* `-f`, `--file <FILE>` — Run test in the specified file. Only valid when `--package` is also specified
* `-i`, `--index <INDEX>` — Run only the index-th test in the file. Only valid when `--file` is also specified
* `-u`, `--update` — Update the test snapshot
* `-l`, `--limit <LIMIT>` — Limit of expect test update passes to run, in order to avoid infinite loops

  Default value: `256`
* `--frozen` — Do not sync dependencies, assuming local dependencies are up-to-date
* `--build-only` — Only build, do not run the tests
* `--no-parallelize` — Run the tests in a target backend sequentially
* `--test-failure-json` — Print failure message in JSON format
* `--patch-file <PATCH_FILE>` — Path to the patch file
* `--doc` — Run doc test



## `moon clean`

Remove the target directory

**Usage:** `moon clean`



## `moon fmt`

Format source code

**Usage:** `moon fmt [OPTIONS] [ARGS]...`

**Arguments:**

* `<ARGS>`

**Options:**

* `--check` — Check only and don't change the source code
* `--sort-input` — Sort input files
* `--block-style <BLOCK_STYLE>` — Add separator between each segments

  Possible values: `false`, `true`




## `moon doc`

Generate documentation

**Usage:** `moon doc [OPTIONS]`

**Options:**

* `--serve` — Start a web server to serve the documentation
* `-b`, `--bind <BIND>` — The address of the server

  Default value: `127.0.0.1`
* `-p`, `--port <PORT>` — The port of the server

  Default value: `3000`
* `--frozen` — Do not sync dependencies, assuming local dependencies are up-to-date



## `moon info`

Generate public interface (`.mbti`) files for all packages in the module

**Usage:** `moon info [OPTIONS]`

**Options:**

* `--frozen` — Do not sync dependencies, assuming local dependencies are up-to-date
* `--no-alias` — Do not use alias to shorten package names in the output



## `moon add`

Add a dependency

**Usage:** `moon add [OPTIONS] <PACKAGE_PATH>`

**Arguments:**

* `<PACKAGE_PATH>` — The package path to add

**Options:**

* `--bin` — Whether to add the dependency as a binary



## `moon remove`

Remove a dependency

**Usage:** `moon remove <PACKAGE_PATH>`

**Arguments:**

* `<PACKAGE_PATH>` — The package path to remove



## `moon install`

Install dependencies

**Usage:** `moon install`



## `moon tree`

Display the dependency tree

**Usage:** `moon tree`



## `moon login`

Log in to your account

**Usage:** `moon login`



## `moon register`

Register an account at mooncakes.io

**Usage:** `moon register`



## `moon publish`

Publish the current module

**Usage:** `moon publish [OPTIONS]`

**Options:**

* `--frozen` — Do not sync dependencies, assuming local dependencies are up-to-date



## `moon package`

Package the current module

**Usage:** `moon package [OPTIONS]`

**Options:**

* `--frozen` — Do not sync dependencies, assuming local dependencies are up-to-date
* `--list`



## `moon update`

Update the package registry index

**Usage:** `moon update`



## `moon coverage`

Code coverage utilities

**Usage:** `moon coverage <COMMAND>`

**Subcommands:**

* `report` — Generate code coverage report
* `clean` — Clean up coverage artifacts



## `moon coverage report`

Generate code coverage report

**Usage:** `moon coverage report [args]... [COMMAND]`

**Arguments:**

* `<args>` — Arguments to pass to the coverage utility

**Options:**

* `-h`, `--help` — Show help for the coverage utility



## `moon coverage clean`

Clean up coverage artifacts

**Usage:** `moon coverage clean`



## `moon generate-build-matrix`

Generate build matrix for benchmarking (legacy feature)

**Usage:** `moon generate-build-matrix [OPTIONS] --output-dir <OUT_DIR>`

**Options:**

* `-n <NUMBER>` — Set all of `drow`, `dcol`, `mrow`, `mcol` to the same value
* `--drow <DIR_ROWS>` — Number of directory rows
* `--dcol <DIR_COLS>` — Number of directory columns
* `--mrow <MOD_ROWS>` — Number of module rows
* `--mcol <MOD_COLS>` — Number of module columns
* `-o`, `--output-dir <OUT_DIR>` — The output directory



## `moon upgrade`

Upgrade toolchains

**Usage:** `moon upgrade [OPTIONS]`

**Options:**

* `-f`, `--force` — Force upgrade



## `moon shell-completion`

Generate shell completion for bash/elvish/fish/pwsh/zsh to stdout

**Usage:** `moon shell-completion [OPTIONS]`


Discussion:
Enable tab completion for Bash, Elvish, Fish, Zsh, or PowerShell
The script is output on `stdout`, allowing one to re-direct the
output to the file of their choosing. Where you place the file
will depend on which shell, and which operating system you are
using. Your particular configuration may also determine where
these scripts need to be placed.

The completion scripts won't update itself, so you may need to
periodically run this command to get the latest completions.
Or you may put `eval "$(moon shell-completion --shell <SHELL>)"`
in your shell's rc file to always load newest completions on startup.
Although it's considered not as efficient as having the completions
script installed.

Here are some common set ups for the three supported shells under
Unix and similar operating systems (such as GNU/Linux).

Bash:

Completion files are commonly stored in `/etc/bash_completion.d/` for
system-wide commands, but can be stored in
`~/.local/share/bash-completion/completions` for user-specific commands.
Run the command:

    $ mkdir -p ~/.local/share/bash-completion/completions
    $ moon shell-completion --shell bash >> ~/.local/share/bash-completion/completions/moon

This installs the completion script. You may have to log out and
log back in to your shell session for the changes to take effect.

Bash (macOS/Homebrew):

Homebrew stores bash completion files within the Homebrew directory.
With the `bash-completion` brew formula installed, run the command:

    $ mkdir -p $(brew --prefix)/etc/bash_completion.d
    $ moon shell-completion --shell bash > $(brew --prefix)/etc/bash_completion.d/moon.bash-completion

Fish:

Fish completion files are commonly stored in
`$HOME/.config/fish/completions`. Run the command:

    $ mkdir -p ~/.config/fish/completions
    $ moon shell-completion --shell fish > ~/.config/fish/completions/moon.fish

This installs the completion script. You may have to log out and
log back in to your shell session for the changes to take effect.

Elvish:

Elvish completions are commonly stored in a single `completers` module.
A typical module search path is `~/.config/elvish/lib`, and
running the command:

    $ moon shell-completion --shell elvish >> ~/.config/elvish/lib/completers.elv

will install the completions script. Note that use `>>` (append) 
instead of `>` (overwrite) to prevent overwriting the existing completions 
for other commands. Then prepend your rc.elv with:

    `use completers`

to load the `completers` module and enable completions.

Zsh:

ZSH completions are commonly stored in any directory listed in
your `$fpath` variable. To use these completions, you must either
add the generated script to one of those directories, or add your
own to this list.

Adding a custom directory is often the safest bet if you are
unsure of which directory to use. First create the directory; for
this example we'll create a hidden directory inside our `$HOME`
directory:

    $ mkdir ~/.zfunc

Then add the following lines to your `.zshrc` just before
`compinit`:

    fpath+=~/.zfunc

Now you can install the completions script using the following
command:

    $ moon shell-completion --shell zsh > ~/.zfunc/_moon

You must then open a new zsh session, or simply run

    $ . ~/.zshrc

for the new completions to take effect.

Custom locations:

Alternatively, you could save these files to the place of your
choosing, such as a custom directory inside your $HOME. Doing so
will require you to add the proper directives, such as `source`ing
inside your login script. Consult your shells documentation for
how to add such directives.

PowerShell:

The powershell completion scripts require PowerShell v5.0+ (which
comes with Windows 10, but can be downloaded separately for windows 7
or 8.1).

First, check if a profile has already been set

    PS C:\> Test-Path $profile

If the above command returns `False` run the following

    PS C:\> New-Item -path $profile -type file -force

Now open the file provided by `$profile` (if you used the
`New-Item` command it will be
`${env:USERPROFILE}\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1`

Next, we either save the completions file into our profile, or
into a separate file and source it inside our profile. To save the
completions into our profile simply use

    PS C:\> moon shell-completion --shell powershell >>
    ${env:USERPROFILE}\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1

This discussion is taken from `rustup completions` command with some changes.


**Options:**

* `--shell <SHELL>` — The shell to generate completion for

  Default value: `<your shell>`

  Possible values: `bash`, `elvish`, `fish`, `powershell`, `zsh`




## `moon version`

Print version information and exit

**Usage:** `moon version [OPTIONS]`

**Options:**

* `--all` — Print all version information
* `--json` — Print version information in JSON format
* `--no-path` — Do not print the path



<hr/>

<small><i>
    This document was generated automatically by
    <a href="https://crates.io/crates/clap-markdown"><code>clap-markdown</code></a>.
</i></small>

================================================
File 542: /data/input/moonbit-docs/next/toolchain/moon/coverage.md
================================================
# Measuring code coverage

We have included tooling for you to measure the code coverage of test and program runs.
The measurement is currently based on branch coverage.
In other words, it measures whether each program branch was executed,
and how many times if they were.

## Running code coverage in tests

To enable coverage instrumentation in tests,
you need to pass the `--enable-coverage` argument to `moon test`.

```
$ moon test --enable-coverage
...
Total tests: 3077, passed: 3077, failed: 0.
```

This will recompile the project
if they weren't previously compiled with coverage enabled.
The execution process will look the same,
but new coverage result files will be generated under the `target` directory.

```
$ ls target/wasm-gc/debug/test/ -w1
array
...
moonbit_coverage_1735628238436873.txt
moonbit_coverage_1735628238436883.txt
...
moonbit_coverage_1735628238514678.txt
option/
...
```

These files contain the information for the toolchain to determine
which parts of the program were executed,
and which parts weren't.

## Visualizing the coverage results

To visualize the result of coverage instrumentation,
you'll need to use the `moon coverage report` subcommand.

The subcommand can export the coverage in a number of formats,
controlled by the `-f` flag:

- Text summary: `summary`
- OCaml Bisect format: `bisect` (default)
- Coveralls JSON format: `coveralls`
- Cobertura XML format: `cobertura`
- HTML pages: `html`

### Text summary

`moon coverage report -f summary` exports the coverage data into stdout,
printing the covered points and total coverage point count for each file.

```
$ moon coverage report -f summary
array/array.mbt: 21/22
array/array_nonjs.mbt: 3/3
array/blit.mbt: 3/3
array/deprecated.mbt: 0/0
array/fixedarray.mbt: 115/115
array/fixedarray_sort.mbt: 110/116
array/fixedarray_sort_by.mbt: 58/61
array/slice.mbt: 6/6
array/sort.mbt: 70/70
array/sort_by.mbt: 56/61
...
```

### OCaml Bisect format

This is the default format to export, if `-f` is not specified.

`moon coverage report -f bisect` exports the coverage data into
a file `bisect.coverage` which can be read by [OCaml Bisect][bisect] tool.

[bisect]: https://github.com/aantron/bisect_ppx

### Coveralls JSON format

`moon coverage report -f coveralls` exports the coverage data into Coverall's JSON format.
This format is line-based, and can be read by both Coveralls and CodeCov.
You can find its specification [here](https://docs.coveralls.io/api-introduction#json-format-web-data).

```
$ moon coverage report -f coveralls
$ cat coveralls.json
{
    "source_files": [
        {
            "name": "builtin/console.mbt",
            "source_digest": "1c24532e12ac5bdf34b7618c9f38bd82",
            "coverage": [null,null,...,null,null]
        },
        {
            "name": "immut/array/array.mbt",
            "source_digest": "bcf1fb1d2f143ebf4423565d5a57e84f",
            "coverage": [null,null,null,...
```

You can directly send this coverage report to Coveralls or CodeCov using the `--send-to` argument.
The following is an example of using it in GitHub Actions:

```
moon coverage report \
    -f coveralls \
    -o codecov_report.json \
    --service-name github \
    --service-job-id "$GITHUB_RUN_NUMBER" \
    --service-pull-request "${{ github.event.number }}" \
    --send-to coveralls

env:
    COVERALLS_REPO_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

More information can be found in `moon coverage report --help`.

### Cobertura XML format

`moon coverage report -f cobertura` exports the coverage data into a format that can be read by [Cobertura](https://cobertura.github.io/cobertura/).

### HTML

`moon coverage report -f html` export the coverage data into a series of human-readable HTML files.
The default export location is the folder named `_coverage`.

The `index.html` in the folder shows a list of all source files,
as well as the coverage percentage in them:

![Index of the HTML](/imgs/coverage_html_index.png)

Clicking on each file shows the coverage detail within each file.
Each coverage point (start of branch)
is represented by a highlighted character in the source code:
Red means the point is not covered among all runs,
and green means the point is covered in at least one run.

Each line is also highlighted by the coverage information,
with the same color coding.
Additionally,
yellow lines are those which has partial coverage:
some points in the line are covered, while others aren't.

Some lines will not have any highlight.
This does not mean the line has not been executed at all,
just the line is not a start of a branch.
Such a line shares the coverage of closest covered the line before it.

![Detailed coverage data](/imgs/coverage_html_page.png)

## Skipping coverage

Adding the pragma `/// @coverage.skip` skips all coverage operations within the function.
Additionally, all deprecated functions will not be covered.


================================================
File 543: /data/input/moonbit-docs/next/toolchain/moon/index.md
================================================
# Moon Build System

```{toctree}
:maxdepth: 2
:caption: Contents:
tutorial
package-manage-tour
commands
module
package
coverage
```


================================================
File 544: /data/input/moonbit-docs/next/toolchain/moon/module.md
================================================
# Module Configuration

moon uses the `moon.mod.json` file to identify and describe a module. For full JSON schema, please check [moon's repository](https://github.com/moonbitlang/moon/blob/main/crates/moonbuild/template/mod.schema.json).

## Name

The `name` field is used to specify the name of the module, and it is required.

```json
{
  "name": "example",
  // ...
}
```

The module name can contain letters, numbers, `_`, `-`, and `/`.

For modules published to [mooncakes.io](https://mooncakes.io), the module name must begin with the username. For example:

```json
{
  "name": "moonbitlang/core",
  // ...
}
```

## Version

The `version` field is used to specify the version of the module.

This field is optional. For modules published to [mooncakes.io](https://mooncakes.io), the version number must follow the [Semantic Versioning 2.0.0](https://semver.org/spec/v2.0.0.html) specification.

```json
{
  "name": "example",
  "version": "0.1.0",
  // ...
}
```

## Deps

The `deps` field is used to specify the dependencies of the module.

It is automatically managed by commands like `moon add` and `moon remove`.

```json
{
  "name": "username/hello",
  "deps": {
    "moonbitlang/x": "0.4.6"
  }
}
```

## README

The `readme` field is used to specify the path to the module's README file.

## Repository

The `repository` field is used to specify the URL of the module's repository.

## License

The `license` field is used to specify the license of the module. The license type must comply with the [SPDX License List](https://spdx.org/licenses/).

```json
{
  "license": "MIT"
}
```

## Keywords

The `keywords` field is used to specify the keywords for the module.

```json
{
  "keywords": ["example", "test"]
}
```

## Description

The `description` field is used to specify the description of the module.

```json
{
  "description": "This is a description of the module."
}
```

## Source directory

The `source` field is used to specify the source directory of the module.

It must be a subdirectory of the directory where the `moon.mod.json` file is located and must be a relative path.

When creating a module using the `moon new` command, a `src` directory will be automatically generated, and the default value of the `source` field will be `src`.

```json
{
  "source": "src"
}
```

When the `source` field does not exist, or its value is `null` or an empty string `""`, it is equivalent to setting `"source": "."`. This means that the source directory is the same as the directory where the `moon.mod.json` file is located.

```json
{
  "source": null
}
{
  "source": ""
}
{
  "source": "."
}
```

## Warning List

This is used to disable specific preset compiler warning numbers.

For example, in the following configuration, `-2` disables the warning number 2 (Unused variable).

```json
{
  "warn-list": "-2",
}
```

You can use `moonc build-package -warn-help` to see the list of preset compiler warning numbers.

```
$ moonc -v                      
v0.1.20250310+a7a1e9804

$ moonc build-package -warn-help
Available warnings: 
  1 Unused function.
  2 Unused variable.
  3 Unused type declaration.
  4 Unused abstract type.
  5 Unused type variable.
  6 Unused constructor.
  7 Unused field or constructor argument.
  8 Redunant modifier.
  9 Unused function declaration.
 10 Struct never constructed.
 11 Partial pattern matching.
 12 Unreachable code.
 13 Unresolved type variable.
 14 Lowercase type name.
 15 Unused mutability.
 16 Parser inconsistency.
 18 Useless loop expression.
 19 Top-level declaration is not left aligned.
 20 Invalid pragma
 21 Some arguments of constructor are omitted in pattern.
 22 Ambiguous block.
 23 Useless try expression.
 24 Useless error type.
 26 Useless catch all.
 27 Deprecated syntax.
 28 Todo
 29 Unused package.
 30 Empty package alias.
 31 Optional argument never supplied.
 32 Default value of optional argument never used.
 33 Unused import value
 35 Reserved keyword.
 36 Loop label shadows another label.
 37 Unused loop label.
 38 Useless guard.
 39 Duplicated method.
 40 Call a qualified method using regular call syntax.
 41 Closed map pattern.
 42 Invalid attribute.
 43 Unused attribute.
 44 Invalid inline-wasm.
 45 Type implments trait with regular methods.
  A all warnings
```

## Alert List

Disable user preset alerts.

```json
{
  "alert-list": "-alert_1-alert_2"
}
```

================================================
File 545: /data/input/moonbit-docs/next/toolchain/moon/package-manage-tour.md
================================================
# MoonBit's Package Manager Tutorial

## Overview

MoonBit's build system seamlessly integrates package management and documentation generation tools, allowing users to easily fetch dependencies from mooncakes.io, access module documentation, and publish new modules.

[mooncakes.io](https://mooncakes.io/) is a centralized package management platform. Each module has a corresponding configuration file `moon.mod.json`, which is the smallest unit for publishing. Under the module's path, there can be multiple packages, each corresponding to a `moon.pkg.json` configuration file. The `.mbt` files at the same level as `moon.pkg.json` belong to this package.

Before getting started, make sure you have installed [moon](https://www.moonbitlang.com/download/).

## Setup mooncakes.io account

```{note}
If you don't want to publish, you can skip this step.
```

If you don't have an account on mooncakes.io, run `moon register` and follow the guide. If you have previously registered an account, you can use `moon login` to log in.

When you see the following message, it means you have successfully logged in:

```
API token saved to ~/.moon/credentials.json
```

## Update index

Use `moon update` to update the mooncakes.io index.

![moon update cli](/imgs/moon-update.png)

## Setup MoonBit project

Open an existing project or create a new project via `moon new`:

![moon new](/imgs/moon-new.png)

## Add dependencies

You can browse all available modules on mooncakes.io. Use `moon add` to add the dependencies you need, or manually edit the `deps` field in `moon.mod.json`.

For example, to add the latest version of the `Yoorkin/example/list` module:

![add deps](/imgs/add-deps.png)

## Import packages from module

Modify the configuration file `moon.pkg.json` and declare the packages that need to be imported in the `import` field.

For example, in the image below, the `hello/main/moon.pkg.json` file is modified to declare the import of `Yoorkin/example/list` in the `main` package. Now, you can call the functions of the third-party package in the `main` package using `@list`.

![import package](/imgs/import.png)

You can also give an alias to the imported package:

```json
{
    "is_main": true,
    "import": [
        { "path": "Yoorkin/example/list", "alias": "ls" }
    ]
}
```

Read the documentation of this module on mooncakes.io, we can use its `of_array` and `reverse` functions to implement a new function `reverse_array`.

![reverse array](/imgs/reverse-array.png)

## Remove dependencies

You can remove dependencies via `moon remove <module name>`.

## Publish your module

If you are ready to share your module, use `moon publish` to push a module to
mooncakes.io. There are some important considerations to keep in mind before publishing:

### Semantic versioning convention

MoonBit's package management follows the convention of [Semantic Versioning](https://semver.org/). Each module must define a version number in the format `MAJOR.MINOR.PATCH`. With each push, the module must increment the:

- MAJOR version when you make incompatible API changes
- MINOR version when you add functionality in a backward compatible manner
- PATCH version when you make backward compatible bug fixes

Additional labels for pre-release and build metadata are available as extensions to the `MAJOR.MINOR.PATCH` format.

moon implements the [minimal version selection](https://research.swtch.com/vgo-mvs), which automatically handles and installs dependencies based on the module's semantic versioning information. Minimal version selection assumes that each module declares its own dependency requirements and follows semantic versioning convention, aiming to make the user's dependency graph as close as possible to the author's development-time dependencies.

### Readme & metadata

Metadata in `moon.mod.json` and `README.md` will be shown in mooncakes.io.

Metadata consist of the following sections:

- `license`: license of this module, it following the [SPDX](https://spdx.dev/about/overview/) convention
- `keywords`: keywords of this module
- `repository`: URL of the package source repository
- `description`: short description to this module
- `homepage`: URL of the module homepage

### Moondoc

mooncakes.io will generate documentation for each module automatically.

The leading `///` comments of each toplevel will be recognized as documentation.
You can write markdown inside.

```moonbit
/// Get the largest element of a non-empty `Array`.
///
/// # Example
///
/// ```
/// maximum([1,2,3,4,5,6]) = 6
/// ```
///
/// # Panics
///
/// Panics if the `xs` is empty.
///
pub fn maximum[T : Compare](xs : Array[T]) -> T {
  // TODO ...
}
```

You can also use `moon doc --serve` to generate and view documentation locally.


================================================
File 546: /data/input/moonbit-docs/next/toolchain/moon/package.md
================================================
# Package Configuration

moon uses the `moon.pkg.json` file to identify and describe a package. For full JSON schema, please check [moon's repository](https://github.com/moonbitlang/moon/blob/main/crates/moonbuild/template/pkg.schema.json).

## Name

The package name is not configurable; it is determined by the directory name of the package.

## is-main

The `is-main` field is used to specify whether a package needs to be linked into an executable file.

The output of the linking process depends on the backend. When this field is set to `true`:

- For the Wasm and `wasm-gc` backends, a standalone WebAssembly module will be generated.
- For the `js` backend, a standalone JavaScript file will be generated.

## Importing dependencies

### import

The `import` field is used to specify other packages that a package depends on.

For example, the following imports `moonbitlang/quickcheck` and `moonbitlang/x/encoding`, 
aliasing the latter to `lib` and importing the function `encode` from the latter.
User can write `@lib.encode` instead of `encode`.

```json
{
  "import": [
    "moonbitlang/quickcheck",
    { "path" : "moonbitlang/x/encoding", "alias": "lib", "value": ["encode"] }
  ]
}
```

### test-import

The `test-import` field is used to specify other packages that the black-box test package of this package depends on,
with the same format as `import`.

The `test-import-all` field is used to specify whether all public definitions from the package being tested should be imported (`true`) by default.

### wbtest-import

The `wbtest-import` field is used to specify other packages that the white-box test package of this package depends on,
with the same format as `import`.

## Conditional Compilation

The smallest unit of conditional compilation is a file.

In a conditional compilation expression, three logical operators are supported: `and`, `or`, and `not`, where the `or` operator can be omitted.

For example, `["or", "wasm", "wasm-gc"]` can be simplified to `["wasm", "wasm-gc"]`.

Conditions in the expression can be categorized into backends and optimization levels:

- **Backend conditions**: `"wasm"`, `"wasm-gc"`, and `"js"`
- **Optimization level conditions**: `"debug"` and `"release"`

Conditional expressions support nesting.

If a file is not listed in `"targets"`, it will be compiled under all conditions by default.

Example:

```json
{
  "targets": {
    "only_js.mbt": ["js"],
    "only_wasm.mbt": ["wasm"],
    "only_wasm_gc.mbt": ["wasm-gc"],
    "all_wasm.mbt": ["wasm", "wasm-gc"],
    "not_js.mbt": ["not", "js"],
    "only_debug.mbt": ["debug"],
    "js_and_release.mbt": ["and", ["js"], ["release"]],
    "js_only_test.mbt": ["js"],
    "js_or_wasm.mbt": ["js", "wasm"],
    "wasm_release_or_js_debug.mbt": ["or", ["and", "wasm", "release"], ["and", "js", "debug"]]
  }
}
```

## Link Options

By default, moon only links packages where `is-main` is set to `true`. If you need to link other packages, you can specify this with the `link` option.

The `link` option is used to specify link options, and its value can be either a boolean or an object.

- When the `link` value is `true`, it indicates that the package should be linked. The output will vary depending on the backend specified during the build.

  ```json
  {
    "link": true
  }
  ```

- When the `link` value is an object, it indicates that the package should be linked, and you can specify link options. For detailed configuration, please refer to the subpage for the corresponding backend.

### Wasm Backend Link Options

#### Common Options

- The `exports` option is used to specify the function names exported by the Wasm backend.

  For example, in the following configuration, the `hello` function from the current package is exported as the `hello` function in the Wasm module, and the `foo` function is exported as the `bar` function in the Wasm module. In the Wasm host, the `hello` and `bar` functions can be called to invoke the `hello` and `foo` functions from the current package.

  ```json
  {
    "link": {
      "wasm": {
        "exports": [
          "hello",
          "foo:bar"
        ]
      },
      "wasm-gc": {
        "exports": [
          "hello",
          "foo:bar"
        ]
      }
    }
  }
  ```

- The `import-memory` option is used to specify the linear memory imported by the Wasm module.

  For example, the following configuration specifies that the linear memory imported by the Wasm module is the `memory` variable from the `env` module.

  ```json
  {
    "link": {
      "wasm": {
        "import-memory": {
          "module": "env",
          "name": "memory"
        }
      },
      "wasm-gc": {
        "import-memory": {
          "module": "env",
          "name": "memory"
        }
      }
    }
  }
  ```

- The `export-memory-name` option is used to specify the name of the linear memory exported by the Wasm module.

  ```json
  {
    "link": {
      "wasm": {
        "export-memory-name": "memory"
      },
      "wasm-gc": {
        "export-memory-name": "memory"
      }
    }
  }
  ```

#### Wasm Linear Backend Link Options

- The `heap-start-address` option is used to specify the starting address of the linear memory that can be used when compiling to the Wasm backend.

  For example, the following configuration sets the starting address of the linear memory to 1024.

  ```json
  {
    "link": {
      "wasm": {
        "heap-start-address": 1024
      }
    }
  }
  ```

#### Wasm GC Backend Link Options

- The `use-js-string-builtin` option is used to specify whether the [JS String Builtin Proposal](https://github.com/WebAssembly/js-string-builtins/blob/main/proposals/js-string-builtins/Overview.md) should be enabled when compiling to the Wasm GC backend. 
  It will make the `String` in MoonBit equivalent to the `String` in JavaScript host runtime.

  For example, the following configuration enables the JS String Builtin.

  ```json
  {
    "link": {
      "wasm-gc": {
        "use-js-builtin-string": true
      }
    }
  }
  ```

- The `imported-string-constants` option is used to specify the imported string namespace used by the JS String Builtin Proposal, which is "_" by default.
  It should meet the configuration in the JS host runtime.

  For example, the following configuration and JS initialization configures the imported string namespace.

  ```json
  {
    "link": {
      "wasm-gc": {
        "use-js-builtin-string": true,
        "imported-string-constants": "_"
      }
    }
  }
  ```

  ```javascript
  const { instance } = await WebAssembly.instantiate(bytes, {}, { importedStringConstants: "strings" });
  ```

### JS Backend Link Options

- The `exports` option is used to specify the function names to export in the JavaScript module.

  For example, in the following configuration, the `hello` function from the current package is exported as the `hello` function in the JavaScript module. In the JavaScript host, the `hello` function can be called to invoke the `hello` function from the current package.

  ```json
  {
    "link": {
      "js": {
        "exports": [
          "hello"
        ]
      }
    }
  }
  ```

- The `format` option is used to specify the output format of the JavaScript module.

  The currently supported formats are:
  - `esm`
  - `cjs`
  - `iife`

  For example, the following configuration sets the output format of the current package to ES Module.

  ```json
  {
    "link": {
      "js": {
        "format": "esm"
      }
    }
  }
  ```

## Pre-build

The `"pre-build"` field is used to specify pre-build commands, which will be executed before build commands such as `moon check|build|test`.

`"pre-build"` is an array, where each element is an object containing `input`, `output`, and `command` fields. The `input` and `output` fields can be strings or arrays of strings, while the `command` field is a string. In the `command`, you can use any shell commands, as well as the `$input` and `$output` variables, which represent the input and output files, respectively. If these fields are arrays, they will be joined with spaces by default.

Currently, there is a built-in special command `:embed`, which converts files into MoonBit source code. The `--text` parameter is used to embed text files, and `--binary` is used for binary files. `--text` is the default and can be omitted. The `--name` parameter is used to specify the generated variable name, with `resource` being the default. The command is executed in the directory where the `moon.pkg.json` file is located.

```json
{
  "pre-build": [
    {
      "input": "a.txt",
      "output": "a.mbt",
      "command": ":embed -i $input -o $output"
    }
  ]
}
```

If the content of `a.txt` in the current package directory is:
```
hello,
world
```

After running `moon build`, the following `a.mbt` file will be generated in the directory where the `moon.pkg.json` is located:

```
let resource : String =
  #|hello,
  #|world
  #|
```

## Warning List

This is used to disable specific preset compiler warning numbers.

For example, in the following configuration, `-2` disables the warning number 2 (Unused variable).

```json
{
  "warn-list": "-2"
}
```

You can use `moonc build-package -warn-help` to see the list of preset compiler warning numbers.

```
$ moonc -v                      
v0.1.20250310+a7a1e9804

$ moonc build-package -warn-help
Available warnings: 
  1 Unused function.
  2 Unused variable.
  3 Unused type declaration.
  4 Unused abstract type.
  5 Unused type variable.
  6 Unused constructor.
  7 Unused field or constructor argument.
  8 Redunant modifier.
  9 Unused function declaration.
 10 Struct never constructed.
 11 Partial pattern matching.
 12 Unreachable code.
 13 Unresolved type variable.
 14 Lowercase type name.
 15 Unused mutability.
 16 Parser inconsistency.
 18 Useless loop expression.
 19 Top-level declaration is not left aligned.
 20 Invalid pragma
 21 Some arguments of constructor are omitted in pattern.
 22 Ambiguous block.
 23 Useless try expression.
 24 Useless error type.
 26 Useless catch all.
 27 Deprecated syntax.
 28 Todo
 29 Unused package.
 30 Empty package alias.
 31 Optional argument never supplied.
 32 Default value of optional argument never used.
 33 Unused import value
 35 Reserved keyword.
 36 Loop label shadows another label.
 37 Unused loop label.
 38 Useless guard.
 39 Duplicated method.
 40 Call a qualified method using regular call syntax.
 41 Closed map pattern.
 42 Invalid attribute.
 43 Unused attribute.
 44 Invalid inline-wasm.
 45 Type implments trait with regular methods.
  A all warnings
```

## Alert List

Disable user preset alerts.

```json
{
  "alert-list": "-alert_1-alert_2"
}
```

================================================
File 547: /data/input/moonbit-docs/next/toolchain/moon/tutorial.md
================================================
# MoonBit's Build System Tutorial

Moon is the build system for the MoonBit language, currently based on the [n2](https://github.com/evmar/n2) project. Moon supports parallel and incremental builds. Additionally, moon also supports managing and building third-party packages on [mooncakes.io](https://mooncakes.io/)

## Prerequisites

Before you begin with this tutorial, make sure you have installed the following:

1. **MoonBit CLI Tools**: Download it from the <https://www.moonbitlang.com/download/>. This command line tool is needed for creating and managing MoonBit projects.

    Use `moon help` to view the usage instructions.

    ```bash
    $ moon help
    ...
    ```

2. **MoonBit Language** plugin in Visual Studio Code: You can install it from the VS Code marketplace. This plugin provides a rich development environment for MoonBit, including functionalities like syntax highlighting, code completion, and more.

Once you have these prerequisites fulfilled, let's start by creating a new MoonBit module.

## Creating a New Module

To create a new module, enter the `moon new` command in the terminal, and you will see the module creation wizard. By using all the default values, you can create a new module named `username/hello` in the `my-project` directory.

```bash
$ moon new
Enter the path to create the project (. for current directory): my-project
Select the create mode: exec
Enter your username: username
Enter your project name: hello
Enter your license: Apache-2.0
Created my-project
```

> If you want to use all default values, you can use `moon new my-project` to create a new module named `username/hello` in the `my-project` directory.

## Understanding the Module Directory Structure

After creating the new module, your directory structure should resemble the following:

```bash
my-project
├── LICENSE
├── README.md
├── moon.mod.json
└── src
    ├── lib
    │   ├── hello.mbt
    │   ├── hello_test.mbt
    │   └── moon.pkg.json
    └── main
        ├── main.mbt
        └── moon.pkg.json
```

Here's a brief explanation of the directory structure:

- `moon.mod.json` is used to identify a directory as a MoonBit module. It contains the module's metadata, such as the module name, version, etc. `source` specifies the source directory of the module. The default value is `src`.

  ```json
  {
    "name": "username/hello",
    "version": "0.1.0",
    "readme": "README.md",
    "repository": "",
    "license": "Apache-2.0",
    "keywords": [],
    "description": "",
    "source": "src"
  }
  ```

- `lib` and `main` directories: These are the packages within the module. Each package can contain multiple `.mbt` files, which are the source code files for the MoonBit language. However, regardless of how many `.mbt` files a package has, they all share a common `moon.pkg.json` file. `lib/*_test.mbt` are separate test files in the `lib` package, these files are for blackbox test, so private members of the `lib` package cannot be accessed directly.

- `moon.pkg.json` is package descriptor. It defines the properties of the package, such as whether it is the main package and the packages it imports.

  - `main/moon.pkg.json`:

    ```json
    {
      "is_main": true,
      "import": [
        "username/hello/lib"
      ]
    }
    ```

  Here, `"is_main: true"` declares that the package needs to be linked by the build system into a wasm file.

  - `lib/moon.pkg.json`:

    ```json
    {}
    ```

  This file is empty. Its purpose is simply to inform the build system that this folder is a package.

## Working with Packages

Our `username/hello` module contains two packages: `username/hello/lib` and `username/hello/main`.

The `username/hello/lib` package contains `hello.mbt` and `hello_test.mbt` files:

  `hello.mbt`

  ```moonbit
  pub fn hello() -> String {
      "Hello, world!"
  }
  ```

  `hello_test.mbt`

  ```moonbit
  test "hello" {
    if @lib.hello() != "Hello, world!" {
      fail!("@lib.hello() != \"Hello, world!\"")
    }
  }
  ```

The `username/hello/main` package contains a `main.mbt` file:

  ```moonbit
  fn main {
    println(@lib.hello())
  }
  ```

To execute the program, specify the file system's path to the `username/hello/main` package in the `moon run` command:

```bash
$ moon run ./src/main
Hello, world!
```

You can also omit `./`

```bash
$ moon run src/main
Hello, world!
```

You can test using the `moon test` command:

```bash
$ moon test
Total tests: 1, passed: 1, failed: 0.
```

## Package Importing

In the MoonBit's build system, a module's name is used to reference its internal packages.
To import the `username/hello/lib` package in `src/main/main.mbt`, you need to specify it in `src/main/moon.pkg.json`:

```json
{
  "is_main": true,
  "import": [
    "username/hello/lib"
  ]
}
```

Here, `username/hello/lib` specifies importing the `username/hello/lib` package from the `username/hello` module, so you can use `@lib.hello()` in `main/main.mbt`.

Note that the package name imported in `src/main/moon.pkg.json` is `username/hello/lib`, and `@lib` is used to refer to this package in `src/main/main.mbt`. The import here actually generates a default alias for the package name `username/hello/lib`. In the following sections, you will learn how to customize the alias for a package.

## Creating and Using a New Package

First, create a new directory named `fib` under `lib`:

```bash
mkdir src/lib/fib
```

Now, you can create new files under `src/lib/fib`:

`a.mbt`:

```moonbit
pub fn fib(n : Int) -> Int {
  match n {
    0 => 0
    1 => 1
    _ => fib(n - 1) + fib(n - 2)
  }
}
```

`b.mbt`:

```moonbit
pub fn fib2(num : Int) -> Int {
  fn aux(n, acc1, acc2) {
    match n {
      0 => acc1
      1 => acc2
      _ => aux(n - 1, acc2, acc1 + acc2)
    }
  }

  aux(num, 0, 1)
}
```

`moon.pkg.json`:

```json
{}
```

After creating these files, your directory structure should look like this:

```bash
my-project
├── LICENSE
├── README.md
├── moon.mod.json
└── src
    ├── lib
    │   ├── fib
    │   │   ├── a.mbt
    │   │   ├── b.mbt
    │   │   └── moon.pkg.json
    │   ├── hello.mbt
    │   ├── hello_test.mbt
    │   └── moon.pkg.json
    └── main
        ├── main.mbt
        └── moon.pkg.json
```

In the `src/main/moon.pkg.json` file, import the `username/hello/lib/fib` package and customize its alias to `my_awesome_fibonacci`:

```json
{
  "is_main": true,
  "import": [
    "username/hello/lib",
    {
      "path": "username/hello/lib/fib",
      "alias": "my_awesome_fibonacci"
    }
  ]
}
```

This line imports the `fib` package, which is part of the `lib` package in the `hello` module. After doing this, you can use the `fib` package in `main/main.mbt`. Replace the file content of `main/main.mbt` to:

```moonbit
fn main {
  let a = @my_awesome_fibonacci.fib(10)
  let b = @my_awesome_fibonacci.fib2(11)
  println("fib(10) = \{a}, fib(11) = \{b}")

  println(@lib.hello())
}
```

To execute your program, specify the path to the `main` package:

```bash
$ moon run ./src/main
fib(10) = 55, fib(11) = 89
Hello, world!
```

## Adding Tests

Let's add some tests to verify our fib implementation. Add the following content in `src/lib/fib/a.mbt`:

`src/lib/fib/a.mbt`

```moonbit
test {
  assert_eq!(fib(1), 1)
  assert_eq!(fib(2), 1)
  assert_eq!(fib(3), 2)
  assert_eq!(fib(4), 3)
  assert_eq!(fib(5), 5)
}
```

This code tests the first five terms of the Fibonacci sequence. `test { ... }` defines an inline test block. The code inside an inline test block is executed in test mode.

Inline test blocks are discarded in non-test compilation modes (`moon build` and `moon run`), so they won't cause the generated code size to bloat.

## Stand-alone test files for blackbox tests

Besides inline tests, MoonBit also supports stand-alone test files. Source files ending in `_test.mbt` are considered test files for blackbox tests. For example, inside the `src/lib/fib` directory, create a file named `fib_test.mbt` and paste the following code:

`src/lib/fib/fib_test.mbt`

```moonbit
test {
  assert_eq!(@fib.fib(1), 1)
  assert_eq!(@fib.fib2(2), 1)
  assert_eq!(@fib.fib(3), 2)
  assert_eq!(@fib.fib2(4), 3)
  assert_eq!(@fib.fib(5), 5)
}
```

Notice that the test code uses `@fib` to refer to the `username/hello/lib/fib` package. The build system automatically creates a new package for blackbox tests by using the files that end with `_test.mbt`. This new package will import the current package automatically, allowing you to use `@lib` in the test code.

Finally, use the `moon test` command, which scans the entire project, identifies, and runs all inline tests as well as files ending with `_test.mbt`. If everything is normal, you will see:

```bash
$ moon test
Total tests: 3, passed: 3, failed: 0.
$ moon test -v
test username/hello/lib/hello_test.mbt::hello ok
test username/hello/lib/fib/a.mbt::0 ok
test username/hello/lib/fib/fib_test.mbt::0 ok
Total tests: 3, passed: 3, failed: 0.
```

================================================
File 548: /data/input/moonbit-docs/next/tutorial/index.md
================================================
# Tutorial

Here are some tutorials that may help you learn the programming language:

- [An interactive tour with language basics](https://tour.moonbitlang.com)
- [Tour for Beginners](./tour.md)

```{only} html
[Download this section in Markdown](path:/download/tutorial/summary.md)
```

```{toctree}
:hidden:
tour

================================================
File 549: /data/input/moonbit-docs/next/tutorial/tour.md
================================================
# A Tour of MoonBit for Beginners

This guide is intended for newcomers, and it's not meant to be a 5-minute quick
tour. This article tries to be a succinct yet easy to understand guide for those
who haven't programmed in a way that MoonBit enables them to, that is, in a more
modern, functional way.

See [the General Introduction](../language/index.md) if you want to straight
delve into the language.

## Installation

**The extension**

Currently, MoonBit development support is through the VS Code extension.
Navigate to
[VS Code Marketplace](https://marketplace.visualstudio.com/items?itemName=moonbit.moonbit-lang)
to download MoonBit language support.

**The toolchain**

> (Recommended) If you've installed the extension above, the runtime can be
> directly installed by running 'Install moonbit toolchain' in the action menu
> and you may skip this part:
> ![runtime-installation](/imgs/runtime-installation.png)

We also provide an installation script: Linux & macOS users can install via

```bash
curl -fsSL https://cli.moonbitlang.com/install/unix.sh | bash
```

For Windows users, PowerShell is used:

```powershell
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser; irm https://cli.moonbitlang.com/install/powershell.ps1 | iex
```

This automatically installs MoonBit in `$HOME/.moon` and adds it to your `PATH`.

If you encounter `moon` not found after installation, try restarting your
terminal or VS Code to let the environment variable take effect.

Do notice that MoonBit is not production-ready at the moment, it's under active
development. To update MoonBit, just run the commands above again.

Running `moon help` gives us a bunch of subcommands. But right now the only
commands we need are `build`, `run`, and `new`.

To create a project (or module, more formally), run `moon new`. You will be
greeted with a creation wizard.

If you choose to create an `exec` mode project, you will get:

```
my-project
├── LICENSE
├── moon.mod.json
├── README.md
└── src
    ├── lib
    │   ├── hello.mbt
    │   ├── hello_test.mbt
    │   └── moon.pkg.json
    └── main
        ├── main.mbt
        └── moon.pkg.json
```

which contains a `main` lib containing a `fn main` that serves as the entrance
of the program. Try running `moon run src/main`.

If you choose to create a `lib` mode project, you will get:

```
my-project
├── LICENSE
├── moon.mod.json
├── README.md
└── src
    ├── lib
    │   ├── hello.mbt
    │   ├── hello_test.mbt
    │   └── moon.pkg.json
    ├── moon.pkg.json
    └── top.mbt
```

In this tutorial, we will work with the `lib` mode project, and we assume the
project name is `examine`.

## Example: Finding those who passed

In this example, we will try to find out, given the scores of some students, how
many of them have passed the test?

To do so, we will start with defining our data types, identify our functions,
and write our tests. Then we will implement our functions.

Unless specified, the following will be defined under the file `src/top.mbt`.

### Data types

The [basic data types](/language/fundamentals.md#built-in-data-structures) in MoonBit includes the following:

- `Unit`
- `Bool`
- `Int`, `UInt`, `Int64`, `UInt64`, `Byte`, ...
- `Float`, `Double`
- `Char`, `String`, ...
- `Array[T]`, ...
- Tuples, and still others

To represent a record containing a student ID and a score using a primitive
type, we can use a 2-tuple containing a student ID (of type `String`) and a
score (of type `Double`) as `(String, Double)`. However this is not very
intuitive as we can't identify with other possible data types, such as a record
containing a student ID and the height of the student.

So we choose to declare our own data type using [struct](/language/fundamentals.md#struct):

```{code-block} moonbit
:class: top-level
struct Student {
  id : String
  score : Double
}
```

One can either pass or fail an exam, so the judgement result can be defined
using [enum](/language/fundamentals.md#enum):

```{code-block} moonbit
:class: top-level
enum ExamResult {
  Pass
  Fail
}
```

### Functions

[Function](/language/fundamentals.md#functions) is a piece of code that takes some inputs and produces a result.

In our example, we need to judge whether a student have passed an exam:

```{code-block} moonbit
:class: top-level
fn is_qualified(student : Student, criteria: Double) -> ExamResult {
  ...
}
```

This function takes an input `student` of type `Student` that we've just defined, an input `criteria` of type `Double` as the criteria may be different for each course or different in each country, and returns an `ExamResult`. 

The `...` syntax allows us to leave functions unimplemented for now.

We also need to find out how many students have passed an exam:

```{code-block} moonbit
:class: top-level
fn count_qualified_students(
  students : Array[Student],
  is_qualified : (Student) -> ExamResult
) -> Int {
  ...
}
```

In MoonBit, functions are first-classed, meaning that we can bind a function to a variable, pass a function as parameter or receiving a function as a result.
This function takes an array of students' records and another function that will judge whether a student have passed an exam.

### Writing tests

We can define inline tests to define the expected behavior of the functions. This is also helpful to make sure that there'll be no regressions when we refactor the program.

```{code-block} moonbit
:class: top-level
test "is qualified" {
  assert_eq!(is_qualified(Student::{ id : "0", score : 50.0 }, 60.0), Fail)
  assert_eq!(is_qualified(Student::{ id : "1", score : 60.0 }, 60.0), Pass)
  assert_eq!(is_qualified(Student::{ id : "2", score : 13.0 }, 7.0), Pass)
}
```

We will get an error message, reminding us that `Show` and `Eq` are not implemented for `ExamResult`. 

`Show` and `Eq` are **traits**. A trait in MoonBit defines some common operations that a type should be able to perform.

For example, `Eq` defines that there should be a way to compare two values of the same type with a function called `op_equal`:

```{code-block} moonbit
:class: top-level
trait Eq {
  op_equal(Self, Self) -> Bool
}
```

and `Show` defines that there should be a way to either convert a value of a type into `String` or write it using a `Logger`:

```{code-block} moonbit
:class: top-level
trait Show {
  output(Self, &Logger) -> Unit
  to_string(Self) -> String
}
```

And the `assert_eq` uses them to constraint the passed parameters so that it can compare the two values and print them when they are not equal:

```{code-block} moonbit
:class: top-level
fn assert_eq![A : Eq + Show](value : A, other : A) -> Unit {
  ...
}
```

We need to implement `Eq` and `Show` for our `ExamResult`. There are two ways to do so.

1. By defining an explicit implementation:

    ```{code-block} moonbit
    :class: top-level
    impl Eq for ExamResult with op_equal(self, other) {
      match (self, other) {
        (Pass, Pass) | (Fail, Fail) => true
        _ => false
      }
    }
    ```

    Here we use [pattern matching](/language/fundamentals.md#pattern-matching) to check the cases of the `ExamResult`.

2. Other is by [deriving](/language/derive.md) since `Eq` and `Show` are [builtin traits](/language/methods.md#builtin-traits) and the output for `ExamResult` is quite straightforward:

    ```{code-block} moonbit
    :class: top-level
    enum ExamResult {
      Pass
      Fail
    } derive(Show)
    ```

Now that we've implemented the traits, we can continue with our test implementations:

```{code-block} moonbit
:class: top-level
test "count qualified students" {
  let students = [
    { id: "0", score: 10.0 },
    { id: "1", score: 50.0 },
    { id: "2", score: 61.0 },
  ]
  let criteria1 = fn(student) { is_qualified(student, 10) }
  let criteria2 = fn(student) { is_qualified(student, 50) }
  assert_eq!(count_qualified_students(students, criteria1), 3)
  assert_eq!(count_qualified_students(students, criteria2), 2)
}

```

Here we use [lambda expressions](/language/fundamentals.md#local-functions) to reuse the previously defined `is_qualified` to create different criteria.

We can run `moon test` to see whether the tests succeed or not.

### Implementing the functions

For the `is_qualified` function, it is as easy as a simple comparison:

```{code-block} moonbit
:class: top-level
fn is_qualified(student : Student, criteria : Double) -> ExamResult {
  if student.score >= criteria {
    Pass
  } else {
    Fail
  }
}
```

In MoonBit, the result of the last expression is the return value of the function, and the result of each branch is the value of the `if` expression.

For the `count_qualified_students` function, we need to iterate through the array to check if each student has passed or not.

A naive version is by using a mutable value and a [`for` loop](/language/fundamentals.md#for-loop):

```{code-block} moonbit
:class: top-level
fn count_qualified_students(
  students : Array[Student],
  is_qualified : (Student) -> ExamResult
) -> Int {
  let mut count = 0
  for i = 0; i < students.length(); i = i + 1 {
    if is_qualified(students[i]) == Pass {
      count += 1
    }
  }
  count
}
```

However, this is neither efficient (due to the border check) nor intuitive, so we can replace the `for` loop with a [`for .. in` loop](/language/fundamentals.md#for--in-loop):

```{code-block} moonbit
:class: top-level
fn count_qualified_students(
  students : Array[Student],
  is_qualified : (Student) -> ExamResult
) -> Int {
  let mut count = 0
  for student in students {
    if is_qualified(student) == Pass { count += 1}
  }
  count
}
```

Still another way is use the functions defined for [iterator](/language/fundamentals.md#iterator):

```{code-block} moonbit
:class: top-level
fn count_qualified_students(
  students : Array[Student],
  is_qualified : (Student) -> ExamResult
) -> Int {
  students.iter().filter(fn(student) { is_qualified(student) == Pass }).count()
}
```

Now the tests defined before should pass.

## Making the library available

Congratulation on your first MoonBit library!

You can now share it with other developers so that they don't need to repeat what you have done.

But before that, you have some other things to do.

### Adjusting the visibility

To see how other people may use our program, MoonBit provides a mechanism called ["black box test"](/language/tests.md#blackbox-tests-and-whitebox-tests).

Let's move the `test` block we defined above into a new file `src/top_test.mbt`.

Oops! Now there are errors complaining that:
- `is_qualified` and `count_qualified_students` are unbound
- `Fail` and `Pass` are undefined
- `Student` is not a record type and the field `id` is not found, etc.

All these come from the problem of visibility. By default, a function defined is not visible for other part of the program outside the current package (bound by the current folder).
And by default, a type is viewed as an abstract type, i.e. we know only that there exists a type `Student` and a type `ExamResult`. By using the black box test, you can make sure that
everything you'd like others to have is indeed decorated with the intended visibility.

In order for others to use the functions, we need to add `pub` before the `fn` to make the function public.

In order for others to construct the types and read the content, we need to add `pub(all)` before the `struct` and `enum` to make the types public.

We also need to slightly modify the test of `count qualified students` to add type annotation:

```{code-block} moonbit
:class: top-level
test "count qualified students" {
  let students: Array[@examine.Student] = [
    { id: "0", score: 10.0 },
    { id: "1", score: 50.0 },
    { id: "2", score: 61.0 },
  ]
  let criteria1 = fn(student) { @examine.is_qualified(student, 10) }
  let criteria2 = fn(student) { @examine.is_qualified(student, 50) }
  assert_eq!(@examine.count_qualified_students(students, criteria1), 3)
  assert_eq!(@examine.count_qualified_students(students, criteria2), 2)
}
```

Note that we access the type and the functions with `@examine`, the name of your package. This is how others use your package, but you can omit them in the black box tests.

And now, the compilation should work and the tests should pass again.

### Publishing the library

Now that you've ready, you can publish this project to [mooncakes.io](https://mooncakes.io),
the module registry of MoonBit. You can find other interesting projects there
too.

1. Execute `moon login` and follow the instruction to create your account with
   an existing GitHub account.
2. Modify the project name in `moon.mod.json` to
   `<your github account name>/<project name>`. Run `moon check` to see if
   there's any other affected places in `moon.pkg.json`.
3. Execute `moon publish` and your done. Your project will be available for
   others to use.

By default, the project will be shared under [Apache 2.0](https://www.apache.org/licenses/LICENSE-2.0.html), 
which is a permissive license allowing everyone to use. You can also use other licenses, such as the [MulanPSL 2.0](https://license.coscl.org.cn/MulanPSL2),
by changing the field `license` in `moon.mod.json` and the content of `LICENSE`.

### Closing

At this point, we've learned about the very basic and most not-so-trivial
features of MoonBit, yet MoonBit is a feature-rich, multi-paradigm programming
language. Visit [language tours](https://tour.moonbitlang.com) for more information in grammar and basic types,
and other documents to get a better hold of MoonBit.

